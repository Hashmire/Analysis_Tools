
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>
        <style>
        /* styles.css - CPE JSON Generator styles */

/* Row selection styling */
.table-active {
    background-color: rgba(0, 123, 255, 0.35) !important;
    font-weight: bold;
    border-left: 3px solid #007bff;
}

/* JSON container transitions */
.json-container {
    transition: all 0.3s ease-in-out;
}

/* Button transitions */
.btn-success {
    transition: background-color 0.3s ease;
}

/* Fix for the table row selection styling */
.table-active,
.table-active > td,
.table-active > th {
    background-color: rgba(0, 123, 255, 0.35) !important;  /* Clearly visible blue */
}

.table-hover tbody tr:hover:not(.table-active) {
    background-color: rgba(0, 0, 0, 0.075) !important;  /* Light gray for hover */
}

/* Ensure selected trumps hover */
.table-hover tbody tr.table-active:hover {
    background-color: rgba(0, 123, 255, 0.45) !important;  /* Slightly darker blue when hovering selected row */
}

/* Add pointer cursor to rows that can be selected */
.cpe-row {
    cursor: pointer;
}

/* Pre-formatted code styling */
pre {
    max-height: 400px;
    overflow-y: auto;
    background: #f8f9fa;
    padding: 15px;
    border-radius: 5px;
}

/* Tab navigation styling */
.bg-pivot {
    --bs-bg-opacity: 1;
    background-color: rgb(181, 90, 232) !important;
}

.tab {
    overflow: hidden;
    border: 1px solid #ccc;
    background-color: #f1f1f1;
}

.tab button {
    background-color: inherit;
    float: left;
    border: none;
    outline: none;
    cursor: pointer;
    padding: 14px 16px;
    transition: 0.3s;
}

.tab button:hover {
    background-color: #ddd;
}

.tab button.active {
    background-color: #ccc;
}

.tabcontent {
    display: none;
    margin-left: 10px;
    border: 1px solid #ccc;
    border-top: none;
}

/* Table styling */
table.dataframe {
    table-layout: fixed;
    width: 100%;
}

table.dataframe td:first-child {
    width: 20%;
}

table.dataframe td:last-child {
    width: 80%;
}

/* Linux Kernel special handling badge */
.linux-kernel-badge {
    display: inline-block;
    margin-right: 5px;
    margin-bottom: 8px;
    padding: 3px 6px;
    font-size: 0.75rem;
    font-weight: bold;
    line-height: 1;
    text-align: center;
    white-space: nowrap;
    vertical-align: baseline;
    border-radius: 4px;
    color: #212529;
    background-color: #ffc107;
    cursor: help;
}

.linux-kernel-badge:hover {
    background-color: #e0a800;
}

/* Git versionType badge styling */
.git-versiontype-badge {
    display: inline-block;
    padding: 0.25em 0.6em;
    margin-right: 0.5rem;
    margin-bottom: 0.5rem;
    font-size: 0.75em;
    font-weight: 700;
    line-height: 1;
    text-align: center;
    white-space: nowrap;
    vertical-align: baseline;
    border-radius: 0.25rem;
    background-color: #ffc107; /* warning color */
    color: #212529; /* dark text */
    cursor: help;
    transition: all 0.2s ease-in-out;
}

.git-versiontype-badge:hover {
    background-color: #e0a800; /* darker warning color on hover */
    transform: scale(1.05);
}
        </style>
    </head>
    <body>
    <script>
/**
 * Parse a CPE string to extract vendor and product information
 * @param {string} cpeString - The CPE string to parse
 * @returns {Object} Object with vendor and product properties
 */
function parseCpeString(cpeString) {
    try {
        // For CPE 2.3 formatted strings (cpe:2.3:part:vendor:product:version:...)
        const parts = cpeString.split(':');
        if (parts.length >= 5) {
            return {
                vendor: parts[3].toLowerCase(),
                product: parts[4].toLowerCase()
            };
        }
        return { vendor: null, product: null };
    } catch (e) {
        console.warn("Error parsing CPE string:", e);
        return { vendor: null, product: null };
    }
}

/**
 * Check if a cpeMatch object represents a version range
 * @param {Object} match - The cpeMatch object to check
 * @returns {boolean} True if it's a range match
 */
function isRangeMatch(match) {
    return match.hasOwnProperty('versionStartIncluding') || 
           match.hasOwnProperty('versionStartExcluding') ||
           match.hasOwnProperty('versionEndIncluding') ||
           match.hasOwnProperty('versionEndExcluding');
}

/**
 * Ensure CPE string has standard format with enough components
 * @param {string} cpeBase - The CPE string to normalize
 * @returns {string} Normalized CPE string
 */
function normalizeCpeString(cpeBase) {
    if (!cpeBase) return "cpe:2.3:a:*:*:*:*:*:*:*:*:*";
    
    // Split the CPE into its components
    const parts = cpeBase.split(':');
    
    // Check if we have the basic structure (cpe:2.3:part)
    if (parts.length < 3) {
        console.error("Invalid CPE string format:", cpeBase);
        return "cpe:2.3:a:*:*:*:*:*:*:*:*:*";
    }
    
    // Ensure it has part:vendor:product components
    while (parts.length < 5) {
        parts.push('*');
    }
    
    // Ensure it has version component so we can replace it later
    if (parts.length < 6) {
        parts.push('*');
    }
    
    // For complete format, ensure it has all 13 parts
    while (parts.length < 13) {
        parts.push('*');
    }
    
    return parts.join(':');
}

/**
 * Calculate total versions from raw platform data
 * @param {Set} selectedRows - Set of selected CPE rows
 * @param {Object} rawPlatformData - Raw platform version data
 * @returns {number} Total number of versions
 */
function calculateTotalVersions(selectedRows, rawPlatformData) {
    try {
        if (rawPlatformData && rawPlatformData.versions && Array.isArray(rawPlatformData.versions)) {
            return rawPlatformData.versions.length;
        }
        return selectedRows.size; // Fallback to number of selected rows
    } catch(e) {
        console.error("Error calculating total versions:", e);
        return selectedRows.size;
    }
}

/**
 * Count total CPE matches in a configuration
 * @param {Object} config - Configuration object
 * @returns {number} Count of CPE matches
 */
function getTotalCPEMatches(config) {
    let count = 0;
    if (config.nodes) {
        for (const node of config.nodes) {
            if (node.cpeMatch) {
                count += node.cpeMatch.length;
            }
        }
    } else if (config.cpeMatch) {
        count = config.cpeMatch.length;
    }
    return count;
}

/**
 * Gather metadata from a table
 * @param {number} tableIndex - Index of the table
 * @returns {Object} Table metadata 
 */
function gatherTableMetadata(tableIndex) {
    try {
        // Get the corresponding metadata from data attributes
        const container = document.querySelector(`.cpe-query-container[data-table-index="${tableIndex}"]`);
        
        if (!container) {
            return {
                dataSource: "Unknown",
                sourceId: "Unknown",
                sourceRole: "Unknown",
                rawPlatformData: null
            };
        }
        
        // Extract metadata from data attributes
        const dataSource = container.getAttribute('data-source') || "Unknown";
        const sourceId = container.getAttribute('data-source-id') || "Unknown";
        const sourceRole = container.getAttribute('data-source-role') || "Unknown";
        
        // Get raw platform data if available
        let rawPlatformData = null;
        const platformDataAttr = container.getAttribute('data-platform-data');
        if (platformDataAttr) {
            try {
                rawPlatformData = JSON.parse(platformDataAttr);
                // Add table index and element ID for reference
                rawPlatformData.tableIndex = tableIndex;
                rawPlatformData.elementId = `rawPlatformData_${tableIndex}`;
            } catch (e) {
                console.warn(`Could not parse platform data for table ${tableIndex}:`, e);
            }
        }
        
        return {
            dataSource,
            sourceId,
            sourceRole,
            rawPlatformData
        };
    } catch(e) {
        console.error(`Error gathering metadata for table ${tableIndex}:`, e);
        return {
            dataSource: "Error",
            sourceId: "Error",
            sourceRole: "Error",
            rawPlatformData: null
        };
    }
}

/**
 * Get statistics string from JSON
 * @param {Object} json - The JSON to extract statistics from
 * @param {number} selectionCount - Number of selected items as fallback
 * @returns {string} Formatted statistics string
 */
function getStatisticsString(json, selectionCount) {
    if (!json || !json.configurations || !json.configurations.length || !json.configurations[0]) {
        return `${selectionCount} selected`;
    }
    
    // Get statistics from generatorData.matchStats
    if (json.configurations[0].generatorData && json.configurations[0].generatorData.matchStats) {
        const stats = json.configurations[0].generatorData.matchStats;
        return `${stats.selectedCriteria} Criteria, ${stats.totalMatches} versions` +
               ` (${stats.exactMatches} exact, ${stats.rangeMatches} ranges)`;
    }
    
    // Fallback to simple count
    return `${selectionCount} selected`;
}

/**
 * Create a basic cpeMatch object
 * @param {string} cpeBase - Base CPE string
 * @returns {Object} Basic cpeMatch object
 */
function createCpeMatchObject(cpeBase) {
    // Normalize the CPE string
    const normalizedCpe = normalizeCpeString(cpeBase);
    
    return {
        "criteria": normalizedCpe,
        "matchCriteriaId": "generated_" + Math.random().toString(36).substr(2, 9),
        "vulnerable": true
    };
}

// Global maps to store selections and generated JSONs
const tableSelections = new Map(); // Map<tableId, Set<cpeBase>>
const consolidatedJsons = new Map(); // Map<tableId, JSON>

/**
 * Creates a CPE match object for a given CPE base string
 * @param {string} cpeBase - The base CPE string
 * @returns {Object} A CPE match object
 */

/**
 * Process version data into cpeMatch objects
 * @param {string} cpeBase - The base CPE string
 * @param {Object} rawPlatformData - Raw platform data
 * @returns {Array} Array of cpeMatch objects
 */
function processVersionDataToCpeMatches(cpeBase, rawPlatformData) {
    try {
        // Normalize the base CPE string first to ensure it has enough components
        cpeBase = normalizeCpeString(cpeBase);
        
        const cpeMatches = [];
        
        // Check if we have valid version data
        if (!rawPlatformData || !rawPlatformData.versions || !Array.isArray(rawPlatformData.versions) || rawPlatformData.versions.length === 0) {
            console.debug("No version data available, using basic CPE match");
            const basicMatch = createCpeMatchObject(cpeBase);
            return [basicMatch];
        }
        
        console.debug(`Processing ${rawPlatformData.versions.length} versions for ${cpeBase}`);
        
        // Detect all special case patterns - align with the badges in generateHTML.py
        const hasWildcards = rawPlatformData.versions.some(v => 
            v && (v.lessThanOrEqual && String(v.lessThanOrEqual).includes('*') || 
                 v.lessThan && String(v.lessThan).includes('*')));
                 
        const hasDefaultUnaffected = rawPlatformData.defaultStatus === 'unaffected';
        const affectedVersions = rawPlatformData.versions.filter(v => v && v.status === 'affected');
        const unaffectedVersions = rawPlatformData.versions.filter(v => v && v.status === 'unaffected');
        const hasInverseStatus = hasDefaultUnaffected && affectedVersions.length > 0;
        const hasMixedStatus = affectedVersions.length > 0 && unaffectedVersions.length > 1;
        
        const hasVersionChanges = rawPlatformData.versions.some(v => 
            v && v.changes && Array.isArray(v.changes) && v.changes.length > 0);
            
        const versionBranches = new Set();
        rawPlatformData.versions.forEach(v => {
            if (v && v.version && typeof v.version === 'string') {
                const parts = v.version.split('.');
                if (parts.length >= 2) {
                    versionBranches.add(`${parts[0]}.${parts[1]}`);
                }
            }
        });
        const hasMultipleBranches = versionBranches.size >= 3;
        
        const specialVersionTypes = new Set();
        rawPlatformData.versions.forEach(v => {
            if (v && v.versionType && !['semver', 'string'].includes(v.versionType) && v.versionType !== 'git') {
                specialVersionTypes.add(v.versionType);
            }
        });
        const hasSpecialVersionTypes = specialVersionTypes.size > 0;
        
        // Check if any special case applies
        const needsSpecialHandling = hasWildcards || hasInverseStatus || hasMixedStatus || 
                                    hasVersionChanges || hasMultipleBranches || hasSpecialVersionTypes;
        
        // Use special handling if needed
        if (needsSpecialHandling) {
            console.debug("Special case detected: Using special version structure processing");
            return processSpecialVersionStructure(cpeBase, rawPlatformData);
        }
        
        // Standard processing for other products
        console.debug(`Using standard processing for ${cpeBase}`);
        
        // Determine default vulnerability status
        const defaultIsAffected = rawPlatformData.defaultStatus === "affected";
        
        for (const versionInfo of rawPlatformData.versions) {
            if (!versionInfo) continue;
            
            // Determine if this version is vulnerable based on status
            const isVulnerable = versionInfo.status === "affected";
            
            // Create cpeMatch using the consolidated function
            const cpeMatch = createCpeMatchFromVersionInfo(cpeBase, versionInfo, isVulnerable);
            cpeMatches.push(cpeMatch);
        }
        
        if (cpeMatches.length === 0) {
            console.debug("No matches created, using basic CPE match");
            const basicMatch = createCpeMatchObject(cpeBase);
            cpeMatches.push(basicMatch);
        }
        
        return cpeMatches;
    } catch (e) {
        console.error("Error processing version data:", e);
        const basicMatch = createCpeMatchObject(cpeBase);
        return [basicMatch];
    }
}

/**
 * Handle version patterns with wildcard in ranges
 * @param {string} cpeBase - Base CPE string
 * @param {Object} versionInfo - Version info with wildcard
 * @param {boolean} isVulnerable - Whether this is a vulnerable match
 * @returns {Array} Array of CPE matches covering the wildcard pattern
 */
function processWildcardVersionPattern(cpeBase, versionInfo, isVulnerable) {
    const matches = [];
    
    // Handle wildcards in lessThanOrEqual
    if (versionInfo.lessThanOrEqual && String(versionInfo.lessThanOrEqual).includes('*')) {
        const wildcard = versionInfo.lessThanOrEqual;
        
        // Extract the prefix before the wildcard (e.g., "5.4." from "5.4.*")
        const prefix = wildcard.split('*')[0].replace(/\.$/, '');
        const parts = prefix.split('.');
        
        // If we have a valid version structure like "5.4.*"
        if (parts.length >= 2) {
            const majorVersion = parseInt(parts[0], 10);
            const minorVersion = parseInt(parts[1], 10);
            
            if (!isNaN(majorVersion) && !isNaN(minorVersion)) {
                // Create range from exact version to next minor
                const startVersion = versionInfo.version || `${majorVersion}.${minorVersion}`;
                const endVersion = `${majorVersion}.${minorVersion + 1}`;
                
                matches.push({
                    criteria: cpeBase,
                    matchCriteriaId: generateMatchCriteriaId(),
                    vulnerable: isVulnerable,
                    versionStartIncluding: startVersion,
                    versionEndExcluding: endVersion
                });
                
                console.debug(`Created range for wildcard ${wildcard}: ${startVersion} to ${endVersion}`);
            }
        }
    }
    
    // If no specific wildcard handling was applied, fall back to standard handling
    if (matches.length === 0) {
        matches.push(createCpeMatchFromVersionInfo(cpeBase, versionInfo, isVulnerable));
    }
    
    return matches;
}

/**
 * Enhanced version of the special structure handler that aligns with our badges
 * @param {string} cpeBase - Base CPE string
 * @param {Object} rawPlatformData - Raw platform data
 * @returns {Array} Array of cpeMatch objects
 */
function processSpecialVersionStructure(cpeBase, rawPlatformData) {
    console.debug("Processing special version structure");
    const cpeMatches = [];
    const defaultIsAffected = rawPlatformData.defaultStatus === "affected";
    
    try {
        // Group versions by status and check for wildcards
        const affectedVersions = [];
        const unaffectedVersions = [];
        const wildcardVersions = [];
        
        rawPlatformData.versions.forEach(versionInfo => {
            if (!versionInfo) return;
            
            // Track versions with wildcards
            if ((versionInfo.lessThanOrEqual && String(versionInfo.lessThanOrEqual).includes('*')) || 
                (versionInfo.lessThan && String(versionInfo.lessThan).includes('*'))) {
                wildcardVersions.push(versionInfo);
            }
            
            // Group by affected status
            if (versionInfo.status === "affected") {
                affectedVersions.push(versionInfo);
            } else if (versionInfo.status === "unaffected") {
                unaffectedVersions.push(versionInfo);
            }
        });
        
        console.debug(`Found ${affectedVersions.length} affected, ${unaffectedVersions.length} unaffected, and ${wildcardVersions.length} wildcard version entries`);
        
        // Handle versions with changes field
        for (const versionInfo of rawPlatformData.versions) {
            if (versionInfo && versionInfo.changes && Array.isArray(versionInfo.changes) && versionInfo.changes.length > 0) {
                for (const change of versionInfo.changes) {
                    if (change.status === "fixed" && change.at) {
                        // Create range from affected version up to fix
                        cpeMatches.push({
                            criteria: cpeBase,
                            matchCriteriaId: generateMatchCriteriaId(),
                            vulnerable: true,
                            versionStartIncluding: versionInfo.version,
                            versionEndExcluding: change.at
                        });
                        
                        console.debug(`Added range for version with fix: ${versionInfo.version} to ${change.at}`);
                    }
                }
            }
        }
        
        // Special case 1: Default affected with unaffected ranges
        if (defaultIsAffected && unaffectedVersions.length > 0) {
            // Process gaps between unaffected ranges
            processGapsBetweenUnaffectedRanges(cpeBase, unaffectedVersions, affectedVersions, cpeMatches);
        } 
        // Special case 2: Default unaffected with specific affected versions
        else if (!defaultIsAffected && affectedVersions.length > 0) {
            // Add each affected version explicitly
            for (const affectedInfo of affectedVersions) {
                // Process wildcards separately
                if ((affectedInfo.lessThanOrEqual && String(affectedInfo.lessThanOrEqual).includes('*')) || 
                    (affectedInfo.lessThan && String(affectedInfo.lessThan).includes('*'))) {
                    const wildcardMatches = processWildcardVersionPattern(cpeBase, affectedInfo, true);
                    cpeMatches.push(...wildcardMatches);
                } else {
                    const cpeMatch = createCpeMatchFromVersionInfo(cpeBase, affectedInfo, true);
                    cpeMatches.push(cpeMatch);
                }
            }
        }
        // Special case 3: Just process wildcards if present
        else if (wildcardVersions.length > 0) {
            for (const wildcardInfo of wildcardVersions) {
                const isVulnerable = wildcardInfo.status === "affected";
                const wildcardMatches = processWildcardVersionPattern(cpeBase, wildcardInfo, isVulnerable);
                cpeMatches.push(...wildcardMatches);
            }
        }
        
        // If no matches were created yet, process all versions normally
        if (cpeMatches.length === 0) {
            console.debug("No special case matches created, processing all versions normally");
            for (const versionInfo of rawPlatformData.versions) {
                if (!versionInfo) continue;
                const isVulnerable = versionInfo.status === "affected";
                const cpeMatch = createCpeMatchFromVersionInfo(cpeBase, versionInfo, isVulnerable);
                cpeMatches.push(cpeMatch);
            }
        }
        
        console.debug(`Generated ${cpeMatches.length} CPE matches for special version structure`);
        
        if (cpeMatches.length === 0) {
            console.debug("No matches created, using basic CPE match");
            const basicMatch = createCpeMatchObject(cpeBase);
            return [basicMatch];
        }
        
        return cpeMatches;
    } catch (e) {
        console.error("Error in special version structure processing:", e);
        console.error(e.stack);
        const basicMatch = createCpeMatchObject(cpeBase);
        return [basicMatch];
    }
}

/**
 * Special handler for special version structure
 * @param {string} cpeBase - Base CPE string
 * @param {Object} rawPlatformData - Raw platform data
 * @returns {Array} Array of cpeMatch objects
 */
function processSpecialVersionStructure(cpeBase, rawPlatformData) {
    console.debug("Processing special version structure");
    const cpeMatches = [];
    const defaultIsAffected = rawPlatformData.defaultStatus === "affected";
    
    try {
        // Group versions by status (affected vs unaffected)
        const affectedVersions = [];
        const unaffectedVersions = [];
        
        rawPlatformData.versions.forEach(versionInfo => {
            if (versionInfo.status === "affected") {
                affectedVersions.push(versionInfo);
            } else if (versionInfo.status === "unaffected") {
                unaffectedVersions.push(versionInfo);
            }
        });
        
        console.debug(`Found ${affectedVersions.length} affected and ${unaffectedVersions.length} unaffected version entries`);
        
        // For defaultStatus=affected, handle unaffected ranges and gaps
        if (defaultIsAffected) {
            // First pass: process unaffected ranges and generate the affected ranges
            if (unaffectedVersions.length > 0) {
                processGapsBetweenUnaffectedRanges(cpeBase, unaffectedVersions, affectedVersions, cpeMatches);
            }
            
            // Second pass: add any explicit affected version not covered by the above
            for (const affectedInfo of affectedVersions) {
                // Check if this explicit affected entry is already covered by our generated ranges
                let isCovered = false;
                
                // Simple case: it's a single version with no range qualifiers
                if (affectedInfo.version && !affectedInfo.lessThan && !affectedInfo.lessThanOrEqual &&
                    !affectedInfo.greaterThan && !affectedInfo.greaterThanOrEqual) {
                    
                    // Check if this version is covered by any of our generated ranges
                    for (const cpeMatch of cpeMatches) {
                        if (isVersionCoveredByRange(affectedInfo.version, cpeMatch)) {
                            isCovered = true;
                            break;
                        }
                    }
                    
                    // If not covered, add it
                    if (!isCovered) {
                        const cpeMatch = createCpeMatchFromVersionInfo(cpeBase, affectedInfo, true);
                        cpeMatches.push(cpeMatch);
                    }
                }
                // For complex ranges, always add them explicitly
                else {
                    const cpeMatch = createCpeMatchFromVersionInfo(cpeBase, affectedInfo, true);
                    cpeMatches.push(cpeMatch);
                }
            }
        }
        // For defaultStatus=unaffected, just add the explicit affected entries
        else {
            for (const affectedInfo of affectedVersions) {
                const cpeMatch = createCpeMatchFromVersionInfo(cpeBase, affectedInfo, true);
                cpeMatches.push(cpeMatch);
            }
        }
        
        console.debug(`Generated ${cpeMatches.length} CPE matches for special version structure`);
        
        if (cpeMatches.length === 0) {
            console.debug("No matches created, using basic CPE match");
            const basicMatch = createCpeMatchObject(cpeBase);
            return [basicMatch];
        }
        
        return cpeMatches;
    } catch (e) {
        console.error("Error in special version structure processing:", e);
        console.error(e.stack);
        const basicMatch = createCpeMatchObject(cpeBase);
        return [basicMatch];
    }
}

/**
 * Check if a version range is already covered by explicit affected entries
 * @param {string} startVersion - Start version of range
 * @param {string|null} endVersion - End version of range (null for unlimited)
 * @param {Array} affectedVersions - Array of explicitly affected version info
 * @returns {boolean} True if the range is already covered
 */
function isRangeCoveredByExplicitEntries(startVersion, endVersion, affectedVersions) {
    for (const affectedInfo of affectedVersions) {
        // Determine the bounds of this affected entry
        let affectedStart = null;
        let affectedEnd = null;
        
        // Get start bound
        if (affectedInfo.greaterThanOrEqual) {
            affectedStart = affectedInfo.greaterThanOrEqual;
        } else if (affectedInfo.greaterThan) {
            affectedStart = incrementVersion(affectedInfo.greaterThan);
        } else if (affectedInfo.version) {
            affectedStart = affectedInfo.version;
        }
        
        // Get end bound
        if (affectedInfo.lessThan) {
            affectedEnd = affectedInfo.lessThan;
        } else if (affectedInfo.lessThanOrEqual) {
            affectedEnd = incrementVersion(affectedInfo.lessThanOrEqual);
        }
        
        // Check if this affected entry covers the entire range we're looking at
        if (affectedStart && compareVersions(affectedStart, startVersion) <= 0) {
            // The affected start is earlier than or equal to our start
            if (!affectedEnd || !endVersion || compareVersions(affectedEnd, endVersion) >= 0) {
                // The affected end is later than or equal to our end (or unlimited)
                return true;
            }
        }
    }
    
    return false;
}

/**
 * Update the previous upper bound based on unaffected range info
 * @param {Object} unaffectedInfo - Unaffected version info object
 * @returns {string|null} The new upper bound for the next affected range
 */
function calculateNextUpperBound(unaffectedInfo) {
    if (unaffectedInfo.lessThanOrEqual === "*") {
        // This covers everything above the version
        return null; // No more ranges above this
    } else if (unaffectedInfo.lessThanOrEqual && unaffectedInfo.lessThanOrEqual.includes("*")) {
        // Handle version wildcards like "5.4.*"
        return getNextVersionAfterWildcard(unaffectedInfo.lessThanOrEqual);
    } else if (unaffectedInfo.lessThan) {
        return unaffectedInfo.lessThan;
    } else if (unaffectedInfo.lessThanOrEqual) {
        // Add a tiny increment to make it exclusive
        return incrementVersion(unaffectedInfo.lessThanOrEqual);
    } else {
        // Single version - the upper bound is the next version
        return incrementVersion(unaffectedInfo.version);
    }
}

/**
 * Get the next version after a wildcard pattern
 * @param {string} versionPattern - Version pattern like "5.4.*"
 * @returns {string} Next version
 */
function getNextVersionAfterWildcard(versionPattern) {
    // Handle wildcard patterns like "5.4.*"
    if (versionPattern.includes('*')) {
        // Extract the prefix before the wildcard
        const prefix = versionPattern.split('*')[0].replace(/\.$/, '');
        
        // Split into parts
        const parts = prefix.split('.');
        
        // For patterns like "5.4.*", we want to get "5.5"
        // For patterns like "5.4.2.*", we want to get "5.4.3"
        if (parts.length >= 2) {
            // Increment the last component before the wildcard
            const lastPart = parseInt(parts[parts.length - 1], 10);
            if (!isNaN(lastPart)) {
                parts[parts.length - 1] = (lastPart + 1).toString();
                
                // Log patch-level wildcards for tracking
                if (parts.length > 2) {
                    console.warn(`Handling patch-level wildcard: ${versionPattern} -> ${parts.join('.')}`);
                }
                
                return parts.join('.');
            }
        }
        return prefix; // Fallback: Return the prefix unchanged
    }
    
    // For non-wildcard patterns, defer to incrementVersion
    return incrementVersion(versionPattern);
}

/**
 * Helper function to sort version info objects
 * @param {Array} versionInfoArray - Array of version info objects
 * @returns {Array} Sorted array
 */
function sortVersionInfo(versionInfoArray) {
    return [...versionInfoArray].sort((a, b) => {
        // First compare by version
        const verA = a.version || "0";
        const verB = b.version || "0";
        
        // If versionType is semver, use semver-style comparison
        if ((a.versionType === "semver" || b.versionType === "semver")) {
            return compareVersions(verA, verB);
        } else {
            // Simple string comparison for non-semver
            return verA.localeCompare(verB);
        }
    });
}

/**
 * Compare two version strings
 * @param {string} versionA - First version
 * @param {string} versionB - Second version
 * @returns {number} Comparison result (-1, 0, 1)
 */
function compareVersions(versionA, versionB) {
    const aParts = versionA.split('.').map(part => parseInt(part, 10) || 0);
    const bParts = versionB.split('.').map(part => parseInt(part, 10) || 0);
    
    // Compare version components
    for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
        const aVal = i < aParts.length ? aParts[i] : 0;
        const bVal = i < bParts.length ? bParts[i] : 0;
        
        if (aVal !== bVal) {
            return aVal - bVal;
        }
    }
    
    return 0;
}

/**
 * Increment a version string slightly
 * @param {string} version - Version string
 * @returns {string} Incremented version
 */
function incrementVersion(version) {
    if (!version) return version;
    
    // For semantic versions
    if (version.includes('.')) {
        const parts = version.split('.');
        const lastPart = parseInt(parts[parts.length - 1], 10);
        
        if (!isNaN(lastPart)) {
            parts[parts.length - 1] = (lastPart + 1).toString();
            return parts.join('.');
        }
    }
    
    // For simple integer versions
    const numVersion = parseInt(version, 10);
    if (!isNaN(numVersion)) {
        return (numVersion + 1).toString();
    }
    
    return version;
}

/**
 * Generate a unique match criteria ID
 * @returns {string} A unique match criteria ID
 */
function generateMatchCriteriaId() {
    return 'generated_' + Math.random().toString(36).substr(2, 9).toUpperCase();
}

/**
 * Process basic version data into a configuration object
 * @param {Set} selectedCPEs - Set of selected CPE base strings or DOM elements
 * @param {Object} rawPlatformData - Raw platform data
 * @returns {Object} Configuration object
 */
function processBasicVersionData(selectedCPEs, rawPlatformData) {
    const config = {
        "operator": "OR",
        "negate": false,
        "cpeMatch": []
    };
    
    // Store the tableIndex in rawPlatformData for reference
    if (rawPlatformData && !rawPlatformData.tableIndex && rawPlatformData.elementId) {
        // Extract table index from element ID if present
        const match = rawPlatformData.elementId.match(/rawPlatformData_(\d+)/);
        if (match && match[1]) {
            rawPlatformData.tableIndex = match[1];
        }
    }
    
    // Process each selected CPE
    selectedCPEs.forEach(cpeRow => {
        let cpeBase;
        
        // Check if cpeRow is a DOM element or a string
        if (typeof cpeRow === 'string') {
            cpeBase = cpeRow;
        } else if (cpeRow && typeof cpeRow.getAttribute === 'function') {
            cpeBase = cpeRow.getAttribute('data-cpe-base');
        } else {
            console.warn("Invalid CPE row type:", typeof cpeRow);
            return;
        }
        
        if (!cpeBase) {
            console.warn("No CPE base found for row:", cpeRow);
            return;
        }
        
        // Process version data into cpeMatch objects
        const cpeMatches = processVersionDataToCpeMatches(cpeBase, rawPlatformData);
        
        console.debug(`Generated ${cpeMatches.length} CPE matches for ${cpeBase}`);
        
        // Add all cpeMatches to the configuration
        config.cpeMatch.push(...cpeMatches);
    });
    
    return config;
}

/**
 * Processes the basic version data for selected CPEs
 * @param {Set} selectedRows - Set of selected CPE rows
 * @param {Object} rawPlatformData - Raw platform data
 * @param {Object} json - The JSON object to update
 * @returns {number} Total versions processed
 */
function processBasicVersionDataOld(selectedRows, rawPlatformData, json) {
    let totalVersions = 0;
    
    // Add cpeMatch objects for each selected CPE, processing version information
    selectedRows.forEach(cpeBase => {
        // If we have raw platform data, process each version into cpeMatch objects
        if (rawPlatformData) {
            const cpeMatches = processVersionDataToCpeMatches(cpeBase, rawPlatformData);
            
            // Track version statistics
            cpeMatches.forEach(match => {
                json.configurations[0].cpeMatch.push(match);
                totalVersions++;
            });
        } else {
            // No version data, just use the basic CPE
            const basicMatch = createCpeMatchObject(cpeBase);
            json.configurations[0].cpeMatch.push(basicMatch);
            totalVersions++;
        }
    });
    
    // IMPORTANT: Return the totalVersions to be used by calculateAndAddStatistics
    return totalVersions;
}

/**
 * Process JSON based on the data source
 * @param {Object} json - The JSON object to update
 * @param {Set} selectedRows - Set of selected CPE rows
 * @param {Object} metadata - Table metadata
 * @returns {boolean} True if processing was successful
 */
function processJsonBasedOnSourceOld(json, selectedRows, metadata) {
    try {
        // Process the JSON structure based on the data source
        const dataSource = metadata.dataSource;
        let totalVersions = 0;
        
        if (dataSource === 'NVDAPI') {
            // Special handling for NVD API data
            totalVersions = processBasicVersionDataOld(selectedRows, metadata.rawPlatformData, json);
        } else {
            // Default handling for other data sources
            totalVersions = processBasicVersionDataOld(selectedRows, metadata.rawPlatformData, json);
        }
        
        // Store totalVersions in the metadata for use in calculateAndAddStatistics
        metadata.totalVersions = totalVersions;
        
        return true;
    } catch(e) {
        console.error("Error processing JSON based on source:", e);
        return false;
    }
}

/**
 * Process JSON based on source type
 * @param {Set} selectedCPEs - Set of selected CPE base strings
 * @param {Object} rawPlatformData - Raw platform data
 * @param {Object} metadata - Table metadata
 * @returns {Object} Generated JSON
 */
function processJsonBasedOnSource(selectedCPEs, rawPlatformData, metadata) {
    // Create a base JSON structure
    const json = {
        "configurations": []
    };
    
    try {
        console.debug(`Processing JSON based on ${metadata.dataSource} source with ${selectedCPEs.size} selected CPEs`);
        
        // Check if we have embedded configuration (for NVD data)
        if (metadata.dataSource === 'NVDAPI' && rawPlatformData && rawPlatformData.rawConfigData) {
            // For NVD API data, we have the complete configuration
            console.debug("Using embedded NVD configuration");
            json.configurations.push(rawPlatformData.rawConfigData);
        } 
        // Regular version data processing
        else {
            console.debug("Processing version data for CPEs");
            // Process the basic version data
            const config = processBasicVersionData(selectedCPEs, rawPlatformData);
            
            // Add metadata
            config.generatorData = {
                "generatedFromSource": {
                    "dataSource": metadata.dataSource || "Unknown",
                    "sourceId": metadata.sourceId || "Unknown",
                    "sourceRole": metadata.sourceRole || "Unknown"
                }
            };
            
            json.configurations.push(config);
        }
        
        // Calculate and add statistics
        calculateAndAddStatistics(json, selectedCPEs, rawPlatformData, metadata);
        
        return json;
    } catch (e) {
        console.error("Error processing JSON:", e);
        
        // Create a fallback configuration
        json.configurations.push({
            "operator": "OR",
            "cpeMatch": [],
            "generatorData": {
                "generatedFromSource": {
                    "dataSource": metadata.dataSource || "Unknown",
                    "sourceId": metadata.sourceId || "Unknown",
                    "sourceRole": metadata.sourceRole || "Unknown",
                    "error": e.message
                }
            }
        });
        
        return json;
    }
}

/**
 * Calculate and add statistics to the JSON
 * @param {Object} json - The JSON to update
 * @param {Set} selectedRows - Selected rows
 * @param {Object} rawPlatformData - Raw platform data
 * @param {Object} metadata - Table metadata
 */
function calculateAndAddStatistics(json, selectedRows, rawPlatformData, metadata) {
    const selectionCount = selectedRows.size;
    let totalMatches = 0;
    let rangeMatches = 0;
    let exactMatches = 0;
    
    // Process statistics based on final JSON structure
    if (json.configurations[0].cpeMatch && json.configurations[0].cpeMatch.length > 0) {
        totalMatches = json.configurations[0].cpeMatch.length;
        
        // Count range vs exact matches
        json.configurations[0].cpeMatch.forEach(match => {
            if (isRangeMatch(match)) {
                rangeMatches++;
            } else {
                exactMatches++;
            }
        });
    } else if (json.configurations[0].nodes) {
        json.configurations[0].nodes.forEach(node => {
            if (node.cpeMatch) {
                totalMatches += node.cpeMatch.length;
                
                // Count range vs exact matches in this node
                node.cpeMatch.forEach(match => {
                    if (isRangeMatch(match)) {
                        rangeMatches++;
                    } else {
                        exactMatches++;
                    }
                });
            }
        });
    }
    
    // Always create generatorData if it doesn't exist
    if (!json.configurations[0].generatorData) {
        json.configurations[0].generatorData = {
            "generatedFromSource": {
                "dataSource": metadata.dataSource || "Unknown",
                "sourceId": metadata.sourceId || "Unknown",
                "sourceRole": metadata.sourceRole || "Unknown"
            }
        };
    }
    
    // Store statistics in generatorData.matchStats only
    json.configurations[0].generatorData.matchStats = {
        totalMatches: totalMatches,
        rangeMatches: rangeMatches,
        exactMatches: exactMatches,
        selectedCriteria: selectionCount
    };
    
    // Remove any old-style statistics to avoid confusion
    if (json.configurations[0].matchStats) {
        delete json.configurations[0].matchStats;
    }
    if (json.configurations[0].versionStats) {
        delete json.configurations[0].versionStats;
    }
}

/**
 * Generate JSON with all configurations from all tables
 * @returns {Object} Master JSON with all configurations
 */
function generateAllConfigurationsJson() {
    try {
        // Create master JSON with all configurations
        const masterJson = {
            // Add the timestamp directly here, at the top level
            "generatorTimestamp": window.timestampHandler ? window.timestampHandler.getTimestamp() : new Date().toISOString(),
            "configurations": []
        };
        
        // Add each table's configuration as a separate node in the configurations array
        consolidatedJsons.forEach((json, tableId) => {
            if (json && json.configurations && json.configurations.length > 0) {
                // Each configuration from a table should retain its generatorData
                json.configurations.forEach(config => {
                    // Ensure the generatorData structure is preserved
                    masterJson.configurations.push(config);
                });
            }
        });
        
        return masterJson;
    } catch(e) {
        console.error("Error generating all configurations JSON:", e);
        // Even in case of error, include the timestamp
        return { 
            "generatorTimestamp": window.timestampHandler ? window.timestampHandler.getTimestamp() : new Date().toISOString(),
            "configurations": [] 
        };
    }
}

/**
 * Update the consolidated JSON for a table
 * @param {string} tableId - ID of the table
 */
function updateConsolidatedJson(tableId) {
    try {
        // Get the selected rows for this table
        const selectedRows = tableSelections.get(tableId);
        
        if (!selectedRows || selectedRows.size === 0) {
            console.debug(`No rows selected for table ${tableId}`);
            consolidatedJsons.set(tableId, null);
            
            // Always update button state even if no rows are selected
            updateButton(tableId, false);
            
            // Update JSON display if it's visible
            updateJsonDisplayIfVisible(tableId);
            
            return;
        }
        
        // Extract the table index from the table ID
        const tableIndex = tableId.split('_')[1];
        
        // Extract metadata and raw platform data from the row data table
        const extractedData = extractDataFromTable(tableIndex);
        
        // Process the JSON based on the source
        const json = processJsonBasedOnSource(
            selectedRows, 
            extractedData.rawPlatformData, 
            extractedData.metadata
        );
        
        // Store the consolidated JSON for this table
        consolidatedJsons.set(tableId, json);
        
        console.debug(`Updated consolidated JSON for table ${tableId}`);
        
        // Find the consolidated JSON button
        const showButton = document.getElementById(`showConsolidatedJson_${tableId}`);
        
        // Update button with selection information
        if (showButton) {
            const statsStr = getStatisticsString(json, selectedRows.size);
            
            // Check if the display is currently visible
            const display = document.getElementById(`consolidatedJsonDisplay_${tableId}`);
            const isVisible = display && display.style.display !== 'none';
            
            // Update button text
            showButton.textContent = isVisible ? 
                `Hide Consolidated JSON (${statsStr})` : 
                `Show Consolidated JSON (${statsStr})`;
            
            // Update button state
            showButton.disabled = false;
            
            // Update button styling based on display visibility
            if (isVisible) {
                showButton.classList.remove('btn-primary');
                showButton.classList.add('btn-success');
            } else {
                showButton.classList.remove('btn-success');
                showButton.classList.add('btn-primary');
            }
        }
        
        // Always update the JSON display if it's visible
        updateJsonDisplayIfVisible(tableId);
        
        // Also update the "Export All" button and configurations display
        updateExportAllButton();
        updateAllConfigurationsDisplay();
        
    } catch(e) {
        console.error(`Error updating consolidated JSON for table ${tableId}:`, e);
        consolidatedJsons.set(tableId, null);
    }
}

/**
 * Extract metadata and rawPlatformData from the row data table
 * @param {string|number} tableIndex - Index of the table
 * @returns {Object} Extracted data including metadata and rawPlatformData
 */
function extractDataFromTable(tableIndex) {
    // Default metadata
    const result = {
        metadata: {
            dataSource: "Unknown",
            sourceId: "Unknown", 
            sourceRole: "Unknown"
        },
        rawPlatformData: null
    };
    
    // Get the row data table
    const rowDataTable = document.getElementById(`rowDataTable_${tableIndex}`);
    
    if (rowDataTable) {
        // Get all rows in the table
        const rows = rowDataTable.querySelectorAll('tr');
        
        // Process the first three rows to extract metadata
        for (let i = 0; i < rows.length && i < 3; i++) {
            const cells = rows[i].querySelectorAll('td');
            if (cells.length >= 2) {
                const labelCell = cells[0];
                const valueCell = cells[1];
                
                // Extract data source from first row
                if (i === 0 && labelCell.textContent.trim() === "Data Source") {
                    result.metadata.dataSource = valueCell.textContent.trim();
                    console.debug(`Found dataSource: ${result.metadata.dataSource}`);
                }
                
                // Extract source ID from second row
                else if (i === 1 && labelCell.textContent.trim() === "Source ID") {
                    const spanWithTitle = valueCell.querySelector('span[title]');
                    if (spanWithTitle) {
                        const titleText = spanWithTitle.getAttribute('title');
                        console.debug(`Source ID title text: "${titleText}"`);
                        
                        // Match pattern: "Source Identifiers: something, UUID"
                        const uuidPattern = /Source Identifiers:.*?([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i;
                        const match = titleText.match(uuidPattern);
                        
                        if (match && match[1]) {
                            result.metadata.sourceId = match[1];
                            console.debug(`Found sourceId UUID: ${result.metadata.sourceId}`);
                        } else {
                            // If no UUID found, use the text content as fallback
                            result.metadata.sourceId = valueCell.textContent.trim();
                            console.debug(`UUID not found in title, using text as sourceId: ${result.metadata.sourceId}`);
                        }
                    } else {
                        // No span with title, just use the text content
                        result.metadata.sourceId = valueCell.textContent.trim();
                        console.debug(`No title attribute found, using text as sourceId: ${result.metadata.sourceId}`);
                    }
                }
                
                // Extract source role from third row
                else if (i === 2 && labelCell.textContent.trim() === "Source Role") {
                    result.metadata.sourceRole = valueCell.textContent.trim();
                    console.debug(`Found sourceRole: ${result.metadata.sourceRole}`);
                }
            }
        }
        
        // Direct access by ID for rawPlatformData - simple and reliable
        const rawDataElement = document.getElementById(`rawPlatformData_${tableIndex}`);
        if (rawDataElement && rawDataElement.textContent) {
            try {
                result.rawPlatformData = JSON.parse(rawDataElement.textContent);
                console.debug(`Raw platform data found for table ${tableIndex}`);
            } catch (parseError) {
                console.error(`Error parsing raw platform data for table ${tableIndex}:`, parseError);
            }
        } else {
            console.debug(`No raw platform data element found with ID rawPlatformData_${tableIndex}`);
        }
    } else {
        console.debug(`Row data table not found for index ${tableIndex}`);
    }
    
    return result;
}

/**
 * Get the next version after a wildcard pattern
 * @param {string} versionPattern - Version pattern like "5.4.*"
 * @returns {string} Next version like "5.5"
 */
function getNextVersionAfterWildcard(versionPattern) {
    // Handle wildcard patterns like "5.4.*"
    if (versionPattern.includes('*')) {
        // Extract the prefix before the wildcard
        const prefix = versionPattern.split('*')[0].replace(/\.$/, '');
        
        // Split into parts
        const parts = prefix.split('.');
        
        // For patterns like "5.4.*", we want to get "5.5"
        if (parts.length >= 2) {
            // Increment the last component before the wildcard
            const lastPart = parseInt(parts[parts.length - 1], 10);
            if (!isNaN(lastPart)) {
                parts[parts.length - 1] = (lastPart + 1).toString();
                return parts.join('.');
            }
        }
        return prefix; // Fallback: Return the prefix unchanged
    }
    
    // For non-wildcard patterns, defer to incrementVersion
    return incrementVersion(versionPattern);
}

/**
 * Update the previous upper bound based on unaffected range info
 * @param {Object} unaffectedInfo - Unaffected version info object
 * @returns {string|null} The new upper bound for the next affected range
 */
function calculateNextUpperBound(unaffectedInfo) {
    if (unaffectedInfo.lessThanOrEqual === "*") {
        // This covers everything above the version
        return null; // No more ranges above this
    } else if (unaffectedInfo.lessThanOrEqual && unaffectedInfo.lessThanOrEqual.includes("*")) {
        // Handle version wildcards like "5.4.*"
        return getNextVersionAfterWildcard(unaffectedInfo.lessThanOrEqual);
    } else if (unaffectedInfo.lessThan) {
        return unaffectedInfo.lessThan;
    } else if (unaffectedInfo.lessThanOrEqual) {
        // Add a tiny increment to make it exclusive
        return incrementVersion(unaffectedInfo.lessThanOrEqual);
    } else {
        // Single version - the upper bound is the next version
        return incrementVersion(unaffectedInfo.version);
    }
}


/**
 * Create a CPE match object from version info
 * @param {string} cpeBase - Base CPE string
 * @param {Object} versionInfo - Version info object
 * @param {boolean} isVulnerable - Vulnerability status
 * @returns {Object} CPE match object
 */
function createCpeMatchFromVersionInfo(cpeBase, versionInfo, isVulnerable) {
    // Handle single version with no range indicators
    if (versionInfo.version && !versionInfo.lessThan && !versionInfo.lessThanOrEqual && 
        !versionInfo.greaterThan && !versionInfo.greaterThanOrEqual) {
        
        // Create a CPE match with explicit version embedded in the criteria
        const cpeParts = cpeBase.split(':');
        cpeParts[5] = versionInfo.version; // Replace wildcard with explicit version
        
        return {
            "criteria": cpeParts.join(':'),
            "matchCriteriaId": generateMatchCriteriaId(),
            "vulnerable": isVulnerable
        };
    } else {
        // Range specification (existing code for handling ranges)
        const cpeMatch = {
            "criteria": cpeBase,
            "matchCriteriaId": generateMatchCriteriaId(),
            "vulnerable": isVulnerable
        };
        
        // Add version range attributes
        if (versionInfo.version) {
            cpeMatch.versionStartIncluding = versionInfo.version;
        }
        if (versionInfo.greaterThan) {
            cpeMatch.versionStartExcluding = versionInfo.greaterThan;
        }
        else if (versionInfo.greaterThanOrEqual) {
            cpeMatch.versionStartIncluding = versionInfo.greaterThanOrEqual;
        }
        
        if (versionInfo.lessThan) {
            cpeMatch.versionEndExcluding = versionInfo.lessThan;
        }
        else if (versionInfo.lessThanOrEqual) {
            cpeMatch.versionEndIncluding = versionInfo.lessThanOrEqual;
        }
        
        return cpeMatch;
    }
}

/**
 * Process gaps between unaffected ranges to create affected ranges
 * @param {string} cpeBase - Base CPE string
 * @param {Array} unaffectedVersions - Array of unaffected version info objects
 * @param {Array} affectedVersions - Array of explicitly affected version info objects
 * @param {Array} cpeMatches - Array to add new cpeMatch objects to
 */
function processGapsBetweenUnaffectedRanges(cpeBase, unaffectedVersions, affectedVersions, cpeMatches) {
    console.debug("Processing gaps between unaffected ranges");
    
    // First, organize the unaffected versions by their starting version and ending version
    const unaffectedRanges = [];
    
    for (const info of unaffectedVersions) {
        let startVer, endVer;
        
        // Determine start version
        if (info.version) {
            startVer = info.version;
        } else if (info.greaterThanOrEqual) {
            startVer = info.greaterThanOrEqual;
        } else if (info.greaterThan) {
            startVer = incrementVersion(info.greaterThan);
        } else {
            startVer = "0"; // Default to beginning
        }
        
        // Determine end version - this is the end of the unaffected range
        if (info.lessThan) {
            endVer = info.lessThan;
        } else if (info.lessThanOrEqual && info.lessThanOrEqual === "*") {
            endVer = null; // Unlimited
        } else if (info.lessThanOrEqual && info.lessThanOrEqual.includes("*")) {
            // Handle wildcards like 5.4.*
            const wildcard = info.lessThanOrEqual;
            
            // Extract the numeric part (like "5.4" from "5.4.*")
            const versionBase = wildcard.split("*")[0].replace(/\.$/, '');
            const parts = versionBase.split(".");
            
            if (parts.length >= 2) {
                // For 5.4.*, the end of the unaffected range is 5.5
                const majorVersion = parseInt(parts[0], 10);
                const minorVersion = parseInt(parts[1], 10);
                
                if (!isNaN(majorVersion) && !isNaN(minorVersion)) {
                    endVer = `${majorVersion}.${minorVersion + 1}`;
                    console.debug(`Processed wildcard ${wildcard} to next version ${endVer}`);
                } else {
                    endVer = incrementVersion(versionBase);
                }
            } else {
                endVer = incrementVersion(versionBase);
            }
        } else if (info.lessThanOrEqual) {
            endVer = incrementVersion(info.lessThanOrEqual);
        } else {
            // Single version, so end is next version
            endVer = incrementVersion(startVer);
        }
        
        unaffectedRanges.push({ start: startVer, end: endVer });
    }
    
    // Sort the ranges by start version
    unaffectedRanges.sort((a, b) => compareVersions(a.start, b.start));
    
    console.debug("Sorted unaffected ranges:");
    unaffectedRanges.forEach((range, i) => {
        console.debug(`Range ${i}: ${range.start} to ${range.end || "unlimited"}`);
    });
    
    // Now find the gaps between unaffected ranges
    // First, set up the initial lower bound
    let previousRange = null;
    
    // Handle the special case for patched versions first - before the main loop
    // This ensures we correctly handle cases where version 5.4 is marked affected but 5.4.277 is unaffected
    const patchVersionCandidates = unaffectedRanges.filter(range => 
        range.start.includes(".") && range.start.split(".").length > 2
    );
    
    for (const patchRange of patchVersionCandidates) {
        // Get the base version from the patched version (5.4 from 5.4.277)
        const startParts = patchRange.start.split('.');
        const baseVersion = (startParts.length >= 2) ? `${startParts[0]}.${startParts[1]}` : startParts[0];
        
        // Check if this base version matches an affected version
        const matchingAffected = affectedVersions.find(av => 
            av.version && (av.version === baseVersion || av.version.startsWith(baseVersion + "."))
        );
        
        if (matchingAffected) {
            console.debug(`Found patched version ${patchRange.start} for base affected version ${baseVersion}`);
            
            // Create a non-vulnerable range from base to patched version (inclusive)
            cpeMatches.push({
                criteria: cpeBase,
                matchCriteriaId: generateMatchCriteriaId(),
                vulnerable: false,
                versionStartIncluding: baseVersion,
                versionEndIncluding: patchRange.start
            });
            
            console.debug(`Created unaffected range from ${baseVersion} to ${patchRange.start} (inclusive)`);
            
            // Create a vulnerable range from patched version (exclusive) to the next minor
            if (patchRange.end) {
                cpeMatches.push({
                    criteria: cpeBase,
                    matchCriteriaId: generateMatchCriteriaId(),
                    vulnerable: true,
                    versionStartExcluding: patchRange.start,
                    versionEndExcluding: patchRange.end
                });
                
                console.debug(`Created affected range from ${patchRange.start} (exclusive) to ${patchRange.end}`);
            }
        }
    }
    
    // Main loop for processing gaps between unaffected ranges
    for (let i = 0; i < unaffectedRanges.length; i++) {
        const currentRange = unaffectedRanges[i];
        
        // If we have a previous range and there's a gap between
        if (previousRange && previousRange.end && compareVersions(previousRange.end, currentRange.start) < 0) {
            console.debug(`Found gap between ${previousRange.end} and ${currentRange.start}`);
            
            // Skip creating affected ranges for gaps that overlap with our patch handling above
            let shouldCreateGapRange = true;
            
            // Check if this gap starts with a base version (like 5.4) that has special patched handling
            for (const patchRange of patchVersionCandidates) {
                const startParts = patchRange.start.split('.');
                const baseVersion = (startParts.length >= 2) ? `${startParts[0]}.${startParts[1]}` : startParts[0];
                
                // If the start of this gap matches a base version we've already handled
                if (previousRange.end === baseVersion) {
                    console.debug(`Skipping gap starting at ${baseVersion} as it's handled by patch special case`);
                    shouldCreateGapRange = false;
                    break;
                }
            }
            
            // Only create the gap range if we didn't handle it as a patch case
            if (shouldCreateGapRange) {
                cpeMatches.push({
                    criteria: cpeBase,
                    matchCriteriaId: generateMatchCriteriaId(),
                    vulnerable: true,
                    versionStartIncluding: previousRange.end,
                    versionEndExcluding: currentRange.start
                });
            }
        }
        
        previousRange = currentRange;
    }
    
    // If the last range doesn't extend to infinity, add a final affected range
    if (previousRange && previousRange.end) {
        console.debug(`Adding final range from ${previousRange.end} to infinity`);
        
        cpeMatches.push({
            criteria: cpeBase,
            matchCriteriaId: generateMatchCriteriaId(),
            vulnerable: true,
            versionStartIncluding: previousRange.end
        });
    }
}

/**
 * Check if a version is covered by a cpeMatch range
 * @param {string} version - Version to check
 * @param {Object} cpeMatch - cpeMatch object with range data
 * @returns {boolean} True if the version is covered
 */
function isVersionCoveredByRange(version, cpeMatch) {
    // If this is an exact match (not a range)
    if (cpeMatch.criteria.includes(`:${version}:`)) {
        return true;
    }
    
    let isGreaterThanLower = true;
    let isLessThanUpper = true;
    
    // Check lower bound
    if (cpeMatch.versionStartIncluding && compareVersions(version, cpeMatch.versionStartIncluding) < 0) {
        isGreaterThanLower = false;
    }
    if (cpeMatch.versionStartExcluding && compareVersions(version, cpeMatch.versionStartExcluding) <= 0) {
        isGreaterThanLower = false;
    }
    
    // Check upper bound
    if (cpeMatch.versionEndIncluding && compareVersions(version, cpeMatch.versionEndIncluding) > 0) {
        isLessThanUpper = false;
    }
    if (cpeMatch.versionEndExcluding && compareVersions(version, cpeMatch.versionEndExcluding) >= 0) {
        isLessThanUpper = false;
    }
    
    return isGreaterThanLower && isLessThanUpper;
}

/**
 * Check for special version structure patterns
 * @param {Object} rawPlatformData - Raw platform data
 * @returns {boolean} True if special case handling is needed
 */
function hasSpecialVersionStructure(rawPlatformData) {
    if (!rawPlatformData) {
        return false;
    }
    
    // Check for unaffected default status with explicit affected entries
    const hasUnaffectedDefault = rawPlatformData.defaultStatus === 'unaffected';
    
    // Count affected and unaffected entries
    let affectedEntries = 0;
    let unaffectedEntries = 0;
    
    if (rawPlatformData.versions && Array.isArray(rawPlatformData.versions)) {
        rawPlatformData.versions.forEach(v => {
            if (v && v.status === 'affected') affectedEntries++;
            if (v && v.status === 'unaffected') unaffectedEntries++;
        });
    }
    
    // Special case if default is unaffected but there are affected entries
    // Or if there are multiple unaffected entries
    return (hasUnaffectedDefault && affectedEntries > 0) || unaffectedEntries > 1;
}

/**
 * Generate JSON output with timestamp
 * @returns {Object} JSON object with timestamp
 */
function generateJsonOutput() {
    // Existing JSON generation code
    const json = {
        // ... existing properties
    };
    
    // Add timestamp if available through the timestamp handler
    if (window.timestampHandler && typeof window.timestampHandler.getTimestamp === 'function') {
        json.generatorTimestamp = window.timestampHandler.getTimestamp();
    }
    
    return json;
}

/**
 * Update the function that displays the JSON content
 */
function updateAllConfigurationsDisplay() {
    const container = document.getElementById('allConfigurationsContent');
    if (container) {
        const json = generateAllConfigurationsJson();
        try {
            // Format the JSON for display
            container.textContent = JSON.stringify(json, null, 2);
        } catch (e) {
            console.error("Error stringifying JSON:", e);
            container.textContent = '{"error": "Error generating JSON", "generatorTimestamp": "' + 
                (window.timestampHandler ? window.timestampHandler.getTimestamp() : new Date().toISOString()) + '"}';
        }
    }
}


/**
 * Update JSON display if it's currently visible
 * @param {string} tableId - ID of the table
 */
function updateJsonDisplayIfVisible(tableId) {
    try {
        const display = document.getElementById(`consolidatedJsonDisplay_${tableId}`);
        const content = document.getElementById(`consolidatedJsonContent_${tableId}`);
        
        // Only update if the display is visible
        if (display && content && display.style.display !== 'none') {
            const selectedRows = tableSelections.get(tableId);
            const selectionCount = selectedRows ? selectedRows.size : 0;
            
            if (!selectedRows || selectedRows.size === 0) {
                content.textContent = 'No rows selected. Please select at least one row.';
                return;
            }
            
            // Get the consolidated JSON for this table
            const json = consolidatedJsons.get(tableId);
            
            if (json) {
                content.textContent = JSON.stringify(json, null, 2);
            } else {
                content.textContent = 'No selections or error generating JSON.';
            }
            
            // Also update the button text
            updateJsonDisplay(tableId, json, selectionCount);
        }
    } catch(e) {
        console.error(`Error updating JSON display for table ${tableId}:`, e);
    }
}

/**
 * Update the button state and text
 * @param {string} tableId - ID of the table
 * @param {boolean} hasSelections - Whether there are selections
 */
function updateButton(tableId, hasSelections) {
    try {
        const button = document.getElementById(`showConsolidatedJson_${tableId}`);
        
        if (button) {
            button.disabled = !hasSelections;
            button.title = hasSelections ? 
                'Show/hide the consolidated JSON' : 
                'Select rows to generate JSON';
        }
    } catch(e) {
        console.error(`Error updating button for table ${tableId}:`, e);
    }
}

/**
 * Update the JSON display and button based on the content
 * @param {string} tableId - ID of the table
 * @param {Object} json - The JSON to display
 * @param {number} selectionCount - Number of selected items
 */
function updateJsonDisplay(tableId, json, selectionCount) {
    try {
        const display = document.getElementById(`consolidatedJsonDisplay_${tableId}`);
        const content = document.getElementById(`consolidatedJsonContent_${tableId}`);
        const showButton = document.getElementById(`showConsolidatedJson_${tableId}`);
        
        if (display && content) {
            // Check if the display is already visible
            const isVisible = display.style.display !== 'none';
            
            // Update the content
            if (json) {
                content.textContent = JSON.stringify(json, null, 2);
            } else {
                content.textContent = 'No selections or error generating JSON.';
            }
            
            // Update button text if it's found
            if (showButton) {
                // Get statistics string
                const statsStr = getStatisticsString(json, selectionCount);
                
                showButton.textContent = isVisible 
                    ? `Hide Consolidated JSON (${statsStr})` 
                    : `Show Consolidated JSON (${statsStr})`;
                
                // Update button styling
                if (isVisible) {
                    showButton.classList.remove('btn-primary');
                    showButton.classList.add('btn-success');
                } else {
                    showButton.classList.remove('btn-success');
                    showButton.classList.add('btn-primary');
                }
            }
        }
    } catch(e) {
        console.error(`Error updating JSON display for table ${tableId}:`, e);
    }
}

/**
 * Update the completion tracker
 */
function updateCompletionTracker() {
    try {
        const tables = document.querySelectorAll('table[id^="rowDataTable_"]');
        let completedCount = 0;
        const totalCount = tables.length;
        
        // Count how many tables are collapsed (completed)
        tables.forEach(table => {
            if (table.classList.contains('d-none')) {
                completedCount++;
            }
        });
        
        // Calculate percentage
        const percentage = totalCount > 0 ? Math.round((completedCount / totalCount) * 100) : 0;
        
        // Update the progress bar
        const progressBar = document.getElementById('completionProgressBar');
        const completedRowsCount = document.getElementById('completedRowsCount');
        const totalRowsCount = document.getElementById('totalRowsCount');
        
        if (progressBar && completedRowsCount && totalRowsCount) {
            progressBar.style.width = `${percentage}%`;
            progressBar.textContent = `${percentage}%`;
            progressBar.setAttribute('aria-valuenow', percentage);
            
            // Change format to succinct fraction followed by "rows"
            completedRowsCount.textContent = `${completedCount}/${totalCount} rows`;
            // Remove the separate total count display since it's now in the fraction
            totalRowsCount.textContent = ''; // or just hide this element with display:none
        }
    } catch(e) {
        console.error('Error updating completion tracker:', e);
    }
}

/**
 * Update the Export All Configurations button
 */
function updateExportAllButton() {
    try {
        // Check if any tables have selected rows
        let hasSelections = false;
        let totalSelections = 0;
        let configCount = 0;
        let configDetails = [];
        let totalVersions = 0;
        
        tableSelections.forEach((selections, tableId) => {
            if (selections.size > 0) {
                hasSelections = true;
                totalSelections += selections.size;
                configCount++;
                
                // Get version count from this table's JSON if available
                const json = consolidatedJsons.get(tableId);
                if (json && json.configurations && json.configurations.length > 0) {
                    const versionCount = json.configurations[0].cpeMatch.length;
                    configDetails.push(`${selections.size} Criteria, ${versionCount} versions`);
                    totalVersions += versionCount;
                } else {
                    configDetails.push(`${selections.size} criteria`);
                    totalVersions += selections.size; // Assume 1 version per Criteria if no detailed data
                }
            }
        });
        
        // Show/hide the Export All button container based on whether there are selections
        const container = document.getElementById('allConfigurationsContainer');
        const exportButton = document.getElementById('exportAllConfigurations');
        const configSummary = document.getElementById('configurationSummary');
        
        if (container && exportButton) {
            container.style.display = hasSelections ? 'block' : 'none';
            
            // Update the summary text with selection count and version information
            if (hasSelections && configSummary) {
                const display = document.getElementById('allConfigurationsDisplay');
                
                // Format the config summary
                const summaryText = `${configCount} config${configCount !== 1 ? 's' : ''} (${configDetails.join(', ')})`;
                
                // Update the summary text instead of changing the button text
                configSummary.textContent = summaryText;
                
                // Keep button text simple - just show/hide state
                exportButton.textContent = display && display.style.display !== 'none' ? 
                    'Hide All Configurations' : 'Show All Configurations';
            } else if (configSummary) {
                configSummary.textContent = '';
            }
        }
    } catch(e) {
        console.error("Error updating export all button:", e);
    }
}

/**
 * Update the all configurations display
 */
function updateAllConfigurationsDisplay() {
    try {
        const display = document.getElementById('allConfigurationsDisplay');
        const content = document.getElementById('allConfigurationsContent');
        
        if (display && content && display.style.display !== 'none') {
            // Create master JSON with configurations from all tables
            const masterJson = generateAllConfigurationsJson();
            
            if (!masterJson || !masterJson.configurations || masterJson.configurations.length === 0) {
                content.textContent = 'No CPEs selected in any table. Please select at least one CPE row.';
            } else {
                content.textContent = JSON.stringify(masterJson, null, 2);
            }
        }
    } catch(e) {
        console.error("Error updating all configurations display:", e);
    }
}

/**
 * Maintain JSON display state across row toggle operations
 * @param {number} tableIndex - Index of the table
 */
function preserveJsonDisplayState(tableIndex) {
    const tableId = `matchesTable_${tableIndex}`;
    const jsonContainer = document.querySelector(`.consolidated-json-container[data-index="${tableIndex}"]`);
    const display = document.getElementById(`consolidatedJsonDisplay_${tableId}`);
    const showButton = document.getElementById(`showConsolidatedJson_${tableId}`);
    
    if (!jsonContainer || !display || !showButton) return;
    
    // Store current state
    const isDisplayVisible = display.style.display !== 'none';
    const selectedRows = tableSelections.get(tableId);
    const selectionCount = selectedRows ? selectedRows.size : 0;
    
    // Get json and detailed statistics
    const json = consolidatedJsons.get(tableId);
    let statsStr = `${selectionCount} selected`;
    
    // Extract detailed statistics if available
    if (json && json.configurations && json.configurations.length > 0) {
        if (json.configurations[0].matchStats) {
            const stats = json.configurations[0].matchStats;
            statsStr = `${stats.selectedCriteria || stats.selectedCPEs} Criteria, ${stats.totalMatches} versions (${stats.exactMatches} exact, ${stats.rangeMatches} ranges)`;
        } else {
            // Fall back to basic statistics if detailed stats aren't available
            let versionCount = selectionCount;
            if (json.configurations[0].versionStats) {
                versionCount = json.configurations[0].versionStats.totalVersions;
            } else if (json.configurations[0].cpeMatch) {
                versionCount = json.configurations[0].cpeMatch.length;
            } else if (json.configurations[0].nodes) {
                versionCount = getTotalCPEMatches(json.configurations[0]);
            }
            statsStr = `${selectionCount} Criteria, ${versionCount} versions`;
        }
    }
    
    // Ensure the button text and state matches the display visibility
    if (isDisplayVisible) {
        showButton.textContent = `Hide Consolidated JSON (${statsStr})`;
        showButton.classList.remove('btn-primary');
        showButton.classList.add('btn-success');
        
        // Also ensure the JSON content is updated
        updateJsonDisplayIfVisible(tableId);
    } else {
        showButton.textContent = `Show Consolidated JSON (${statsStr})`;
        showButton.classList.remove('btn-success');
        showButton.classList.add('btn-primary');
    }
    
    // Ensure proper container positioning
    const collapseButton = document.getElementById(`collapseRowButton_${tableIndex}`);
    if (collapseButton) {
        const buttonParent = collapseButton.parentNode;
        buttonParent.parentNode.insertBefore(jsonContainer, buttonParent.nextSibling);
    }
}

/**
 * Function to handle tab navigation
 * @param {Event} evt - The click event
 * @param {string} tabName - The ID of the tab to open
 */
function openCity(evt, cityName) {
    // Declare all variables
    let i, tabcontent, tablinks;

    // Get all elements with class="tabcontent" and hide them
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
    }

    // Get all elements with class="tablinks" and remove the class "active"
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
    }

    // Show the current tab, and add an "active" class to the button that opened the tab
    document.getElementById(cityName).style.display = "block";
    evt.currentTarget.className += " active";
}

// Make the function available globally
window.openCity = openCity;

/**
 * Function to toggle row collapse state
 * @param {number} tableIndex - Index of the table
 */
function toggleRowCollapse(tableIndex) {
    try {
        const rowDataTable = document.getElementById(`rowDataTable_${tableIndex}`);
        const matchesTable = document.getElementById(`matchesTable_${tableIndex}`);
        const jsonContainer = document.querySelector(`.consolidated-json-container[data-index="${tableIndex}"]`);
        const collapseButton = document.getElementById(`collapseRowButton_${tableIndex}`);
        const tableId = `matchesTable_${tableIndex}`; 
        
        // Define isCollapsed variable outside the if block
        let isCollapsed = false;
        
        if (rowDataTable && matchesTable) {
            // Toggle visibility for tables
            isCollapsed = rowDataTable.classList.toggle('d-none');
            matchesTable.classList.toggle('d-none');
            
            // Always ensure the JSON container is in the right place
            // regardless of collapsed state
            if (jsonContainer && collapseButton) {
                // Get the parent of the collapse button
                const buttonParent = collapseButton.parentNode;
                
                // Always move the JSON container to be adjacent to the button
                buttonParent.parentNode.insertBefore(jsonContainer, buttonParent.nextSibling);
                
                // Add some spacing for better visual separation
                jsonContainer.classList.add('mt-2');
                
                // IMPORTANT: Update the consolidated JSON button to maintain selection count
                const selectedRows = tableSelections.get(tableId);
                const selectionCount = selectedRows ? selectedRows.size : 0;
                
                // Find the consolidated JSON button
                const showButton = document.getElementById(`showConsolidatedJson_${tableId}`);
                const altShowButton = document.getElementById(`showConsolidatedJson_matchesTable_${tableIndex}`);
                const buttonToUpdate = showButton || altShowButton;
                
                // Update the button text to maintain selection count
                if (buttonToUpdate) {
                    // Check if display is visible
                    const display = document.getElementById(`consolidatedJsonDisplay_${tableId}`);
                    const isVisible = display && display.style.display !== 'none';
                    
                    // ADDED: Make sure we're seeing consistent behavior between the display and button
                    if (isVisible && display.style.display !== 'block') {
                        display.style.display = 'block';
                    }
                    
                    if (selectionCount > 0) {
                        buttonToUpdate.textContent = isVisible 
                            ? `Hide Consolidated JSON (${selectionCount} selected)` 
                            : `Show Consolidated JSON (${selectionCount} selected)`;
                    } else {
                        buttonToUpdate.textContent = isVisible 
                            ? `Hide Consolidated JSON` 
                            : `Show Consolidated JSON`;
                    }
                    
                    // ADDED: Ensure button styling matches display state
                    if (isVisible) {
                        buttonToUpdate.classList.remove('btn-primary');
                        buttonToUpdate.classList.add('btn-success');
                    } else {
                        buttonToUpdate.classList.remove('btn-success');
                        buttonToUpdate.classList.add('btn-primary');
                    }
                }
                
                // Also update the display content if it's visible
                updateJsonDisplayIfVisible(tableId);
            }
            
            // Update button text
            if (collapseButton) {
                collapseButton.textContent = isCollapsed ? 'Expand Row (Completed)' : 'Collapse Row (Mark Complete)';
                collapseButton.classList.toggle('btn-success', isCollapsed);
                collapseButton.classList.toggle('btn-secondary', !isCollapsed);
            }
        }
        // Define variables before using them in console.debug
        const selectedRows = tableSelections.get(tableId) || new Set();
        const selectionCount = selectedRows.size;
        
        // Get display visibility state
        const display = document.getElementById(`consolidatedJsonDisplay_${tableId}`);
        const isVisible = display && display.style.display !== 'none';
        
        console.debug(`Table ${tableId} collapsed: ${isCollapsed}, Selection count: ${selectionCount}, JSON visible: ${isVisible}`);
        // Update the completion tracker
        updateCompletionTracker();
        // Update the export all configurations button text
        updateExportAllButton();
        
        // Preserve JSON display state
        preserveJsonDisplayState(tableIndex);
    } catch(e) {
        console.error(`Error in toggleRowCollapse for tableIndex ${tableIndex}:`, e);
    }
}

/**
 * Initialize the event listeners for tables and buttons
 */
function initializeEventListeners() {
    try {
        // Find all matchesTables (there may be multiple)
        const tables = document.querySelectorAll('table[id^="matchesTable"]');
        
        // Add a master "Export All Configurations" button at the top of cveListCPESuggester
        const cveListCPESuggester = document.getElementById('cveListCPESuggester');
        
        // Scan for git versionTypes and add warnings (add this near the beginning)
        if (typeof scanForGitVersionTypes === 'function') {
            scanForGitVersionTypes();
        }
        
        // ... existing initialization code ...
        
        if (cveListCPESuggester) {
            // Create the Export All container at the beginning
            const allContainer = document.createElement('div');
            allContainer.classList.add('all-configurations-container', 'mt-3', 'mb-5');
            allContainer.id = 'allConfigurationsContainer';
            allContainer.innerHTML = `
                <!-- NEW: Add configuration summary above the button -->
                <div id="configurationSummary" class="text-center mb-2" style="font-weight: 500;"></div>
                <div class="d-grid gap-2 col-12 mx-auto">
                    <button id="exportAllConfigurations" class="btn btn-danger">Show All Configurations</button>
                </div>
                <div id="allConfigurationsDisplay" class="mt-3" style="display: none;">
                    <h4>Complete Configuration JSON</h4>
                    <p class="text-muted">This combines all selected CPEs from all tables, with each table creating its own configuration node.</p>
                    <pre id="allConfigurationsContent" style="max-height: 600px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 5px;"></pre>
                </div>
            `;
            
            // Insert at the beginning of cveListCPESuggester
            if (cveListCPESuggester.firstChild) {
                cveListCPESuggester.insertBefore(allContainer, cveListCPESuggester.firstChild.nextSibling);
            } else {
                cveListCPESuggester.appendChild(allContainer);
            }
            
            // Add click handler to the Export All button
            document.getElementById('exportAllConfigurations').addEventListener('click', function() {
                const display = document.getElementById('allConfigurationsDisplay');
                const content = document.getElementById('allConfigurationsContent');
                
                if (display && content) {
                    // Create master JSON with configurations from all tables
                    const masterJson = generateAllConfigurationsJson();
                    
                    if (!masterJson || !masterJson.configurations || masterJson.configurations.length === 0) {
                        content.textContent = 'No CPEs selected in any table. Please select at least one CPE row.';
                    } else {
                        content.textContent = JSON.stringify(masterJson, null, 2);
                    }
                    
                    // Toggle display
                    display.style.display = display.style.display === 'none' ? 'block' : 'none';
                    
                    // Update the button text to reflect current state (without configuration details)
                    this.textContent = display.style.display === 'none' ? 'Show All Configurations' : 'Hide All Configurations';
                }
            });
            
            // Create a completion tracker container only if allContainer exists
            const completionTrackerContainer = document.createElement('div');
            completionTrackerContainer.classList.add('completion-tracker-container', 'mt-3', 'mb-3', 'p-3', 'border', 'rounded');
            completionTrackerContainer.id = 'completionTrackerContainer';
            completionTrackerContainer.innerHTML = `
                <h4>Completion Progress</h4>
                <div class="progress mb-2">
                    <div id="completionProgressBar" class="progress-bar bg-success" role="progressbar" style="width: 0%" 
                         aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</</div>
                </div>
                <div class="d-flex justify-content-between">
                    <span id="completedRowsCount">0 rows completed</span>
                    <span id="totalRowsCount">${tables.length} total rows</span>
                </div>
            `;

            // Insert right after the export all container
            allContainer.parentNode.insertBefore(completionTrackerContainer, allContainer.nextSibling);

            // Initialize the completion tracker
            updateCompletionTracker();
        }

        // Initialize each table
        tables.forEach((table, tableIndex) => {
            const tableId = table.id;
            
            // Initialize selections for this table
            tableSelections.set(tableId, new Set());
            
            // Add click handlers to all CPE rows in this table
            const rows = table.querySelectorAll('.cpe-row');
            rows.forEach(function(row) {
                row.addEventListener('click', function(event) {
                    // Don't handle clicks on elements with their own handlers
                    if (event.target.tagName === 'BUTTON' || 
                        event.target.tagName === 'A' ||
                        event.target.closest('button') ||
                        event.target.closest('a')) {
                        return;
                    }
                    
                    // Toggle row selection
                    let cpeBase = row.getAttribute('data-cpe-base');
                    
                    // Normalize CPE base string when getting it from the row
                    cpeBase = normalizeCpeString(cpeBase);
                    
                    const selections = tableSelections.get(tableId);
                    
                    if (selections.has(cpeBase)) {
                        selections.delete(cpeBase);
                        row.classList.remove('table-active');
                    } else {
                        selections.add(cpeBase);
                        row.classList.add('table-active');
                    }
                    
                    // Update the JSON
                    updateConsolidatedJson(tableId);
                });
            });
            
            // Add a container for consolidated JSON right after this table
            const container = document.createElement('div');
            container.classList.add('consolidated-json-container', 'mt-3', 'mb-4', 'json-container');
            container.setAttribute('data-index', tableIndex);
            container.innerHTML = `
                <div id="consolidatedJsonDisplay_${tableId}" class="mt-3" style="display: none;">
                    <h4>Consolidated Configuration JSON</h4>
                    <pre id="consolidatedJsonContent_${tableId}" style="max-height: 400px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 5px;"></pre>
                </div>
            `;
            
            // Place the container directly after the table
            table.parentNode.insertBefore(container, table.nextSibling);
            
            // Create the consolidated JSON button and place it next to the collapse button
            const jsonButton = document.createElement('button');
            jsonButton.id = `showConsolidatedJson_${tableId}`;
            jsonButton.className = 'btn btn-primary';
            jsonButton.textContent = 'Show Consolidated JSON';

            // Find the button container and add the JSON button
            const collapseButtonContainer = document.getElementById(`buttonContainer_${tableIndex}`);
            if (collapseButtonContainer) {
                collapseButtonContainer.appendChild(jsonButton);
            }

            // Add click handler to the button - find it first since it's already in the DOM
            const showButton = document.getElementById(`showConsolidatedJson_${tableId}`);
            if (showButton) {
                showButton.addEventListener('click', function() {
                    try {
                        const display = document.getElementById(`consolidatedJsonDisplay_${tableId}`);
                        
                        if (display) {
                            // Check if the corresponding table is collapsed
                            const matchesTable = document.getElementById(tableId);
                            const tableIndex = tableId.split('_')[1];
                            const rowDataTable = document.getElementById(`rowDataTable_${tableIndex}`);
                            const isTableCollapsed = matchesTable.classList.contains('d-none');
                            const jsonContainer = document.querySelector(`.consolidated-json-container[data-index="${tableIndex}"]`);
                            const collapseButton = document.getElementById(`collapseRowButton_${tableIndex}`);
                            
                            // Toggle display
                            const isVisible = display.style.display === 'none' ? false : true;
                            display.style.display = isVisible ? 'none' : 'block';
                            
                            // Always ensure the JSON container is in the right place when showing
                            if (!isVisible && jsonContainer && collapseButton) {
                                // Get the parent of the collapse button
                                const buttonParent = collapseButton.parentNode;
                                
                                // Always move the JSON container to be adjacent to the button
                                buttonParent.parentNode.insertBefore(jsonContainer, buttonParent.nextSibling);
                                
                                // Add some spacing for better visual separation
                                jsonContainer.classList.add('mt-2');
                            }
                            
                            // Get the json and statistics - ENSURE THIS CODE IS INCLUDED
                            const json = consolidatedJsons.get(tableId);
                            const selectedRows = tableSelections.get(tableId);
                            const selectionCount = selectedRows ? selectedRows.size : 0;
                            const statsStr = getStatisticsString(json, selectionCount);
                            
                            // Update button text with count and state
                            this.textContent = isVisible ? 
                                `Show Consolidated JSON (${statsStr})` : 
                                `Hide Consolidated JSON (${statsStr})`;
                            
                            // Update content when showing
                            if (!isVisible) {
                                updateJsonDisplayIfVisible(tableId);
                            }
                            
                            // Update button styling
                            if (!isVisible) {
                                this.classList.remove('btn-primary');
                                this.classList.add('btn-success');
                            } else {
                                this.classList.remove('btn-success');
                                this.classList.add('btn-primary');
                            }
                        }
                    } catch(e) {
                        console.error(`Error toggling JSON display for table ${tableId}:`, e);
                    }
                });
            }
        });
        
        // Initial update of Export All button visibility
        updateExportAllButton();
        
    } catch(e) {
        console.error("Error initializing event listeners:", e);
    }
}

// Make toggleRowCollapse available globally for HTML button onclick handlers
window.toggleRowCollapse = toggleRowCollapse;

// Initialize everything when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', initializeEventListeners);

/**
 * Maintain JSON display state across row toggle operations
 * @param {number} tableIndex - Index of the table
 */
function preserveJsonDisplayState(tableIndex) {
    const tableId = `matchesTable_${tableIndex}`;
    const jsonContainer = document.querySelector(`.consolidated-json-container[data-index="${tableIndex}"]`);
    const display = document.getElementById(`consolidatedJsonDisplay_${tableId}`);
    const showButton = document.getElementById(`showConsolidatedJson_${tableId}`);
    
    if (!jsonContainer || !display || !showButton) return;
    
    // Store current state
    const isDisplayVisible = display.style.display !== 'none';
    const selectedRows = tableSelections.get(tableId);
    const selectionCount = selectedRows ? selectedRows.size : 0;
    
    // Get json and statistics
    const json = consolidatedJsons.get(tableId);
    const statsStr = getStatisticsString(json, selectionCount);
    
    // Ensure the button text and state matches the display visibility
    if (isDisplayVisible) {
        showButton.textContent = `Hide Consolidated JSON (${statsStr})`;
        showButton.classList.remove('btn-primary');
        showButton.classList.add('btn-success');
        
        // Also ensure the JSON content is updated
        updateJsonDisplayIfVisible(tableId);
    } else {
        showButton.textContent = `Show Consolidated JSON (${statsStr})`;
        showButton.classList.remove('btn-success');
        showButton.classList.add('btn-primary');
    }
    
    // Ensure proper container positioning
    const collapseButton = document.getElementById(`collapseRowButton_${tableIndex}`);
    if (collapseButton) {
        const buttonParent = collapseButton.parentNode;
        buttonParent.parentNode.insertBefore(jsonContainer, buttonParent.nextSibling);
    }
}

/**
 * Timestamp Handler
 * Manages the generator timestamp for CPE JSON data and timestamp display
 */

// Module for handling timestamp-related operations
(function() {
    // Store the timestamp globally for use in other modules
    let generatorTimestamp = "";
    
    // Initialize timestamp functionality
    function initTimestampHandler(timestamp) {
        // Store the timestamp globally
        generatorTimestamp = timestamp;
        
        // Format and display the timestamp when the document is ready
        document.addEventListener('DOMContentLoaded', function() {
            formatAndDisplayTimestamp();
        });
    }
    
    // Format and display the timestamp in the user's local timezone
    function formatAndDisplayTimestamp() {
        const timeElement = document.querySelector('#generationTimestamp time');
        if (!timeElement) return;
        
        const utcTime = new Date(generatorTimestamp);
        const options = { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric', 
            hour: '2-digit', 
            minute: '2-digit', 
            second: '2-digit',
            timeZoneName: 'short' 
        };
        timeElement.textContent = utcTime.toLocaleString(undefined, options);
    }
    
    // Get the stored timestamp
    function getTimestamp() {
        return generatorTimestamp;
    }
    
    // Expose public methods
    window.timestampHandler = {
        init: initTimestampHandler,
        getTimestamp: getTimestamp
    };
})();


</script>
    <!-- Tool Info Header -->
    <div class="header" style="margin-left: 10px;">
        <h1>NVD Analysis Intelligence Tool <small>Hashmire/Analysis_Tools version: {{VERSION_PLACEHOLDER}}</small></h1>
    </div>
    
    <!-- Tab links -->
    <div class="tab">
        <button class="tablinks" onclick="openCity(event, 'cveListCPESuggester')">CVE List CPE Suggester</button>
        <button class="tablinks" onclick="openCity(event, 'vdbIntelDashboard')">VDB Intel Dashboard</button>
    </div>
    
    <div class="d-flex align-items-center justify-content-between" style="margin-left: 10px; margin-right: 10px;">
        <h3 style="margin-bottom: 0px;"><b>CVE-2023-5541</b></h3>
        <span id="generationTimestamp" class="text-muted">Generated: <time datetime="2025-04-09T20:43:16.023017Z"></time></span>
    </div>
    <hr style="margin: 10px; border: 1px solid;">
    
    <!-- CVE List CPE Suggester -->
    <div id="cveListCPESuggester" class="tabcontent" style="display: block; border-left: 0px;">
        <h3>CVE List CPE Suggester</h3>
        <table border="1" class="dataframe table table-stripped">
  <thead>
    <tr style="text-align: right;">
      <th style="min-width: 20%;">rowDataHTML</th>
      <th style="min-width: 80%;">cpeQueryHTML</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><div class="mb-3 d-flex gap-2" id="buttonContainer_0"><button id="collapseRowButton_0" class="btn btn-secondary" onclick="toggleRowCollapse(0)">Collapse Row (Mark Complete)</button></div><table id="rowDataTable_0" class="table table-hover">                <tr>                    <td>Data Source</td>                    <td>CVEAPI</td>                </tr>                                <tr>                    <td>Source ID</td>                    <td><span title="Contact Email: patrick@puiterwijk.org &#013;Source Identifiers: patrick@puiterwijk.org, 92fb86c3-55a5-4fb5-9c3f-4757b9e96dc5">Fedora Project</span></td>                </tr>                                <tr>                    <td>Source Role</td>                    <td>CNA</td>                </tr>                <tr><td>Platform Entry Notifications</td><td><span class="badge bg-warning" title="Versions array contains default unaffected status with specific affected entries">Inverse Status Pattern</span> <span class="badge bg-warning" title="Versions array contains multiple version branches: 4.0, 4.1, 3.11, 4.2">Multiple Version Branches</span> <span class="badge bg-info" title="status: affected, version: 4.2.0, lessThan: 4.2.3, versionType: semver&#013;status: affected, version: 4.1.0, lessThan: 4.1.6, versionType: semver&#013;status: affected, version: 4.0.0, lessThan: 4.0.11, versionType: semver&#013;status: affected, version: 3.11.0, lessThan: 3.11.17, versionType: semver&#013;status: affected, version: 0, lessThan: 3.9.24, versionType: semver">CVE Affects Version Range(s)</span> <span class="badge bg-secondary" title="cpe:2.3:*:*:*moodle*:*:*:*:*:*:*:*:*">CPE Base String Searches</span> </td></tr>            <tr>                <td>Package Name</td>                <td>moodle</td>            </tr>                    <tr>            <td>Raw Platform Data</td>            <td><details><summary>Review rawPlatformData</summary>            <code id="rawPlatformData_0" class="rawPlatformData">{"versions": [{"status": "affected", "version": "4.2.0", "lessThan": "4.2.3", "versionType": "semver"}, {"status": "affected", "version": "4.1.0", "lessThan": "4.1.6", "versionType": "semver"}, {"status": "affected", "version": "4.0.0", "lessThan": "4.0.11", "versionType": "semver"}, {"status": "affected", "version": "3.11.0", "lessThan": "3.11.17", "versionType": "semver"}, {"status": "affected", "version": "0", "lessThan": "3.9.24", "versionType": "semver"}], "packageName": "moodle", "collectionURL": "https://git.moodle.org", "defaultStatus": "unaffected"}</code></details></td>        </tr>        </table></td>
      <td><div id="cpe-query-container-0" class="cpe-query-container" >    <table id="matchesTable_0" class="table table-hover matchesTable">    <thead>      <tr>        <th style="width: 50%">CPE Base String</th>        <th style="width: 50%">Match Details</th>      </tr>    </thead>    <tbody>            <tr id="row_cpe_2_3_a_moodle_moodle_*_*_*_*_*_*_*_*" class="cpe-row" data-cpe-base="cpe:2.3:a:moodle:moodle:*:*:*:*:*:*:*:*">            <td class="text-break">cpe:2.3:a:moodle:moodle:*:*:*:*:*:*:*:*</td>            <td>                <div class="d-flex flex-wrap gap-1 align-items-center">                    <span class="badge rounded-pill bg-secondary" title="searchSourceproduct:  cpe:2.3:*:*:*moodle*:*:*:*:*:*:*:*:*&#10;">Relevant Match String Searches: 1</span>                    <span class="badge rounded-pill bg-success" title="version: cpe:2.3:a:moodle:moodle:3.11.0:-:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:3.11.0:beta:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:3.11.0:rc1:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:3.11.0:rc2:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.0.0:-:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.0.0:beta:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.0.0:rc1:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.0.0:rc2:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.0.0:rc3:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.0.0:rc4:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.1.0:-:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.1.0:rc3:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.1.0:rc2:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.1.0:rc1:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.1.0:beta:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.2.0:*:*:*:*:*:*:*&#10;lessThan: cpe:2.3:a:moodle:moodle:4.2.3:*:*:*:*:*:*:*&#10;lessThan: cpe:2.3:a:moodle:moodle:4.1.6:*:*:*:*:*:*:*&#10;lessThan: cpe:2.3:a:moodle:moodle:4.0.11:*:*:*:*:*:*:*&#10;lessThan: cpe:2.3:a:moodle:moodle:3.11.17:*:*:*:*:*:*:*&#10;lessThan: cpe:2.3:a:moodle:moodle:3.9.24:*:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.2.0:-:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.2.0:rc1:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.2.0:rc2:*:*:*:*:*:*&#10;version: cpe:2.3:a:moodle:moodle:4.2.0:beta:*:*:*:*:*:*">Version Matches Identified: 25</span>                    <div class="badge bg-primary d-inline-flex align-items-center">                        Total CPE Names: 500                        <span class="badge bg-info ms-1">Final: 465</span>                        <span class="badge bg-warning ms-1">Deprecated: 35</span>                    </div>                </div>            </td>        </tr>                <tr id="row_cpe_2_3_a_moodle-block_sitenews_project_moodle-block_sitenews_*_*_*_*_*_*_*_*" class="cpe-row" data-cpe-base="cpe:2.3:a:moodle-block_sitenews_project:moodle-block_sitenews:*:*:*:*:*:*:*:*">            <td class="text-break">cpe:2.3:a:moodle-block_sitenews_project:moodle-block_sitenews:*:*:*:*:*:*:*:*</td>            <td>                <div class="d-flex flex-wrap gap-1 align-items-center">                    <span class="badge rounded-pill bg-secondary" title="searchSourceproduct:  cpe:2.3:*:*:*moodle*:*:*:*:*:*:*:*:*&#10;">Relevant Match String Searches: 1</span>                    <span class="badge rounded-pill bg-success" title="">Version Matches Identified: 0</span>                    <div class="badge bg-primary d-inline-flex align-items-center">                        Total CPE Names: 5                        <span class="badge bg-info ms-1">Final: 5</span>                        <span class="badge bg-warning ms-1">Deprecated: 0</span>                    </div>                </div>            </td>        </tr>            </tbody>    </table>    </div></td>
    </tr>
    <tr>
      <td><div class="mb-3 d-flex gap-2" id="buttonContainer_1"><button id="collapseRowButton_1" class="btn btn-secondary" onclick="toggleRowCollapse(1)">Collapse Row (Mark Complete)</button></div><table id="rowDataTable_1" class="table table-hover">                <tr>                    <td>Data Source</td>                    <td>NVDAPI</td>                </tr>                                <tr>                    <td>Source ID</td>                    <td><span title="Contact Email: nvd@nist.gov &#013;Source Identifiers: nvd@nist.gov">NIST</span></td>                </tr>                                <tr>                    <td>Source Role</td>                    <td>NVD</td>                </tr>                <tr><td>Platform Entry Notifications</td><td><span class="badge bg-info" title="No versions detected!">NVD Configuration</span> </td></tr>        <tr>            <td>Raw Platform Data</td>            <td><details><summary>Review rawPlatformData</summary>            <code id="rawPlatformData_1" class="rawPlatformData">{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:moodle:moodle:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.9.0", "versionEndExcluding": "3.9.24", "matchCriteriaId": "B4F617E2-A462-4502-895E-136F1ECA1DC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:moodle:moodle:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.11.0", "versionEndExcluding": "3.11.17", "matchCriteriaId": "7C058D38-D206-4BEC-B647-4CD1808A1FC8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:moodle:moodle:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.0.11", "matchCriteriaId": "4827B277-0EC2-4254-B6DF-F18475A6253C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:moodle:moodle:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.0", "versionEndExcluding": "4.1.6", "matchCriteriaId": "E660C47C-2CB3-4B06-B98A-F8EE211F798A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:moodle:moodle:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2.0", "versionEndExcluding": "4.2.3", "matchCriteriaId": "C65020B8-B78E-4B59-B894-3F223D769078"}]}]}</code></details></td>        </tr>        </table></td>
      <td><div id="cpe-query-container-1" class="cpe-query-container" >    <table id="matchesTable_1" class="table table-hover matchesTable">    <thead>      <tr>        <th style="width: 50%">CPE Base String</th>        <th style="width: 50%">Match Details</th>      </tr>    </thead>    <tbody>        </tbody>    </table>    </div></td>
    </tr>
  </tbody>
</table>
        <script>
            // Initialize the timestamp handler with the generated timestamp
            window.timestampHandler.init("2025-04-09T20:43:16.023017Z");
        </script>
    </div>
    
        <!-- VDB Intel Dashboard -->
        <div id="vdbIntelDashboard" class="tabcontent" style="border-left: 0px;">
            <h3>VDB Intel Dashboard</h3>
            <table class="table table-hover" id="supportedSourceTable"><tr><th>Name & Link</th><th>CVSS v3.x</th><th>CWE</th><th>Notes/Context</th><th>Response Code</th></tr><tr id="IBM-Xforce"><td><a href="https://exchange.xforce.ibmcloud.com/vulnerabilities/CVE-2023-5541" target="_blank">IBM Xforce</a></td><td> - </td><td> - </td><td> - </td><td>Response Data:  200</td></tr><tr id="Teneble-CVE"><td><a href="https://www.tenable.com/cve/CVE-2023-5541" target="_blank">Teneble CVE</a></td><td> - </td><td> - </td><td> - </td><td>Response Data:  200</td></tr><tr id="Microsoft-MSRC"><td><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-5541" target="_blank">Microsoft MSRC</a></td><td> - </td><td> - </td><td> - </td><td>Response Data:  200</td></tr><tr id="RedHat-Security-API" class="danger"><td><a href="https://access.redhat.com/hydra/rest/securitydata/CVE-2023-5541" target="_blank">RedHat Security API</a></td><td> - </td><td> - </td><td> - </td><td>Response Data:  404</td></tr><tr id="Amazon-CVE" class="danger"><td><a href="https://alas.aws.amazon.com/cve/html/CVE-2023-5541" target="_blank">Amazon CVE</a></td><td> - </td><td> - </td><td> - </td><td>Response Data:  403</td></tr><tr id="SUSE-CVE" class="danger"><td><a href="https://www.suse.com/security/cve/CVE-2023-5541" target="_blank">SUSE CVE</a></td><td> - </td><td> - </td><td> - </td><td>Response Data:  404</td></tr></table>
        </div>
        
    <script>
    function openCity(evt, cityName) {
        var i, tabcontent, tablinks;
        tabcontent = document.getElementsByClassName("tabcontent");
        for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
        }
        tablinks = document.getElementsByClassName("tablinks");
        for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }
        document.getElementById(cityName).style.display = "block";
        evt.currentTarget.className += " active";
    }
    </script>
    </body>
    </html>
    