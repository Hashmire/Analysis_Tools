<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPE Alias Mapping Dashboard - {{TOOL_VERSION}}</title>
    <link rel="stylesheet" href="../css/alias_mapping_dashboard.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>CPE Alias Mapping Dashboard</h1>
            <p>
                Analyze CVE Platform Aliases and Assign them to CPE Base Strings <br />
                Hashmire/Analysis_Tools {{TOOL_VERSION}}
            </p>
        </div>

        <div class="file-selector">
            <!-- File Input Controls -->
            <div class="file-input-container">
                <div class="file-input-main">
                    <input type="file" id="fileInput" class="file-input" accept=".json">
                    <button type="button" id="file-select-btn" class="file-input-wrapper">
                        <div class="file-icon">üó∫Ô∏è</div>
                        <div class="file-input-text">Load Source Mapping File</div>
                    </button>
                    <div class="status-bar" id="status-bar" style="display: none;">
                        <div class="status-filename" id="status-filename">--</div>
                        <div class="status-details">
                            <div class="status-item">
                                <span>Generated: <span id="generation-time">--</span></span>
                            </div>
                            <div class="status-item">
                                <span id="file-size">-- KB</span> ‚Ä¢ <span>Loaded <span id="load-time">--</span></span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Documentation Toggle - Right Aligned -->
                <div class="doc-toggle" onclick="toggleDocumentation()">
                    <div class="doc-header">
                        <div class="doc-header-content">
                            <div class="doc-icon">‚ÑπÔ∏è</div>
                            <div>
                                <h3 class="doc-title">What am I looking at?</h3>
                                <p class="doc-subtitle">Click to learn how to use this dashboard and why it exists.</p>
                            </div>
                        </div>
                        <div class="doc-chevron" id="doc-chevron">‚ñº</div>
                    </div>
                </div>
            </div>
            
            <!-- Documentation Content - Expandable -->
            <div class="documentation-content" id="documentation-content">
                <div class="doc-intro">
                    <p>
                        <strong>Overview:  </strong><br />
                        The Common Plaform Enumeration (CPE) Alias Mapping Dashboard is designed to help systematically convert platform alias data into validated CPE Base String mappings for a specific external data contributor. <br />
                        The files generated are to enhance the coverage and precision of <a href="https://github.com/Hashmire/Analysis_Tools/tree/main/src/analysis_tool/mappings" target="_blank" style="color: #0066cc; text-decoration: none;">Existing Confirmed Mapping Files</a>.<br />
                        These mappings help to resolve <a href="https://github.com/Hashmire/Analysis_Tools/blob/main/documentation/cpe_automation_challenges.md#problem-domain-1-cpe-base-string-determination" target="_blank" style="color: #0066cc; text-decoration: none;">Problem Domain #1 - CPE Base String Determination</a> 
                        challenges by providing a vetted set of aliases that can be programmatically associated with CPE Base Strings for CPE Automation needs.
                    </p>
                    <p>
                        <strong>Goals:  </strong><br />
                        This dashboard aims to increase Confirmed Mapping coverage to <strong>100%</strong>. <i>This goal is limited based on the various data concerns within external platform alias contribututions.</i> <br />
                        This dashboard aims to reduce the identified Data Concerns to <strong>0%</strong>. <i>This goal is limited based on the active involvement of external platform alias data contributors.</i> <br />
                    </p>
                    <p>
                        <strong>Feedback: </strong><br />
                        For technical issues, feature requests, or questions; please visit the <a href="https://github.com/Hashmire/Analysis_Tools/issues" target="_blank" style="color: #0066cc; text-decoration: none;">Repository Issues page</a>. <br />
                        Community feedback and contributions to improve the dashboard's functionality and user experience are always encouraged!</p>
                </div>

                <div class="doc-sections">
                    <div class="doc-section">
                        <h4>üîç Step 1: Review and Filter Unconfirmed Aliases</h4>
                        <ul>
                            <li>Aliases are sets of platform related data extracted from various authoritative sources</li>
                            <li>Use the search filter to find targeted text values among the Alias Groups</li>
                            <li>Examine alias properties like vendor, product, platform, repo, etc.</li>
                            <li>Click each alias to review associated contextual information (NVD Website CPE-AS, CVE Frequency Data) </li>
                            <li>Click CVE links to review the current CPE Match String assignments within NVD Applicability Statements</li>
                            <li>Focus on high-frequency aliases (more CVEs = higher impact when mapped)</li>
                            <li>Avoid selecting aliases that contain inappropriate data such as version information or multiple platform values</li>
                        </ul>
                    </div>

                    <div class="doc-section">
                        <h4>üìã Step 2: Select Related Aliases for Mapping</h4>
                        <ul>
                            <li>Check the box(es) next to alias(es) that represent the exact same platform and specificity</li>
                            <li>Group related aliases that should share the same CPE Base String</li>
                            <li>Review current selections in the selected alias(es) window (bottom right of browser screen)</li>
                            <li>Minimum 1 alias required to generate a mapping</li>
                        </ul>
                    </div>

                    <div class="doc-section">
                        <h4>üìã Step 3: Update Confirmed Mappings</h4>
                        <ul>
                            <li>Click "Update Confirmed Mappings" to open the mapping generator</li>
                            <li>Consider all appropriate CPE Base String specificity and normative requirements</li>
                            <li>Choose CPE Base String approach:</li>
                            <ul>
                                <li><strong>Manual CPE:</strong> Enter full <code>cpe:2.3:a:vendor:product:*:*:*:*:swed:tsw:thw:*</code> format</li>
                                <li><strong>Existing CPE:</strong> Select from dropdown of existing confirmed mappings</li>
                            </ul>
                            <li>Review the generated JSON with your selected aliases</li>
                            <li>Visually confirm the aliases are appropriate for the CPE Base String</li>
                        </ul>
                    </div>

                    <div class="doc-section">
                        <h4>üíæ Step 4: Save and Continue</h4>
                        <ul>
                            <li>Click the "Update Confirmed Mapping" button to commit the alias assignment</li>
                            <li>Continue mapping remaining aliases</li>
                            <li>Download the Confirmed Mapping file by clicking the JSON button in the section header</li>
                            <li>Submit the file for inclusion</li>
                        </ul>
                    </div>

                    <div class="doc-section doc-section-full-width">
                        <h4>üìä Understanding the Data</h4>
                        <ul>
                            <li><strong>Aliases</strong> - Sets of platform related data extracted from various authoritative sources</li>
                            <li><strong>Unconfirmed Aliases</strong> - Aliases without validated CPE mappings, these need manual review and confirmation</li>
                            <li><strong>Confirmed Mapping Coverage</strong> - Percentage of aliases that already have validated CPE Mappings</li>
                            <li><strong>Alias Properties</strong> - Properties extracted from the CVE List <code>affected</code> array</li>
                            <li><strong>CPE Base String</strong> - Common Platform Enumeration Match String for representing a platform. Does not include <code>version</code> or <code>update</code> attribute data.</li>
                            <li><strong>CPE Applicability Statment (CPE-AS)</strong> - Common Platform Enumeration Applicability Statements are a json representation of platform data used to indicate which platforms are affected by a vulnerability</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="content">
            <div id="loadingMessage" class="loading">
                Select a source mapping extraction file to begin analysis
            </div>

            <div id="errorMessage" class="error" style="display: none;"></div>

            <div id="mainContent" style="display: none;">
                <div class="section">
                    <div class="aliases-section-header gradient-green" onclick="toggleAnalysis()">
                        <div class="section-header-flex">
                            <div style="text-align: left; flex: 1;">
                                <span style="font-weight: 600;">Source Alias Statistics</span>
                                <div style="font-size: 0.8em; opacity: 0.9; margin-top: 1px;">Analysis and breakdown of confirmed mappings and unconfirmed aliases</div>
                            </div>
                            <span id="analysis-chevron" style="font-size: 1.1em; flex-shrink: 0;">‚ñ≤</span>
                        </div>
                    </div>
                    <div class="analysis-content expanded" id="analysis-content">
                        <div class="section-content">
                            <div id="statsGrid" class="stats-grid">
                                <div class="stat-card coverage-tooltip">
                                    <div class="stat-value" id="totalAliases">-</div>
                                    <div class="stat-label">Total Unique Aliases</div>
                                    <div class="tooltiptext" id="aliasTooltip">
                                        <div class="tooltip-section">
                                            <div class="tooltip-formula">
                                                Confirmed Mapping + Unconfirmed Aliases + Unconfirmed Aliases with Data Concerns
                                            </div>
                                        </div>
                                        <div class="tooltip-section">
                                            <span class="tooltip-highlight">Current Calculation:</span><br>
                                            <span id="tooltipAliasCalculation">Loading...</span>
                                        </div>
                                        <div class="tooltip-section">
                                            <span class="tooltip-highlight">Breakdown:</span><br>
                                            <span id="tooltipAliasBreakdown">Loading...</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="stat-card coverage-tooltip">
                                    <div class="stat-value" id="confirmedMappingCoverage">-</div>
                                    <div class="stat-label">Confirmed Mapping Coverage</div>
                                    <div class="tooltiptext" id="coverageTooltip">
                                        <div class="tooltip-section">
                                            <span class="tooltip-highlight">Intersection-Based Coverage Calculation</span><br>
                                            <div class="tooltip-formula">
                                                (Unique Aliases in Confirmed Mappings √∑ Total Unique Aliases) √ó 100%
                                            </div>
                                        </div>
                                        <div class="tooltip-section">
                                            <span class="tooltip-highlight">Properties Compared:</span><br>
                                            <span style="font-size: 0.85em;">vendor, product, platform, platforms, collectionURL, repo, packageName</span>
                                        </div>
                                        <div class="tooltip-section">
                                            <span class="tooltip-highlight">Current Calculation:</span><br>
                                            <span id="tooltipCalculation">Loading...</span>
                                        </div>
                                        <div class="tooltip-section">
                                            <span class="tooltip-highlight">Data Sources:</span><br>
                                            <span id="tooltipCoverageBreakdown">Loading...</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="stat-card coverage-tooltip">
                                    <div class="stat-value" id="confirmedConcernCount">-</div>
                                    <div class="stat-label">Confirmed Mapping Alias Data Concerns</div>
                                    <div class="tooltiptext" id="concernTooltip">
                                        <div class="tooltip-section">
                                            <div class="tooltip-formula">
                                                (Confirmed Aliases with Data Quality Issues √∑ Total Confirmed Aliases) √ó 100%
                                            </div>
                                        </div>
                                        <div class="tooltip-section">
                                            <span class="tooltip-highlight">Current Calculation:</span><br>
                                            <span id="tooltipConcernCalculation">Loading...</span>
                                        </div>
                                        <div class="tooltip-section">
                                            <span class="tooltip-highlight">Breakdown:</span><br>
                                            <span id="tooltipConcernBreakdown">Loading...</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="stat-card coverage-tooltip">
                                    <div class="stat-value" id="externalConcernCount">-</div>
                                    <div class="stat-label">Unconfirmed Alias Data Concerns</div>
                                    <div class="tooltiptext" id="externalConcernTooltip">
                                        <div class="tooltip-section">
                                            <div class="tooltip-formula">
                                                (Unconfirmed Aliases with Data Quality Issues √∑ Total External Aliases) √ó 100%
                                            </div>
                                        </div>
                                        <div class="tooltip-section">
                                            <span class="tooltip-highlight">Current Calculation:</span><br>
                                            <span id="tooltipExternalConcernCalculation">Loading...</span>
                                        </div>
                                        <div class="tooltip-section">
                                            <span class="tooltip-highlight">Breakdown:</span><br>
                                            <span id="tooltipExternalConcernBreakdown">Loading...</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="filter-container" id="aliasFilter" style="display: none;">
                    <label for="filterInput" class="font-500 color-333">Filter:</label>
                    <input type="text" id="filterInput" class="form-input flex-1 mr-8 ml-8" placeholder="Enter search term..." />
                    <button id="searchButton" class="btn-primary">Search</button>
                    <button id="clearFilter" class="btn-secondary ml-4">Clear</button>
                </div>

                <div id="aliasGroups"></div>

                <!-- Unconfirmed Data Concerns Section -->
                <div id="sourceDataConcernGroups"></div>
            </div>
        </div>
    </div>

    <!-- Selection Panel -->
    <div class="selection-panel white-card" id="selectionPanel">
        <h4>Selected Aliases (<span id="selectionCount">0</span>)</h4>
        <div class="selection-list" id="selectionList"></div>
        <button class="consolidate-btn" id="consolidateBtn" onclick="consolidateAliases()">
            Update Confirmed Mappings
        </button>
    </div>

    <!-- Output Modal -->
    <div class="output-modal" id="outputModal">
        <div class="output-modal-content white-card" id="modalContent">
            <div class="modal-header" id="modalHeader">
                <h3>Update Confirmed Mappings</h3>
            </div>
            <div style="margin-bottom: 16px;">
                <label for="cpeBaseString" style="display: block; margin-bottom: 4px; font-weight: 500;">CPE Base String:</label>
                
                <!-- CPE Builder Input -->
                <div style="margin-bottom: 6px;">
                    <input type="text" id="cpeBaseString" placeholder="a:vendor:product" 
                           class="code-input"
                           oninput="handleCpeInput(this)"
                           onkeydown="handleCpeKeydown(event)">
                    <div id="cpeValidationMessage" style="font-size: 0.75em; margin-top: 2px; height: 18px; overflow: hidden; line-height: 1.2;"></div>
                    <div id="cpePreview" class="code-preview" style="height: 14px; overflow: hidden;"></div>
                </div>
                
                <!-- Existing CPE Dropdown -->
                <div>
                    <select id="existingCpeSelect" 
                            onchange="selectExistingCpe()" 
                            class="form-select"
                            style="width: 100%;">
                        <option value="">Or select from existing CPE strings...</option>
                    </select>
                </div>
            </div>
            <pre id="outputContent" class="code-output"></pre>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-primary" onclick="updateConfirmedMappings()">Update Confirmed Mappings</button>
                <button class="modal-btn modal-btn-secondary" onclick="closeOutputModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Processing Overlay (positioned at body level for maximum z-index effectiveness) -->
    <div id="processingOverlay" class="processing-overlay">
        <div class="processing-card">
            <div class="processing-spinner"></div>
            <div id="processingTitle" class="processing-title">Processing Data</div>
            <div id="processingMessage" class="processing-message">Please wait while we process your request...</div>
            <div class="processing-progress">
                <div id="processingProgressBar" class="processing-progress-bar" style="width: 0%;"></div>
            </div>
            <div id="processingDetails" class="processing-details"></div>
        </div>
    </div>

    <script>
        // Active global variables still needed by current system
        let currentData = null;  // Used for compatibility and download functions

        // ========== DATA MANAGER ==========
        const DataManager = {
            // Raw input data (immutable after load)
            rawData: null,
            
            // Simple ID counter for performance optimization
            aliasIdCounter: 1,
            
            // Three distinct datasets with explicit labels
            datasets: {
                confirmedMapping: [],           // From confirmedMappings array
                unconfirmedAliases: [],        // From aliasGroups with no data concerns  
                sourceDataConcernAliases: []   // From aliasGroups with data quality issues
            },
            
            // Processed data for display
            displayData: {
                confirmedMapping: [],
                unconfirmedAliases: [],
                sourceDataConcernAliases: []
            },
            
            // Current filter/search state
            filters: {
                searchText: '',
                activeDatasets: ['confirmedMapping', 'unconfirmedAliases', 'sourceDataConcernAliases']
            },
            
            // Utility methods
            clearAllDatasets: function() {
                this.datasets.confirmedMapping = [];
                this.datasets.unconfirmedAliases = [];
                this.datasets.sourceDataConcernAliases = [];
                this.displayData.confirmedMapping = [];
                this.displayData.unconfirmedAliases = [];
                this.displayData.sourceDataConcernAliases = [];
            },
            
            getDataset: function(datasetType) {
                if (datasetType === 'confirmedMapping') {
                    // Confirmed mappings have nested structure: [{cpeBaseString, aliases: [...]}, ...]
                    // Flatten to array of aliases with cpeBaseString property
                    const flattenedAliases = [];
                    const confirmedMappings = this.displayData[datasetType] || [];
                    
                    console.debug(`[getDataset] confirmedMapping: ${confirmedMappings.length} mappings found`);
                    
                    confirmedMappings.forEach((mapping, index) => {
                        console.debug(`[getDataset] Mapping ${index}: CPE=${mapping.cpeBaseString}, aliases=${mapping.aliases ? mapping.aliases.length : 'null'}`);
                        if (mapping.aliases && Array.isArray(mapping.aliases)) {
                            mapping.aliases.forEach(alias => {
                                flattenedAliases.push({
                                    ...alias,
                                    cpeBaseString: mapping.cpeBaseString
                                });
                            });
                        }
                    });
                    
                    console.debug(`[getDataset] confirmedMapping result: ${flattenedAliases.length} total aliases`);
                    return flattenedAliases;
                } else {
                    // Unconfirmed and source data concern aliases are flat arrays
                    return this.displayData[datasetType] || [];
                }
            },
            
            // Test function to verify structure
            validateStructure: function() {
                const expectedDatasets = ['confirmedMapping', 'unconfirmedAliases', 'sourceDataConcernAliases'];
                for (const dataset of expectedDatasets) {
                    if (!Array.isArray(this.datasets[dataset])) {
                        throw new Error(`Dataset ${dataset} is not an array`);
                    }
                    if (!Array.isArray(this.displayData[dataset])) {
                        throw new Error(`DisplayData ${dataset} is not an array`);
                    }
                }
                return true;
            },
            
            // Filter management methods
            setSearchFilter: function(searchText) {
                this.filters.searchText = searchText;
            },
            
            getActiveDatasets: function() {
                return this.filters.activeDatasets;
            },
            
            // ========== DATA LOADING METHOD ==========
            
            // Load raw JSON data and populate the three datasets
            loadData: function(jsonData) {
                try {
                    // Validate input data
                    if (!jsonData || !jsonData.aliasGroups) {
                        throw new Error('Invalid data format: missing aliasGroups');
                    }
                    
                    // Store raw data
                    this.rawData = jsonData;
                    
                    // Clear existing datasets
                    this.clearAllDatasets();
                    
                    // Process aliasGroups data into unconfirmed and concerning datasets
                    jsonData.aliasGroups.forEach(mapping => {
                        mapping.aliases.forEach(alias => {
                            // Create processed alias with required fields
                            const processedAlias = {
                                ...alias,
                                id: this.aliasIdCounter++, // Assign unique numeric ID
                                cveCount: alias.source_cve ? alias.source_cve.length : 0,
                                uniqueCveCount: alias.source_cve ? new Set(alias.source_cve).size : 0,
                                aliasGroup: alias.aliasGroup || mapping.aliasGroup,
                                isConfirmedMapping: false
                            };
                            
                            // Create search text for filtering
                            const searchFields = [
                                alias.alias || '',
                                alias.product || '',
                                alias.vendor || '',
                                alias.version || '',
                                alias.update || '',
                                alias.edition || '',
                                alias.language || ''
                            ];
                            processedAlias._searchText = searchFields.join(' ').toLowerCase();
                            
                            // Detect source data concerns using global function (aligned with testing implementations)
                            const concerns = detectSourceDataConcerns(alias);
                            processedAlias.concerns = concerns;
                            
                            console.log(`Processed unconfirmed alias:`, alias.vendor, alias.product, `platform: "${alias.platform || alias.platforms || 'N/A'}"`, `concerns: ${concerns.length}`);
                            
                            // Separate into datasets based on concerns
                            if (concerns.length > 0) {
                                console.log(`Adding unconfirmed alias with concerns to sourceDataConcernAliases:`, alias.vendor, alias.product);
                                this.datasets.sourceDataConcernAliases.push(processedAlias);
                            } else {
                                this.datasets.unconfirmedAliases.push(processedAlias);
                            }
                        });
                    });
                    
                    // Process confirmedMappings data if it exists
                    if (jsonData.confirmedMappings) {
                        console.log('Processing confirmedMappings data with', jsonData.confirmedMappings.length, 'mappings');
                        
                        // Build confirmed aliases lookup for deduplication
                        const confirmedAliasesLookup = new Set();
                        
                        jsonData.confirmedMappings.forEach((confirmedMapping, index) => {
                            // Handle both cpeBaseString (camelCase) and cpebasestring (lowercase) formats
                            const cpeBaseString = confirmedMapping.cpeBaseString || confirmedMapping.cpebasestring;
                            if (!cpeBaseString) {
                                console.error('Missing required cpeBaseString in confirmed mapping:', confirmedMapping);
                                return; // Skip this mapping if no CPE base string
                            }
                            
                            console.log(`Processing confirmed mapping ${index + 1}:`, cpeBaseString, 'with', confirmedMapping.aliases.length, 'aliases');
                            
                            // confirmedMapping dataset should receive processed confirmed mappings
                            // Process aliases for this CPE base string
                            const processedAliases = [];
                            confirmedMapping.aliases.forEach(alias => {
                                const processedAlias = {
                                    ...alias,
                                    id: this.aliasIdCounter++, // Assign unique numeric ID
                                    cveCount: alias.source_cve ? alias.source_cve.length : 0,
                                    uniqueCveCount: alias.source_cve ? new Set(alias.source_cve).size : 0,
                                    aliasGroup: alias.source_cve && alias.source_cve.length > 0 ? 'Confirmed_Mapping_WithData' : 'Confirmed_Mapping_NoData',
                                    isConfirmedMapping: true,
                                    hasCveData: alias.source_cve && alias.source_cve.length > 0,
                                    frequency: alias.frequency || 0,
                                    cpeBaseString: cpeBaseString // Store CPE base string for reference
                                };
                                
                                // Create search text for filtering
                                const searchFields = [
                                    alias.alias || '',
                                    alias.product || '',
                                    alias.vendor || '',
                                    alias.version || '',
                                    alias.update || '',
                                    alias.edition || '',
                                    alias.language || '',
                                    alias.platform || ''
                                ];
                                processedAlias._searchText = searchFields.join(' ').toLowerCase();
                                
                                // Detect concerns using global function (aligned with testing implementations)
                                const concerns = detectSourceDataConcerns(alias);
                                processedAlias.concerns = concerns;
                                
                                console.log(`Adding confirmed alias to dataset:`, processedAlias.vendor, processedAlias.product, `platform: "${processedAlias.platform || 'N/A'}"`, `cpeBaseString: ${cpeBaseString}`, `concerns: ${concerns.length}`);
                                processedAliases.push(processedAlias);
                                
                                // Add to lookup for deduplication - create key based on vendor, product, and platform
                                const vendor = (alias.vendor || '').toLowerCase().trim();
                                const product = (alias.product || '').toLowerCase().trim();
                                const platform = (alias.platform || alias.platforms || '').toLowerCase().trim();
                                const lookupKey = `${vendor}:${product}:${platform}`;
                                confirmedAliasesLookup.add(lookupKey);
                                
                                // Debug logging for specific cases
                                if (product.includes('windows server 2019')) {
                                    console.log(`Added confirmed key: "${lookupKey}"`);
                                }
                            });
                            
                            // Store as nested structure with CPE base string and processed aliases
                            this.datasets.confirmedMapping.push({
                                cpeBaseString: cpeBaseString,
                                aliases: processedAliases
                            });
                        });
                        
                        // Deduplicate: Remove aliases from unconfirmed datasets that match confirmed mappings
                        console.log(`Deduplicating aliases using ${confirmedAliasesLookup.size} confirmed mappings...`);
                        console.log('Sample confirmed keys:', Array.from(confirmedAliasesLookup).slice(0, 5));
                        let dedupeCount = 0;
                        
                        // Check unconfirmedAliases dataset
                        this.datasets.unconfirmedAliases = this.datasets.unconfirmedAliases.filter(alias => {
                            const vendor = (alias.vendor || '').toLowerCase().trim();
                            const product = (alias.product || '').toLowerCase().trim();
                            const platform = (alias.platform || alias.platforms || '').toLowerCase().trim();
                            const lookupKey = `${vendor}:${product}:${platform}`;
                            
                            // Debug logging for specific cases
                            if (product.includes('windows server 2019')) {
                                console.log(`Checking unconfirmed: "${lookupKey}" - Exact match: ${confirmedAliasesLookup.has(lookupKey)}`);
                            }
                            
                            if (confirmedAliasesLookup.has(lookupKey)) {
                                console.log(`Removing duplicate from unconfirmed: ${alias.vendor} ${alias.product} (${platform})`);
                                dedupeCount++;
                                return false; // Remove this alias
                            }
                            return true; // Keep this alias
                        });
                        
                        // Check sourceDataConcernAliases dataset
                        this.datasets.sourceDataConcernAliases = this.datasets.sourceDataConcernAliases.filter(alias => {
                            const vendor = (alias.vendor || '').toLowerCase().trim();
                            const product = (alias.product || '').toLowerCase().trim();
                            const platform = (alias.platform || alias.platforms || '').toLowerCase().trim();
                            const lookupKey = `${vendor}:${product}:${platform}`;
                            
                            if (confirmedAliasesLookup.has(lookupKey)) {
                                console.log(`Removing duplicate from concerns: ${alias.vendor} ${alias.product} (${platform})`);
                                dedupeCount++;
                                return false; // Remove this alias
                            }
                            return true; // Keep this alias
                        });
                        
                        console.log(`Deduplication complete: removed ${dedupeCount} duplicates`);
                    }
                    
                    // Update display data
                    this.displayData.confirmedMapping = [...this.datasets.confirmedMapping];
                    this.displayData.unconfirmedAliases = [...this.datasets.unconfirmedAliases];
                    this.displayData.sourceDataConcernAliases = [...this.datasets.sourceDataConcernAliases];
                    
                    // Count confirmed aliases in nested structure
                    const confirmedAliasCount = this.datasets.confirmedMapping.reduce((total, mapping) => {
                        return total + (mapping.aliases ? mapping.aliases.length : 0);
                    }, 0);
                    
                    console.log(`Loaded data: ${confirmedAliasCount} confirmed, ${this.datasets.unconfirmedAliases.length} unconfirmed, ${this.datasets.sourceDataConcernAliases.length} concerning aliases`);
                    
                    return { 
                        success: true, 
                        confirmedCount: confirmedAliasCount,
                        unconfirmedCount: this.datasets.unconfirmedAliases.length,
                        concernCount: this.datasets.sourceDataConcernAliases.length
                    };
                    
                } catch (error) {
                    console.error(`loadData failed: ${error.message}`);
                    return { success: false, error: error.message };
                }
            },

            // ========== DATASET PROCESSING METHODS ==========            
            // Remove alias from source dataset
            removeAlias: function(aliasId, sourceDataset) {
                try {
                    if (!this.datasets[sourceDataset]) {
                        throw new Error(`Invalid source dataset: ${sourceDataset}`);
                    }
                    
                    const dataset = this.datasets[sourceDataset];
                    const index = dataset.findIndex(item => item.id === aliasId || item.aliasGroup === aliasId);
                    
                    if (index === -1) {
                        throw new Error(`Alias ID ${aliasId} not found in ${sourceDataset}`);
                    }
                    
                    // Remove from dataset
                    const removedItem = dataset.splice(index, 1)[0];
                    
                    // Update display data
                    this.displayData[sourceDataset] = [...dataset];
                    
                    // Refresh display for the affected dataset
                    const displayResult = updateDatasetDisplay([sourceDataset]);
                    if (!displayResult.success) {
                        console.warn(`Display update failed after removeAlias: ${displayResult.error}`);
                    }
                    
                    // Update dashboard statistics after removing alias
                    updateStatsFromDataManager();
                    
                    console.log(`Removed alias ${aliasId} from ${sourceDataset}`);
                    return { success: true, removedItem: removedItem };
                    
                } catch (error) {
                    console.error(`removeAlias failed: ${error.message}`);
                    return { success: false, error: error.message };
                }
            },
            
            // Move alias from source dataset to confirmedMapping with CPE base string
            mergeWithConfirmed: function(aliasId, sourceDataset, cpeBaseString) {
                try {
                    // Validate inputs
                    if (!this.datasets[sourceDataset]) {
                        throw new Error(`Invalid source dataset: ${sourceDataset}`);
                    }
                    
                    // Normalize and validate CPE base string
                    cpeBaseString = normalizeCpeString(cpeBaseString);
                    
                    // Sanitize to fix any corruption patterns
                    const fixResult = validateAndFixCPE(cpeBaseString);
                    if (fixResult.wasCorrupted) {
                        console.warn('üîß CPE corruption detected and fixed:', {
                            original: fixResult.original,
                            fixed: fixResult.fixed
                        });
                        cpeBaseString = fixResult.fixed;
                    }
                    
                    const validation = fixResult.validation;
                    if (!validation.valid) {
                        if (validation.errors && validation.errors.length > 0) {
                            throw new Error(`CPE validation failed: ${validation.errors.join(', ')}`);
                        } else {
                            throw new Error(`CPE validation failed: ${validation.message}`);
                        }
                    }
                    
                    // Ensure CPE base string format: version and update must be wildcards
                    cpeBaseString = ensureCpeBaseString(cpeBaseString);
                    
                    // Find the alias in source dataset using efficient ID lookup
                    const sourceData = this.datasets[sourceDataset];
                    const aliasIndex = sourceData.findIndex(item => item.id === aliasId);
                    
                    if (aliasIndex === -1) {
                        throw new Error(`Alias ID ${aliasId} not found in ${sourceDataset}`);
                    }
                    
                    const aliasItem = sourceData[aliasIndex];
                    
                    // Check for conflicts: alias already exists in different CPE base string
                    const confirmedData = this.datasets.confirmedMapping;
                    console.log(`Checking conflicts for alias ${aliasId} against ${confirmedData.length} existing CPE mappings`);
                    
                    for (const mapping of confirmedData) {
                        if (mapping.cpeBaseString !== cpeBaseString) {
                            // Check if this alias already exists in a different CPE mapping
                            // Must match vendor, product, AND platform (including null/undefined cases)
                            const hasConflict = mapping.aliases && mapping.aliases.some(alias => 
                                (alias.vendor === aliasItem.vendor && 
                                 alias.product === aliasItem.product &&
                                 (alias.platform || '') === (aliasItem.platform || '')) ||
                                (aliasItem.aliases && aliasItem.aliases.some(subAlias => 
                                    alias.vendor === subAlias.vendor && 
                                    alias.product === subAlias.product &&
                                    (alias.platform || '') === (subAlias.platform || '')
                                ))
                            );
                            if (hasConflict) {
                                console.error(`Conflict detected: alias ${aliasId} (${aliasItem.vendor}:${aliasItem.product}:${aliasItem.platform || 'no-platform'}) already exists in CPE: ${mapping.cpeBaseString}`);
                                throw new Error(`Alias already exists in different CPE base string: ${mapping.cpeBaseString}`);
                            }
                        }
                    }
                    
                    // Check if cpeBaseString already exists in confirmedMapping
                    let targetMapping = confirmedData.find(item => item.cpeBaseString === cpeBaseString);
                    
                    // Prepare alias data for confirmed mapping format
                    const aliasData = [];
                    if (aliasItem.aliases && Array.isArray(aliasItem.aliases)) {
                        // Multiple aliases from alias group - filter placeholders from each
                        const cleanedAliases = aliasItem.aliases.map(alias => {
                            const cleanedAlias = { ...alias };
                            // Filter out placeholder platform values
                            if (cleanedAlias.platform && (
                                cleanedAlias.platform === '' || 
                                cleanedAlias.platform === 'N/A' || 
                                cleanedAlias.platform === 'n/a' || 
                                cleanedAlias.platform === 'unknown' || 
                                cleanedAlias.platform === '*' ||
                                cleanedAlias.platform === 'null' ||
                                cleanedAlias.platform === 'none'
                            )) {
                                delete cleanedAlias.platform;
                            }
                            return cleanedAlias;
                        });
                        aliasData.push(...cleanedAliases);
                    } else {
                        // Single alias item - preserve properties but filter placeholders
                        const singleAlias = {
                            ...aliasItem, // Copy all properties
                            isConfirmedMapping: true, // Mark as confirmed
                            cpeBaseString: cpeBaseString // Add CPE reference
                        };
                        
                        // Filter out placeholder platform values to avoid carrying them forward
                        if (singleAlias.platform && (
                            singleAlias.platform === '' || 
                            singleAlias.platform === 'N/A' || 
                            singleAlias.platform === 'n/a' || 
                            singleAlias.platform === 'unknown' || 
                            singleAlias.platform === '*' ||
                            singleAlias.platform === 'null' ||
                            singleAlias.platform === 'none'
                        )) {
                            delete singleAlias.platform;
                        }
                        aliasData.push(singleAlias);
                    }
                    
                    if (targetMapping) {
                        // Add to existing CPE base string entry
                        if (!targetMapping.aliases) targetMapping.aliases = [];
                        targetMapping.aliases.push(...aliasData);
                    } else {
                        // Create new CPE base string entry
                        const newMapping = {
                            cpeBaseString: cpeBaseString,
                            aliases: aliasData
                        };
                        confirmedData.push(newMapping);
                    }
                    
                    // Remove from source dataset
                    sourceData.splice(aliasIndex, 1);
                    
                    // CRITICAL: Update both datasets and displayData to ensure synchronization
                    this.datasets[sourceDataset] = [...sourceData];
                    this.displayData[sourceDataset] = [...sourceData];
                    this.datasets.confirmedMapping = [...confirmedData];
                    this.displayData.confirmedMapping = [...confirmedData];
                    
                    // Note: Display update will be handled by the calling function to avoid race conditions
                    
                    console.log(`After removal: ${sourceDataset} has ${sourceData.length} items, confirmedMapping has ${confirmedData.length} items`);
                    
                    console.log(`Merged alias ${aliasId} from ${sourceDataset} to confirmed mapping: ${cpeBaseString}`);
                    return { success: true, cpeBaseString: cpeBaseString, aliasCount: aliasData.length };
                    
                } catch (error) {
                    console.error(`mergeWithConfirmed failed: ${error.message}`);
                    return { success: false, error: error.message };
                }
            },
            
            // Alias function for moveToConfirmed (same as mergeWithConfirmed)
            moveToConfirmed: function(aliasId, sourceDataset, cpeBaseString) {
                // Use the existing mergeWithConfirmed implementation
                const result = this.mergeWithConfirmed(aliasId, sourceDataset, cpeBaseString);
                
                // Update display for both source dataset and confirmed mapping
                if (result.success) {
                    const displayResult = updateDatasetDisplay([sourceDataset, 'confirmedMapping']);
                    if (!displayResult.success) {
                        console.warn(`Display update failed after moveToConfirmed: ${displayResult.error}`);
                    }
                    
                    // Update dashboard statistics after confirmed mapping changes
                    updateStatsFromDataManager();
                }
                
                return result;
            },
            
            // Batch merge multiple aliases with confirmed mappings
            batchMergeWithConfirmed: function(transferMap) {
                try {
                    // Validate transferMap structure
                    if (!transferMap || typeof transferMap !== 'object') {
                        throw new Error('Invalid transferMap: must be an object');
                    }
                    
                    // Create backup of current state for rollback
                    const backup = {
                        confirmedMapping: JSON.parse(JSON.stringify(this.datasets.confirmedMapping)),
                        unconfirmedAliases: JSON.parse(JSON.stringify(this.datasets.unconfirmedAliases)),
                        sourceDataConcernAliases: JSON.parse(JSON.stringify(this.datasets.sourceDataConcernAliases))
                    };
                    
                    const results = [];
                    const errors = [];
                    
                    // Process each transfer
                    for (const [aliasId, transferData] of Object.entries(transferMap)) {
                        const { sourceDataset, cpeBaseString } = transferData;
                        
                        const result = this.mergeWithConfirmed(aliasId, sourceDataset, cpeBaseString);
                        
                        if (result.success) {
                            results.push({ aliasId, ...result });
                        } else {
                            errors.push({ aliasId, error: result.error });
                        }
                    }
                    
                    // If any errors occurred, rollback all changes
                    if (errors.length > 0) {
                        // Restore backup
                        this.datasets.confirmedMapping = backup.confirmedMapping;
                        this.datasets.unconfirmedAliases = backup.unconfirmedAliases;
                        this.datasets.sourceDataConcernAliases = backup.sourceDataConcernAliases;
                        
                        // Update display data
                        this.displayData.confirmedMapping = [...backup.confirmedMapping];
                        this.displayData.unconfirmedAliases = [...backup.unconfirmedAliases];
                        this.displayData.sourceDataConcernAliases = [...backup.sourceDataConcernAliases];
                        
                        // Refresh display after rollback
                        const displayResult = updateDatasetDisplay(['confirmedMapping', 'unconfirmedAliases', 'sourceDataConcernAliases']);
                        if (!displayResult.success) {
                            console.warn(`Display update failed after rollback: ${displayResult.error}`);
                        }
                        
                        // Update dashboard statistics after rollback
                        updateStatsFromDataManager();
                        
                        const errorMsg = `Batch merge failed, rolled back all changes. Errors: ${errors.map(e => e.error).join('; ')}`;
                        console.error(errorMsg);
                        throw new Error(errorMsg);
                    }
                    
                    // Refresh display for all datasets (batch operations can affect multiple datasets)
                    const displayResult = updateDatasetDisplay(['confirmedMapping', 'unconfirmedAliases', 'sourceDataConcernAliases']);
                    if (!displayResult.success) {
                        console.warn(`Display update failed after batchMergeWithConfirmed: ${displayResult.error}`);
                    }
                    
                    // Update dashboard statistics after batch confirmed mapping changes
                    updateStatsFromDataManager();
                    
                    console.log(`Batch merge completed successfully: ${results.length} aliases processed`);
                    return { success: true, processed: results.length, results: results };
                    
                } catch (error) {
                    console.error(`batchMergeWithConfirmed failed: ${error.message}`);
                    return { success: false, error: error.message };
                }
            },
            
            // Export confirmed mappings as JSON file with auto-download
            exportConfirmedMappings: function() {
                try {
                    // Get source UUID from loaded data or generate fallback
                    let sourceUuid = null;
                    let cnaId = null;
                    
                    if (window.currentData && window.currentData.metadata && window.currentData.metadata.target_uuid) {
                        sourceUuid = window.currentData.metadata.target_uuid;
                        cnaId = sourceUuid;
                    } else if (this.rawData && this.rawData.metadata && this.rawData.metadata.target_uuid) {
                        sourceUuid = this.rawData.metadata.target_uuid;
                        cnaId = sourceUuid;
                    } else {
                        // Fallback to generated ID if no source UUID available
                        cnaId = 'generated-' + Date.now().toString(36);
                        sourceUuid = 'unknown';
                    }
                    
                    // Create export structure matching microsoft.json format
                    const exportData = {
                        cnaId: cnaId,
                        confirmedMappings: this.datasets.confirmedMapping.map(mapping => ({
                            cpeBaseString: ensureCpeBaseString(mapping.cpeBaseString),
                            aliases: mapping.aliases || []
                        }))
                    };
                    
                    // Create JSON blob
                    const jsonString = JSON.stringify(exportData, null, 4);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    
                    // Generate filename with source UUID prefix and timestamp
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                    const filename = `${sourceUuid}-confirmed-mappings-${timestamp}.json`;
                    
                    // Create download link and trigger download
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    
                    console.log(`Exported confirmed mappings to: ${filename}`);
                    return { success: true, filename: filename, entryCount: exportData.confirmedMappings.length, sourceUuid: sourceUuid };
                    
                } catch (error) {
                    console.error(`exportConfirmedMappings failed: ${error.message}`);
                    return { success: false, error: error.message };
                }
            },
            
            // Refresh display for specified datasets
            refreshDatasetDisplay: function(sourceDatasetList) {
                try {
                    if (!Array.isArray(sourceDatasetList)) {
                        sourceDatasetList = [sourceDatasetList];
                    }
                    
                    const validDatasets = ['confirmedMapping', 'unconfirmedAliases', 'sourceDataConcernAliases'];
                    const refreshedDatasets = [];
                    
                    for (const dataset of sourceDatasetList) {
                        if (!validDatasets.includes(dataset)) {
                            console.warn(`Invalid dataset for refresh: ${dataset}`);
                            continue;
                        }
                        
                        // Update display data
                        this.displayData[dataset] = [...this.datasets[dataset]];
                        refreshedDatasets.push(dataset);
                    }
                    
                    // Trigger UI refresh using new display system
                    if (refreshedDatasets.length > 0) {
                        const displayResult = updateDatasetDisplay(refreshedDatasets);
                        if (!displayResult.success) {
                            throw new Error(`Display update failed: ${displayResult.error}`);
                        }
                    }
                    
                    console.log(`Refreshed display for datasets: ${refreshedDatasets.join(', ')}`);
                    return { success: true, refreshed: refreshedDatasets };
                    
                } catch (error) {
                    console.error(`refreshDatasetDisplay failed: ${error.message}`);
                    return { success: false, error: error.message };
                }
            }
        };

        // ========== NEW DATASET DISPLAY SYSTEM ==========
        
        /**
         * Updates the display areas based on specified DataManager datasets
         * @param {Array<string>} datasetsToUpdate - Array of dataset names to update
         *   Valid values: 'confirmedMapping', 'unconfirmedAliases', 'sourceDataConcernAliases'
         */
        function updateDatasetDisplay(datasetsToUpdate = ['confirmedMapping', 'unconfirmedAliases', 'sourceDataConcernAliases']) {
            try {
                // Validate input
                if (!Array.isArray(datasetsToUpdate)) {
                    throw new Error('datasetsToUpdate must be an array');
                }
                
                const validDatasets = ['confirmedMapping', 'unconfirmedAliases', 'sourceDataConcernAliases'];
                const invalidDatasets = datasetsToUpdate.filter(dataset => !validDatasets.includes(dataset));
                if (invalidDatasets.length > 0) {
                    throw new Error(`Invalid datasets: ${invalidDatasets.join(', ')}`);
                }
                
                // Clear filtering state (no retention between display refreshes)
                allSortedAliases = null;
                allConcerningAliases = null;
                
                // Clear and reset the search filter UI
                clearSearchFilter();
                
                // Prepare data from DataManager
                const mainAliasData = [];
                const concernAliasData = [];
                
                // Process each requested dataset
                datasetsToUpdate.forEach(datasetName => {
                    const datasetArray = DataManager.getDataset(datasetName);
                    
                    if (datasetName === 'sourceDataConcernAliases') {
                        // Source data concerns go to separate section
                        concernAliasData.push(...datasetArray);
                    } else {
                        // confirmedMapping and unconfirmedAliases go to main section
                        mainAliasData.push(...datasetArray);
                    }
                });
                
                // Sort main alias data (confirmed mappings first, then by CVE count)
                const sortedMainData = mainAliasData.sort((a, b) => {
                    // Primary sort: confirmed mappings first
                    if (a.isConfirmedMapping !== b.isConfirmedMapping) {
                        return b.isConfirmedMapping ? 1 : -1;
                    }
                    
                    // Secondary sort: CVE count (highest first)
                    if (b.cveCount !== a.cveCount) {
                        return b.cveCount - a.cveCount;
                    }
                    
                    // Tertiary sort: Product name (alphabetical)
                    const productA = (a.product || '').toLowerCase();
                    const productB = (b.product || '').toLowerCase();
                    return productA.localeCompare(productB);
                });
                
                // Sort concern data by CVE count
                const sortedConcernData = concernAliasData.sort((a, b) => {
                    if (b.cveCount !== a.cveCount) {
                        return b.cveCount - a.cveCount;
                    }
                    const productA = (a.product || '').toLowerCase();
                    const productB = (b.product || '').toLowerCase();
                    return productA.localeCompare(productB);
                });
                
                // Update display areas
                if (datasetsToUpdate.includes('confirmedMapping') || datasetsToUpdate.includes('unconfirmedAliases')) {
                    displayAliasesByFrequency(sortedMainData);
                    
                    // Update global filter variables for compatibility
                    allSortedAliases = sortedMainData;
                }
                
                if (datasetsToUpdate.includes('sourceDataConcernAliases')) {
                    displaySourceDataConcerns(sortedConcernData);
                    
                    // Update global filter variables for compatibility
                    allConcerningAliases = sortedConcernData;
                }
                
                // Reinitialize filter system (no retention between refreshes)
                if (typeof initializeFilter === 'function') {
                    initializeFilter();
                }
                
                console.log(`Display updated for datasets: ${datasetsToUpdate.join(', ')}`);
                return { success: true, updated: datasetsToUpdate };
                
            } catch (error) {
                console.error(`updateDatasetDisplay failed: ${error.message}`);
                return { success: false, error: error.message };
            }
        }

        // ========== CACHED DOM ELEMENTS ==========
        let fileInput, searchButton, clearButton, errorMessage, loadingMessage, mainContent, statsGrid;

        // ===========================================
        // DATA PATTERN DEFINITIONS FOR REVIEW
        // Organized by detection category for easy maintenance
        // Should be synchronized with Python platform_entry_registry.py patterns
        // ===========================================
        
        // === PLACEHOLDER DETECTION PATTERNS ===
        const GENERAL_PLACEHOLDER_VALUES = [
            'unspecified', 'unknown', 'none', 'undefined', 'various',
            'n/a', 'not available', 'not applicable', 'unavailable',
            'na', 'nil', 'tbd', 'to be determined', 'pending',
            'not specified', 'not determined', 'not known', 'not listed',
            'not provided', 'missing', 'empty', 'null', '-',
            'see references', 'see advisory', 'check', 'noted', 'all',
            'contact vendor', 'check with vendor'
        ];

        // === TEXT COMPARATOR DETECTION PATTERNS ===
        const TEXT_COMPARATOR_PATTERNS = {
            'Upper Bound Comparators': ['prior to', 'earlier than', 'before', 'until', 'below', 'up to'],
            'Lower Bound Comparators': ['later than', 'newer than', 'after', 'since', 'from', 'above'],
            'Range Separators': ['through', 'thru', 'between', 'and', 'to'],
            'Approximation Patterns': ['about', 'approximately', 'circa', 'around', 'roughly'],
            'Inclusive/Exclusive Indicators': ['inclusive', 'exclusive', 'including', 'excluding'],
            'Temporal/Status Indicators': ['earliest', 'recent', 'legacy', 'past', 'future', 'latest', 'current']
        };
        
        // Flattened list for detection logic
        const ALL_TEXT_COMPARATOR_PATTERNS = [];
        for (const patternType in TEXT_COMPARATOR_PATTERNS) {
            ALL_TEXT_COMPARATOR_PATTERNS.push(...TEXT_COMPARATOR_PATTERNS[patternType]);
        }

        // === REGEX PATTERN DEFINITIONS ===
        const HYPHENATED_VERSION_RANGE_REGEX = /\d+(?:\.\d+)*\s+-\s+\d+(?:\.\d+)*/i;
        
        // Whitespace detection patterns
        const LEADING_WHITESPACE_REGEX = /^\s+/;
        const TRAILING_WHITESPACE_REGEX = /\s+$/;
        const EXCESSIVE_SPACES_REGEX = /\s{2,}/;  // 2+ consecutive spaces

        // === MATHEMATICAL COMPARATOR PATTERNS ===
        const MATHEMATICAL_COMPARATOR_PATTERNS = ['<', '>', '=', '<=', '=<', '=>', '>=', '!='];

        // === INVALID CHARACTER PATTERNS ===
        const VALID_VERSION_PATTERN = /^(\*|[a-zA-Z0-9]+[-*_:.+()~a-zA-Z0-9]*)$/;
        const INVALID_CHARS_FINDER = /[^a-zA-Z0-9\-*_:.+()~]/g;

        // ========== GLOBAL CONSTANTS ==========
        const cve5Properties = [
            'vendor', 'product', 'platform', 'collectionURL', 'packageName', 'cpes', 
            'modules', 'programFiles', 'programRoutines', 'repo'
        ];

        // ========== UTILITY FUNCTIONS ==========
        function initializeCachedElements() {
            fileInput = document.getElementById('fileInput');
            searchButton = document.getElementById('searchButton');
            clearButton = document.getElementById('clearFilter');
            errorMessage = document.getElementById('errorMessage');
            loadingMessage = document.getElementById('loadingMessage');
            mainContent = document.getElementById('mainContent');
            statsGrid = document.getElementById('statsGrid');
        }

        // Synchronized placeholder detection function
        function isPlaceholderValue(value) {
            if (!value || value === '' || value === null || value === undefined) {
                return true;
            }
            
            if (typeof value === 'string') {
                const valueLower = value.toLowerCase().trim();
                return GENERAL_PLACEHOLDER_VALUES.some(placeholder => valueLower === placeholder.toLowerCase());
            }
            
            return false;
        }

        // Helper function to get display value or empty string if placeholder
        function getDisplayValue(value, fallback = '') {
            return isPlaceholderValue(value) ? fallback : value;
        }

        function detectSourceDataConcerns(alias) {
            const concerns = [];
            
            // ===========================================
            // COMPLETE PYTHON SDC REPLICATION (9/9 GROUPS)
            // Implements all Python platform_entry_registry.py detection groups
            // ===========================================
            
            // Use centralized field list to ensure all supported fields are checked
            const aliasFields = cve5Properties.filter(field => 
                ['vendor', 'product', 'platform', 'packageName', 'collectionURL', 'repo'].includes(field)
            );
            
            // === 1. PLACEHOLDER DETECTION (Python: placeholderValues) ===
            aliasFields.forEach(fieldName => {
                if (alias[fieldName] && typeof alias[fieldName] === 'string') {
                    const fieldValue = alias[fieldName];
                    const fieldLower = fieldValue.toLowerCase().trim();
                    
                    // Check against centralized placeholder patterns
                    const isPlaceholder = GENERAL_PLACEHOLDER_VALUES.some(val => fieldLower === val.toLowerCase());
                    
                    if (isPlaceholder) {
                        concerns.push({
                            type: "placeholderValues",
                            field: fieldName,
                            value: fieldValue,
                            detectedPattern: fieldValue,
                            issue: `${fieldName.charAt(0).toUpperCase() + fieldName.slice(1)} field contains placeholder value preventing CPE matching`
                        });
                    }
                }
            });
            
            // === 2. WHITESPACE ISSUES (Python: whitespaceIssues) ===
            aliasFields.forEach(fieldName => {
                if (alias[fieldName] && typeof alias[fieldName] === 'string') {
                    const fieldValue = alias[fieldName];
                    
                    // Leading whitespace
                    if (LEADING_WHITESPACE_REGEX.test(fieldValue)) {
                        concerns.push({
                            type: "whitespaceIssues",
                            field: fieldName,
                            value: fieldValue,
                            detectedPattern: "leading whitespace",
                            issue: `${fieldName.charAt(0).toUpperCase() + fieldName.slice(1)} field has leading whitespace`
                        });
                    }
                    
                    // Trailing whitespace
                    if (TRAILING_WHITESPACE_REGEX.test(fieldValue)) {
                        concerns.push({
                            type: "whitespaceIssues",
                            field: fieldName,
                            value: fieldValue,
                            detectedPattern: "trailing whitespace",
                            issue: `${fieldName.charAt(0).toUpperCase() + fieldName.slice(1)} field has trailing whitespace`
                        });
                    }
                    
                    // Excessive internal spaces (2+ consecutive)
                    if (EXCESSIVE_SPACES_REGEX.test(fieldValue)) {
                        concerns.push({
                            type: "whitespaceIssues",
                            field: fieldName,
                            value: fieldValue,
                            detectedPattern: "excessive spaces",
                            issue: `${fieldName.charAt(0).toUpperCase() + fieldName.slice(1)} field contains excessive internal spaces`
                        });
                    }
                }
            });
            
            // === 3. TEXT COMPARATOR DETECTION (Python: textComparators) ===
            aliasFields.forEach(fieldName => {
                if (alias[fieldName] && typeof alias[fieldName] === 'string') {
                    const fieldValue = alias[fieldName];
                    const fieldLower = fieldValue.toLowerCase();
                    
                    // Check string patterns by category
                    for (const [patternType, patterns] of Object.entries(TEXT_COMPARATOR_PATTERNS)) {
                        patterns.forEach(pattern => {
                            if (fieldLower.includes(pattern.toLowerCase())) {
                                concerns.push({
                                    type: "textComparators",
                                    field: fieldName,
                                    value: fieldValue,
                                    detectedPattern: pattern,
                                    patternType: patternType,
                                    issue: `${fieldName.charAt(0).toUpperCase() + fieldName.slice(1)} field contains text comparator '${pattern}'`
                                });
                            }
                        });
                    }
                    
                    // Check regex patterns (hyphenated version ranges)
                    const regexMatch = fieldValue.match(HYPHENATED_VERSION_RANGE_REGEX);
                    if (regexMatch) {
                        concerns.push({
                            type: "textComparators",
                            field: fieldName,
                            value: fieldValue,
                            detectedPattern: regexMatch[0],
                            patternType: "Hyphenated Version Range",
                            issue: `${fieldName.charAt(0).toUpperCase() + fieldName.slice(1)} field contains version range pattern '${regexMatch[0]}'`
                        });
                    }
                }
            });
            
            // === 4. INVALID CHARACTER DETECTION (Python: invalidCharacters) ===
            aliasFields.forEach(fieldName => {
                if (alias[fieldName] && typeof alias[fieldName] === 'string') {
                    const fieldValue = alias[fieldName];
                    
                    // Use allow-list approach like Python
                    if (!VALID_VERSION_PATTERN.test(fieldValue) && fieldValue !== '*') {
                        // Find specific invalid characters
                        const invalidChars = fieldValue.match(INVALID_CHARS_FINDER);
                        if (invalidChars) {
                            // Report each unique invalid character
                            [...new Set(invalidChars)].forEach(char => {
                                concerns.push({
                                    type: "invalidCharacters",
                                    field: fieldName,
                                    value: fieldValue,
                                    detectedPattern: char,
                                    issue: `${fieldName.charAt(0).toUpperCase() + fieldName.slice(1)} field contains invalid character '${char}'`
                                });
                            });
                        }
                    }
                }
            });
            
            // === 5. BLOAT TEXT DETECTION ===
            // Detects vendor text redundantly included in product and packageName fields
            if (alias.vendor && typeof alias.vendor === 'string' && alias.vendor.trim() !== '' && 
                !isPlaceholderValue(alias.vendor)) {
                
                const vendorLower = alias.vendor.toLowerCase().trim();
                
                // Check for vendor text in product field
                if (alias.product && typeof alias.product === 'string') {
                    const productLower = alias.product.toLowerCase().trim();
                    if (productLower.includes(vendorLower) && productLower !== vendorLower) {
                        concerns.push({
                            type: "bloatTextDetection",
                            field: "product",
                            value: alias.product,
                            detectedPattern: alias.vendor,
                            patternType: "vendor_redundancy",
                            issue: `Product field contains redundant vendor text '${alias.vendor}'`
                        });
                    }
                }
                
                // Check for vendor text in packageName field
                if (alias.packageName && typeof alias.packageName === 'string') {
                    const packageNameLower = alias.packageName.toLowerCase().trim();
                    if (packageNameLower.includes(vendorLower) && packageNameLower !== vendorLower) {
                        concerns.push({
                            type: "bloatTextDetection", 
                            field: "packageName",
                            value: alias.packageName,
                            detectedPattern: alias.vendor,
                            patternType: "vendor_redundancy",
                            issue: `PackageName field contains redundant vendor text '${alias.vendor}'`
                        });
                    }
                }
            }
            
            return concerns;
        }
        let propertyDistributionChart = null;

        // CPE normalization and validation functions
        function normalizeCpeString(cpeString) {
            if (!cpeString) return cpeString;
            
            // Split the CPE string into parts
            const parts = cpeString.split(':');
            
            // If it's not a proper CPE string, return as-is
            if (parts.length < 3 || !cpeString.startsWith('cpe:2.3:')) {
                return cpeString;
            }
            
            // Normalize each component (vendor, product, etc.)
            for (let i = 3; i < parts.length; i++) {
                if (parts[i] && parts[i] !== '*') {
                    // Convert to lowercase only
                    parts[i] = parts[i].toLowerCase();
                }
            }
            
            return parts.join(':');
        }

        function ensureCpeBaseString(cpeString) {
            if (!cpeString) return cpeString;
            
            // Split the CPE string into parts
            const parts = cpeString.split(':');
            
            // If it's not a proper CPE string, return as-is
            if (parts.length < 3 || !cpeString.startsWith('cpe:2.3:')) {
                return cpeString;
            }
            
            // CPE 2.3 format: cpe:2.3:part:vendor:product:version:update:edition:language:sw_edition:target_sw:target_hw:other
            // Indices:       0    1    2    3      4       5       6      7       8        9          10         11        12
            // Base strings must have version (5) and update (6) as wildcards
            if (parts.length >= 7) {
                parts[5] = '*';  // version
                parts[6] = '*';  // update
            }
            
            return parts.join(':');
        }

        function validateCpeString(cpeString) {
            if (!cpeString) return { valid: false, message: 'Empty CPE string' };
            
            const errors = [];
            
            // Check for corruption indicators first
            if (cpeString.includes('::')) {
                errors.push('Contains double colons (::) - indicates data corruption. Use :*: instead');
            }
            
            if (!cpeString.startsWith('cpe:2.3:')) {
                errors.push('Must start with cpe:2.3:');
            }
            
            const parts = cpeString.split(':');
            
            if (parts.length !== 13) {
                errors.push(`Expected 13 components, found ${parts.length}`);
            }
            
            // Check for empty components that should be wildcards
            const emptyComponentIndices = [];
            parts.forEach((part, index) => {
                if (part === '' && index >= 3) { // Skip cpe, 2.3, and part attribute
                    emptyComponentIndices.push(index);
                }
            });
            
            if (emptyComponentIndices.length > 0) {
                errors.push(`Empty components at positions ${emptyComponentIndices.join(', ')}. Use '*' wildcards instead`);
            }
            
            // Only check further validation if we have the right number of parts
            if (parts.length >= 3) {
                // Validate part attribute (must be 'a', 'o', or 'h')
                const part = parts[2];
                if (!['a', 'o', 'h'].includes(part)) {
                    errors.push(`Invalid part attribute '${part}'. Must be 'a' (application), 'o' (operating system), or 'h' (hardware)`);
                }
            }
            
            if (parts.length >= 5) {
                const vendor = parts[3];
                const product = parts[4];
                
                if ((!vendor || vendor === '*') && (!product || product === '*')) {
                    errors.push('Must specify at least vendor or product');
                }
            }
            
            // Check for unescaped spaces and special characters in all components
            for (let i = 3; i < parts.length; i++) {
                const component = parts[i];
                
                // Map component index to attribute name
                const attributeNames = [
                    'Vendor Attribute',      // index 3
                    'Product Attribute',     // index 4
                    'Version Attribute',     // index 5
                    'Update Attribute',      // index 6
                    'Edition Attribute',     // index 7
                    'Language Attribute',    // index 8
                    'SW_Edition Attribute', // index 9
                    'Target_SW Attribute',   // index 10
                    'Target_HW Attribute',   // index 11
                    'Other Attribute'        // index 12
                ];
                
                const attributeName = attributeNames[i - 3] || `Attribute ${i - 2}`;
                
                // Check for unescaped spaces
                if (component.includes(' ')) {
                    errors.push(`${attributeName} contains spaces. Spaces must be converted to underscores in CPE 2.3 format`);
                }
                
                // Check for unescaped special characters
                const requiredEscapes = {
                    '!': '\\!', '"': '\\"', '#': '\\#', '$': '\\$', '&': '\\&', 
                    "'": "\\'", '(': '\\(', ')': '\\)', '+': '\\+', '/': '\\/',
                    ';': '\\;', '<': '\\<', '=': '\\=', '>': '\\>', '?': '\\?',
                    '@': '\\@', '[': '\\[', ']': '\\]', '^': '\\^', '`': '\\`',
                    '{': '\\{', '|': '\\|', '}': '\\}', '~': '\\~', ',': '\\,'
                };
                
                for (const [char, escaped] of Object.entries(requiredEscapes)) {
                    if (component.includes(char) && !component.includes(escaped)) {
                        errors.push(`${attributeName} contains unescaped '${char}'. Must be escaped as '${escaped}'`);
                    }
                }
            }
            
            if (errors.length > 0) {
                return { valid: false, errors: errors };
            }
            
            return { valid: true, message: 'Valid CPE 2.3 Base String' };
        }

        function handleCpeInput(input) {
            let value = input.value;
            const validationDiv = document.getElementById('cpeValidationMessage');
            const previewDiv = document.getElementById('cpePreview');
            
            // Handle empty input
            if (!value) {
                validationDiv.innerHTML = '';
                previewDiv.innerHTML = 'Enter: a:vendor:product';
                input.style.borderColor = '#ccc';
                input.removeAttribute('data-final-cpe');
                updateConsolidatedOutput();
                return;
            }
            
            // Force "cpe:2.3:" prefix only when user is typing new content
            if (!value.startsWith('cpe:2.3:')) {
                // If user typed something that doesn't start with cpe: at all, prepend the full prefix
                if (!value.startsWith('cpe:')) {
                    value = 'cpe:2.3:' + value;
                    input.value = value;
                    // Set cursor position after the forced prefix
                    setTimeout(() => {
                        input.setSelectionRange(value.length, value.length);
                    }, 0);
                } 
                // If user typed cpe: but not the full cpe:2.3:, and it's not a partial deletion
                else if (value.startsWith('cpe:') && !value.startsWith('cpe:2.3:') && value.length > 4) {
                    value = 'cpe:2.3:' + value.substring(4);
                    input.value = value;
                    setTimeout(() => {
                        input.setSelectionRange(value.length, value.length);
                    }, 0);
                }
                // If user is backspacing through "cpe:" or partial "cpe:2.3:", don't force anything
                else if (value === 'cpe:' || value === 'cpe:2' || value === 'cpe:2.' || value === 'cpe:2.3') {
                    validationDiv.innerHTML = '';
                    previewDiv.innerHTML = 'Continue typing: cpe:2.3:a:vendor:product';
                    input.style.borderColor = '#ccc';
                    input.removeAttribute('data-final-cpe');
                    updateConsolidatedOutput();
                    return;
                }
            }
            
            // Show consistent example for exactly "cpe:2.3:"
            if (value === 'cpe:2.3:') {
                validationDiv.innerHTML = '';
                previewDiv.innerHTML = 'Continue with: a:vendor:product';
                input.style.borderColor = '#ccc';
                input.removeAttribute('data-final-cpe');
                updateConsolidatedOutput();
                return;
            }
            
            // Only validate during live typing, don't auto-fix
            // Auto-fix only happens on Enter key in handleCpeKeydown
            const validation = validateCpeString(value);
            
            if (validation.valid) {
                // Ensure version and update are wildcards for base string format
                const normalizedValue = ensureCpeBaseString(value);
                validationDiv.innerHTML = `<span class="status-success">‚úÖ Valid CPE 2.3 Base String</span>`;
                previewDiv.innerHTML = '';
                input.style.borderColor = '#4CAF50';
                input.setAttribute('data-final-cpe', normalizedValue);
            } else {
                // Display validation errors in fixed height container with consistent formatting
                if (validation.errors && validation.errors.length > 0) {
                    // Show only first error to maintain consistent height
                    const firstError = validation.errors[0];
                    const moreCount = validation.errors.length > 1 ? ` (+${validation.errors.length - 1} more)` : '';
                    validationDiv.innerHTML = `<span class="status-error">‚ùå ${firstError}${moreCount}</span>`;
                } else {
                    validationDiv.innerHTML = `<span class="status-error">‚ùå ${validation.message}</span>`;
                }
                previewDiv.innerHTML = 'Example: a:vendor:product';
                input.style.borderColor = '#dc3545';
                input.removeAttribute('data-final-cpe');
            }
            
            // Update the modal button state
            updateModalButtonState();
            
            updateConsolidatedOutput();
        }
        
        function updateModalButtonState() {
            const cpeInput = document.getElementById('cpeBaseString');
            const updateBtn = document.getElementById('outputModal')?.querySelector('.modal-btn-primary');
            
            if (!updateBtn || !cpeInput) return;
            
            const isValidCpe = cpeInput.hasAttribute('data-final-cpe') && cpeInput.getAttribute('data-final-cpe');
            const hasSelectedAliases = selectedAliases && selectedAliases.size > 0;
            
            if (isValidCpe && hasSelectedAliases) {
                updateBtn.disabled = false;
                updateBtn.style.opacity = '1';
                updateBtn.style.cursor = 'pointer';
                updateBtn.title = '';
            } else {
                updateBtn.disabled = true;
                updateBtn.style.opacity = '0.5';
                updateBtn.style.cursor = 'not-allowed';
                
                if (!isValidCpe && !hasSelectedAliases) {
                    updateBtn.title = 'Please enter a valid CPE base string and select aliases';
                } else if (!isValidCpe) {
                    updateBtn.title = 'Please enter a valid CPE base string';
                } else if (!hasSelectedAliases) {
                    updateBtn.title = 'Please select aliases to map';
                }
            }
        }

        function handleCpeKeydown(event) {
            if (event.key === 'Enter') {
                const input = event.target;
                let value = input.value;
                
                // AUTO-FIX ONLY ON ENTER: Sanitize any existing corruption
                value = sanitizeCPE(value);
                
                // AUTO-FIX ONLY ON ENTER: Auto-complete with :*:*:*:*:*:*:*:* if not already complete
                if (value.startsWith('cpe:2.3:') && value.split(':').length < 13) {
                    const parts = value.split(':');
                    while (parts.length < 13) {
                        parts.push('*');
                    }
                    value = parts.join(':');
                }
                
                // Ensure CPE base string format: version and update must be wildcards
                value = ensureCpeBaseString(value);
                
                // Update input with sanitized and completed value
                input.value = value;
                handleCpeInput(input);
                
                event.preventDefault();
            }
        }

        // Initialize filter functionality
        function initializeFilter() {
            const filterInput = document.getElementById('filterInput');
            const filterContainer = document.getElementById('aliasFilter');

            if (allSortedAliases && allSortedAliases.length > 0) {
                filterContainer.style.display = 'flex';
            }

            // Search on Enter
            filterInput.onkeypress = function(e) {
                if (e.key === 'Enter') {
                    performSearch(this.value.toLowerCase());
                }
            };

            // Search on click
            searchButton.onclick = function() {
                performSearch(filterInput.value.toLowerCase());
            };

            // Clear on click
            clearButton.onclick = function() {
                filterInput.value = '';
                performSearch('');
            };
        }

        /**
         * Clear and reset the search filter to its initial state
         */
        function clearSearchFilter() {
            const filterInput = document.getElementById('filterInput');
            
            if (filterInput) {
                filterInput.value = '';
                console.debug('üîç Search filter input cleared');
            }
        }

        function performSearch(filterText) {
            // Show loading
            const originalSearchText = searchButton.textContent;
            const originalClearText = clearButton.textContent;
            searchButton.textContent = '‚è≥ Searching...';
            clearButton.textContent = '‚è≥ Clearing...';
            searchButton.disabled = true;
            clearButton.disabled = true;

            // Use setTimeout to allow UI update
            setTimeout(() => {
                // Use DataManager query functions instead of deprecated filterAliases
                if (!filterText.trim()) {
                    // No filter - show all data
                    updateDatasetDisplay(['confirmedMapping', 'unconfirmedAliases', 'sourceDataConcernAliases']);
                } else {
                    // Apply filter using query functions
                    const searchTerm = filterText.trim().toLowerCase();
                    
                    // Use query function to get all aliases then filter
                    const allAliases = DataQueries.getAllAliases();
                    const filteredAliases = allAliases.filter(alias => 
                        alias._searchText && alias._searchText.includes(searchTerm)
                    );
                    
                    // Sort filtered aliases
                    const sortedAliases = filteredAliases.sort((a, b) => {
                        const scoreA = a.frequency || a.cveCount || a.source_cve?.length || 0;
                        const scoreB = b.frequency || b.cveCount || b.source_cve?.length || 0;
                        if (scoreB !== scoreA) return scoreB - scoreA;
                        
                        const productA = (a.product || '').toLowerCase();
                        const productB = (b.product || '').toLowerCase();
                        return productA.localeCompare(productB);
                    });
                    
                    // Separate filtered results by dataset type using property-based identification
                    const filteredConfirmed = sortedAliases.filter(alias => 
                        alias.isConfirmedMapping === true
                    );
                    const filteredUnconfirmed = sortedAliases.filter(alias => 
                        alias.isConfirmedMapping !== true && !alias.hasSourceDataConcerns
                    );
                    const filteredConcern = sortedAliases.filter(alias => 
                        alias.hasSourceDataConcerns === true
                    );
                    
                    console.debug('üîç Search filter results:', {
                        searchTerm: searchTerm,
                        totalFiltered: sortedAliases.length,
                        confirmed: filteredConfirmed.length,
                        unconfirmed: filteredUnconfirmed.length,
                        concern: filteredConcern.length
                    });
                    
                    // Display filtered results
                    const mainAliasData = [...filteredConfirmed, ...filteredUnconfirmed];
                    const concernAliasData = filteredConcern;
                    
                    // Sort data
                    const sortAliases = (aliases) => aliases.sort((a, b) => {
                        const scoreA = a.frequency || a.cveCount || a.source_cve?.length || 0;
                        const scoreB = b.frequency || b.cveCount || b.source_cve?.length || 0;
                        if (scoreB !== scoreA) return scoreB - scoreA;
                        
                        const productA = (a.product || '').toLowerCase();
                        const productB = (b.product || '').toLowerCase();
                        return productA.localeCompare(productB);
                    });
                    
                    const sortedMainData = sortAliases(mainAliasData);
                    const sortedConcernData = sortAliases(concernAliasData);
                    
                    // Display filtered data
                    if (sortedMainData.length > 0) {
                        displayAliasesByFrequency(sortedMainData);
                    } else {
                        document.getElementById('aliasGroups').innerHTML = '<div class="white-card"><p>No results found for your search.</p></div>';
                    }
                    
                    if (sortedConcernData.length > 0) {
                        displaySourceDataConcerns(sortedConcernData);
                    } else {
                        document.getElementById('sourceDataConcernGroups').innerHTML = '';
                    }
                }
                
                // Reset search UI
                
                // Restore buttons
                searchButton.textContent = originalSearchText;
                clearButton.textContent = originalClearText;
                searchButton.disabled = false;
                clearButton.disabled = false;
            }, 10);
        }

        // CPE formatting functions (from processData.py)
        function normalizeToASCII(text) {
            if (!text) return '';
            
            // Convert to string if not already
            if (typeof text !== 'string') {
                text = String(text);
            }
            
            // Basic Unicode normalization
            text = text.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            
            // Handle specific Unicode characters
            const replacements = {
                '√∏': 'o', '√ò': 'O',
                '√¶': 'ae', '√Ü': 'AE',
                '√ü': 'ss',
                '≈Ç': 'l', '≈Å': 'L',
                '¬©': 'c',
                '¬Æ': 'r',
                '‚Ñ¢': 'tm',
                '‚Ç¨': 'euro',
                '¬£': 'pound',
                '¬•': 'yen'
            };
            
            for (const [unicode, ascii] of Object.entries(replacements)) {
                text = text.replace(new RegExp(unicode, 'g'), ascii);
            }
            
            // Remove remaining non-ASCII characters
            text = text.replace(/[^\x00-\x7F]/g, '');
            
            return text;
        }

        function formatFor23CPE(rawAttribute) {
            if (!rawAttribute || rawAttribute.trim() === '') return '*';
            
            // Normalize to ASCII first
            let attribute = normalizeToASCII(rawAttribute);
            
            // If normalization resulted in empty string, return wildcard
            if (!attribute || attribute.trim() === '') return '*';
            
            // CPE escaping rules
            const cpeEscape = {
                " ": "_",
                "\\": "\\\\",
                "!": "\\!",
                "\"": "\\\"",
                "#": "\\#",
                "$": "\\$",
                "&": "\\&",
                "'": "\\'",
                "(": "\\(",
                ")": "\\)",
                "+": "\\+",
                "/": "\\/",
                ":": "\\:",
                ";": "\\;",
                "<": "\\<",
                "=": "\\=",
                ">": "\\>",
                "?": "\\?",
                "@": "\\@",
                "[": "\\[",
                "]": "\\]",
                "^": "\\^",
                "`": "\\`",
                "{": "\\{",
                "|": "\\|",
                "}": "\\}",
                "~": "\\~",
                ",": "\\,"
            };
            
            attribute = attribute.toLowerCase();
            
            let result = '';
            for (const char of attribute) {
                result += cpeEscape[char] || char;
            }
            
            // Ensure we never return empty string - use wildcard instead
            return result.trim() || '*';
        }

        /**
         * Sanitize CPE string by fixing common corruption patterns
         * @param {string} cpeString - The CPE string to sanitize
         * @returns {string} - Sanitized CPE string
         */
        function sanitizeCPE(cpeString) {
            if (!cpeString) return cpeString;
            
            // Fix double colons (::) by replacing with :*:
            let sanitized = cpeString.replace(/::/g, ':*:');
            
            // Fix triple or more colons by replacing with :*:
            sanitized = sanitized.replace(/:{3,}/g, ':*:');
            
            // Ensure we have exactly 13 components
            const parts = sanitized.split(':');
            if (parts.length < 13) {
                // Pad with wildcards if too short
                while (parts.length < 13) {
                    parts.push('*');
                }
                sanitized = parts.join(':');
            } else if (parts.length > 13) {
                // Trim to 13 components if too long
                sanitized = parts.slice(0, 13).join(':');
            }
            
            // Replace any empty components with wildcards
            const finalParts = sanitized.split(':').map(part => part === '' ? '*' : part);
            
            return finalParts.join(':');
        }

        /**
         * Validate and automatically fix CPE string corruption
         * @param {string} cpeString - The CPE string to validate and fix
         * @returns {object} - Object with fixed CPE string and validation result
         */
        function validateAndFixCPE(cpeString) {
            // First sanitize to fix obvious corruption
            const sanitized = sanitizeCPE(cpeString);
            
            // Then validate the sanitized version
            const validation = validateCpeString(sanitized);
            
            return {
                original: cpeString,
                fixed: sanitized,
                validation: validation,
                wasCorrupted: cpeString !== sanitized
            };
        }

        function generateSuggestedCPE(alias) {
            const vendor = isPlaceholderValue(alias.vendor) ? '*' : formatFor23CPE(alias.vendor);
            const product = isPlaceholderValue(alias.product) ? '*' : formatFor23CPE(alias.product);
            
            // Handle platform mapping for target_hw
            let targetHw = '*';
            if (alias.platform && !isPlaceholderValue(alias.platform)) {
                const platform = alias.platform.toLowerCase();
                if (platform.includes('x64') || platform.includes('64-bit')) {
                    targetHw = 'x64';
                } else if (platform.includes('32-bit') || platform.includes('x86')) {
                    targetHw = 'x86';
                } else if (platform.includes('arm')) {
                    targetHw = 'arm';
                } else {
                    // Keep platform as-is for complex platform strings
                    targetHw = formatFor23CPE(alias.platform);
                }
            }
            
            return `cpe:2.3:a:${vendor}:${product}:*:*:*:*:*:*:${targetHw}:*`;
        }

        function generateAliasMapping(alias) {
            // Create a clean mapping object excluding calculated fields
            const mapping = {};
            
            // Core required fields
            if (alias.vendor && !isPlaceholderValue(alias.vendor)) mapping.vendor = alias.vendor;
            if (alias.product && !isPlaceholderValue(alias.product)) mapping.product = alias.product;
            
            // Optional fields - only include if they have meaningful values
            const optionalFields = ['platforms', 'packageName', 'repo', 'collectionURL', 
                                  'container_type', 'programRoutines', 'programFiles', 'modules', 'defaultStatus'];
            
            optionalFields.forEach(field => {
                if (alias[field] && !isPlaceholderValue(alias[field])) {
                    mapping[field] = alias[field];
                }
            });
            
            return mapping;
        }

        function downloadConfirmedMappingsJSON(cpeGroups) {
            try {
                // Generate the confirmed mappings JSON structure
                const confirmedMappings = [];
                
                Object.entries(cpeGroups).forEach(([cpeBaseString, aliases]) => {
                    // Create aliases array with only the essential fields
                    const cleanAliases = aliases.map(alias => {
                        const cleanAlias = {};
                        
                        // Add vendor and product (required fields)
                        if (alias.vendor) cleanAlias.vendor = alias.vendor;
                        if (alias.product) cleanAlias.product = alias.product;
                        
                        // Add optional fields if they exist and aren't placeholder values
                        const optionalFields = ['version', 'update', 'edition', 'language'];
                        optionalFields.forEach(field => {
                            if (alias[field] && !isPlaceholderValue(alias[field])) {
                                cleanAlias[field] = alias[field];
                            }
                        });
                        
                        // Handle platform field - standardized on "platform" property
                        if (alias.platform && !isPlaceholderValue(alias.platform)) {
                            cleanAlias.platform = alias.platform;
                        }
                        
                        return cleanAlias;
                    });
                    
                    // Create the confirmed mapping entry
                    const confirmedMapping = {
                        cpeBaseString: cpeBaseString,
                        aliases: cleanAliases
                    };
                    
                    confirmedMappings.push(confirmedMapping);
                });
                
                // Extract the source_id from DataManager's raw data - use source_id or source_name as fallback
                if (!DataManager.rawData || !DataManager.rawData.metadata) {
                    throw new Error('Cannot download: No metadata found in loaded data');
                }
                
                // Use source_id (preferred) or source_name as the identifier
                const sourceId = DataManager.rawData.metadata.source_id || DataManager.rawData.metadata.source_name;
                if (!sourceId) {
                    throw new Error('Cannot download: No source_id or source_name found in metadata');
                }
                
                // Create the full JSON structure
                const jsonData = {
                    cnaId: sourceId,
                    confirmedMappings: confirmedMappings
                };
                
                // Create and download the file
                const jsonString = JSON.stringify(jsonData, null, 4);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `confirmed_mappings_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show success message
                const downloadBtn = event.target.closest('.download-btn');
                if (downloadBtn) {
                    const originalHTML = downloadBtn.innerHTML;
                    downloadBtn.innerHTML = '<i class="fas fa-check" style="font-size: 0.8em;"></i><span>Downloaded!</span>';
                    downloadBtn.style.background = 'rgba(76, 175, 80, 0.3)';
                    
                    setTimeout(() => {
                        downloadBtn.innerHTML = originalHTML;
                        downloadBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                    }, 2000);
                }
            } catch (error) {
                // Show error message to user
                const downloadBtn = event.target.closest('.download-btn');
                if (downloadBtn) {
                    const originalHTML = downloadBtn.innerHTML;
                    downloadBtn.innerHTML = '<i class="fas fa-exclamation-triangle" style="font-size: 0.8em;"></i><span>Error!</span>';
                    downloadBtn.style.background = 'rgba(244, 67, 54, 0.3)';
                    
                    setTimeout(() => {
                        downloadBtn.innerHTML = originalHTML;
                        downloadBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                    }, 3000);
                }
                
                // Log the error for debugging
                console.error('Download failed:', error.message);
                alert('Download failed: ' + error.message);
            }
        }

        function groupCvesByYear(cveList) {
            const groups = {};
            
            // Handle null/undefined or non-array inputs
            if (!cveList || !Array.isArray(cveList) || cveList.length === 0) {
                return [];
            }
            
            cveList.forEach(cve => {
                // Extract year from CVE-YYYY-NNNNN format
                const yearMatch = cve.match(/CVE-(\d{4})-/);
                const year = yearMatch ? yearMatch[1] : 'Unknown';
                
                if (!groups[year]) {
                    groups[year] = [];
                }
                groups[year].push(cve);
            });
            
            // Sort years in descending order (most recent first)
            const sortedYears = Object.keys(groups).sort((a, b) => {
                if (a === 'Unknown') return 1;
                if (b === 'Unknown') return -1;
                return parseInt(b) - parseInt(a);
            });
            
            return sortedYears.map(year => ({
                year: year,
                cves: groups[year].sort(), // Sort CVEs within each year
                count: groups[year].length
            }));
        }

        function generateCveGroupsHtml(cveGroups) {
            // Handle empty or invalid input
            if (!cveGroups || !Array.isArray(cveGroups) || cveGroups.length === 0) {
                return '<div class="no-cves">No CVE data available</div>';
            }
            
            return cveGroups.map(group => {
                // Subtle color coding using dashboard's existing palette
                const yearColor = group.year === 'Unknown' ? '#BDBDBD' : 
                                 parseInt(group.year) >= 2024 ? '#4CAF50' :  // Main green for recent
                                 parseInt(group.year) >= 2020 ? '#66BB6A' :  // Light green for 2020-2023
                                 '#E0E0E0';  // Light gray for older
                
                const yearLabel = group.year === 'Unknown' ? 'Unknown Year' : group.year;
                const textColor = yearColor === '#E0E0E0' ? '#666' : 'white';
                
                return `
                    <div class="cve-year-group">
                        <div class="cve-year-header" style="background: ${yearColor}; color: ${textColor};" 
                             onclick="toggleCveYear(this)"
                             onmouseover="this.style.opacity='0.8'"
                             onmouseout="this.style.opacity='1'">
                            <span>${yearLabel} ‚Ä¢ ${group.count} CVE${group.count > 1 ? 's' : ''}</span>
                            <span class="cve-year-toggle">‚ñº</span>
                        </div>
                        <div class="cve-year-content">
                            <div class="cve-list">
                                ${group.cves.map(cve => `<a href="https://nvd.nist.gov/vuln/detail/${cve}#vulnConfigurationsArea" target="_blank" class="cve-link" title="View ${cve} on NVD">${cve}</a>`).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Documentation toggle functionality
        function toggleDocumentation() {
            const fileSelector = document.querySelector('.file-selector');
            const content = document.getElementById('documentation-content');
            const chevron = document.getElementById('doc-chevron');
            
            const isExpanded = content.classList.contains('expanded');
            
            if (isExpanded) {
                content.classList.remove('expanded');
                fileSelector.classList.remove('expanded');
                chevron.textContent = '‚ñº';
                chevron.style.transform = 'rotate(0deg)';
            } else {
                content.classList.add('expanded');
                fileSelector.classList.add('expanded');
                chevron.textContent = '‚ñ≤';
                chevron.style.transform = 'rotate(180deg)';
            }
        }

        // Analysis toggle functionality
        function toggleAnalysis() {
            const content = document.getElementById('analysis-content');
            const chevron = document.getElementById('analysis-chevron');
            
            const isExpanded = content.classList.contains('expanded');
            
            if (isExpanded) {
                content.classList.remove('expanded');
                chevron.textContent = '‚ñº';
                chevron.style.transform = 'rotate(0deg)';
            } else {
                content.classList.add('expanded');
                chevron.textContent = '‚ñ≤';
                chevron.style.transform = 'rotate(180deg)';
            }
        }

        // Check for pre-injected data and auto-load
        function checkForInjectedData() {
            if (typeof currentData !== 'undefined' && currentData !== null && typeof currentData === 'object' && currentData.aliasGroups) {
                console.log('‚úì Injected data detected, loading dashboard automatically...');
                
                // Update status bar with injected data metadata
                const statusBar = document.getElementById('status-bar');
                const statusFilename = document.getElementById('status-filename');
                const generationTimeEl = document.getElementById('generation-time');
                const fileSizeEl = document.getElementById('file-size');
                const loadTimeEl = document.getElementById('load-time');
                
                if (statusBar) {
                    // Display source name for quick scope identification
                    const sourceName = currentData.metadata?.source_name || 'Unknown Source';
                    statusFilename.textContent = sourceName;
                    
                    let generationTime = 'Unknown';
                    if (currentData.metadata && currentData.metadata.extraction_timestamp) {
                        const genDate = new Date(currentData.metadata.extraction_timestamp);
                        generationTime = genDate.toLocaleString();
                    } else if (currentData.metadata && currentData.metadata.run_started_at) {
                        const genDate = new Date(currentData.metadata.run_started_at);
                        generationTime = genDate.toLocaleString();
                    }
                    generationTimeEl.textContent = generationTime;
                    
                    // Calculate approximate data size
                    const dataSize = (JSON.stringify(currentData).length / 1024).toFixed(1);
                    fileSizeEl.textContent = `~${dataSize} KB`;
                    
                    const now = new Date();
                    loadTimeEl.textContent = now.toLocaleTimeString();
                    
                    statusBar.style.display = 'block';
                }
                
                // Load data into DataManager
                showProcessingOverlay('Loading Pre-Injected Data...');
                
                setTimeout(() => {
                    try {
                        updateProcessingProgress(25, 'Parsing injected data...');
                        
                        if (!currentData.aliasGroups) {
                            throw new Error('Invalid data format: missing aliasGroups');
                        }
                        
                        updateProcessingProgress(50, 'Loading data into DataManager...');
                        
                        const loadResult = DataManager.loadData(currentData);
                        if (!loadResult.success) {
                            throw new Error(`DataManager load failed: ${loadResult.error}`);
                        }
                        
                        updateProcessingProgress(75, 'Updating statistics and display...');
                        
                        // Update stats using DataManager data
                        updateStatsFromDataManager();
                        
                        // Display using new system
                        const displayResult = updateDatasetDisplay(['confirmedMapping', 'unconfirmedAliases', 'sourceDataConcernAliases']);
                        if (!displayResult.success) {
                            console.warn(`Display update failed: ${displayResult.error}`);
                        }
                        
                        updateProcessingProgress(90, 'Initializing charts and interface...');
                        
                        // Initialize charts and UI using query functions
                        initializeChartsAndUI();
                        
                        updateProcessingProgress(100, 'Complete!');
                        
                        setTimeout(() => {
                            hideProcessingOverlay();
                        }, 500);
                        
                        console.log('Dashboard successfully loaded with pre-injected data');
                        return true;
                        
                    } catch (error) {
                        console.error('Error loading injected data:', error);
                        hideProcessingOverlay();
                        showError(`Failed to load data: ${error.message}`);
                        return false;
                    }
                }, 100);
                
                return true;
            }
            return false;
        }

        // File input handling
        document.addEventListener('DOMContentLoaded', function() {
            initializeCachedElements();
            
            // Check if data was injected - if so, auto-load it
            if (checkForInjectedData()) {
                console.log('Dashboard initialized with injected data');
                return; // Skip file input setup since data is already loaded
            }
            
            const fileSelectBtn = document.getElementById('file-select-btn');
            const statusBar = document.getElementById('status-bar');
            const statusFilename = document.getElementById('status-filename');
            const fileSize = document.getElementById('file-size');
            const generationTime = document.getElementById('generation-time');
            const loadTime = document.getElementById('load-time');

            // Handle file select button click
            fileSelectBtn.addEventListener('click', function() {
                fileInput.click();
            });

            // Handle file selection
            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    // Show status bar
                    statusBar.style.display = 'block';
                    statusFilename.textContent = file.name;
                    fileSize.textContent = (file.size / 1024).toFixed(1) + ' KB';
                    
                    // Extract generation time from filename if possible
                    const timeMatch = file.name.match(/(\d{8}_\d{6})/);
                    if (timeMatch) {
                        const timeStr = timeMatch[1];
                        const year = timeStr.substring(0, 4);
                        const month = timeStr.substring(4, 6);
                        const day = timeStr.substring(6, 8);
                        const hour = timeStr.substring(9, 11);
                        const minute = timeStr.substring(11, 13);
                        const second = timeStr.substring(13, 15);
                        generationTime.textContent = `${year}-${month}-${day} ${hour}:${minute}:${second}`;
                    } else {
                        generationTime.textContent = 'Unknown';
                    }
                    
                    // Load the file
                    loadFile();
                }
            });
        });

        function loadFile() {
            const file = fileInput.files[0];
            
            if (!file) {
                showError('Please select a file first');
                return;
            }

            // Clear any existing search filter state
            clearSearchFilter();

            // Show processing overlay for file loading
            showProcessingOverlay(
                'Loading Data File...'
            );

            const startTime = Date.now();
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    updateProcessingProgress(25, 'Parsing JSON data...');
                    
                    const jsonData = JSON.parse(e.target.result);
                    if (!jsonData.aliasGroups) {
                        throw new Error('Invalid file format: missing aliasGroups');
                    }
                    
                    updateProcessingProgress(50, 'Loading data into DataManager...');
                    
                    // Load data into DataManager (NEW SYSTEM)
                    const loadResult = DataManager.loadData(jsonData);
                    if (!loadResult.success) {
                        throw new Error(`DataManager load failed: ${loadResult.error}`);
                    }
                    
                    updateProcessingProgress(75, 'Updating statistics and display...');
                    
                    // Store for legacy compatibility and download function
                    currentData = jsonData;
                    window.currentData = jsonData;
                    
                    hideError();
                    
                    // Update stats using DataManager data
                    updateStatsFromDataManager();
                    
                    // Display using new system
                    const displayResult = updateDatasetDisplay(['confirmedMapping', 'unconfirmedAliases', 'sourceDataConcernAliases']);
                    if (!displayResult.success) {
                        console.warn(`Display update failed: ${displayResult.error}`);
                    }
                    
                    updateProcessingProgress(90, 'Initializing charts and interface...');
                    
                    // Initialize charts and UI using query functions
                    initializeChartsAndUI();
                    
                    updateProcessingProgress(100, 'Complete!');
                    
                    // Update load time
                    const loadTimeMs = Date.now() - startTime;
                    const loadTimeEl = document.getElementById('load-time');
                    if (loadTimeEl) {
                        loadTimeEl.textContent = loadTimeMs + 'ms ago';
                    }
                    
                    // Hide overlay after short delay
                    setTimeout(() => {
                        hideProcessingOverlay();
                    }, 800);
                    
                } catch (error) {
                    hideProcessingOverlay();
                    showError('Error loading file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // ========== DATAMANAGER STATS INTEGRATION ==========
        
        /**
         * Query functions to gather data from the three distinct datasets
         */
        const DataQueries = {
            // Get all aliases from all three datasets (properly handling nested confirmed mappings)
            getAllAliases: function() {
                const confirmed = DataManager.getDataset('confirmedMapping');
                const unconfirmed = DataManager.getDataset('unconfirmedAliases');
                const concern = DataManager.getDataset('sourceDataConcernAliases');
                
                console.debug(`[getAllAliases] Confirmed: ${confirmed.length}, Unconfirmed: ${unconfirmed.length}, Concern: ${concern.length}`);
                
                // Flatten confirmed mappings to handle nested structure
                const flattenedConfirmed = [];
                confirmed.forEach(mapping => {
                    if (mapping.aliases && Array.isArray(mapping.aliases)) {
                        flattenedConfirmed.push(...mapping.aliases);
                    } else {
                        flattenedConfirmed.push(mapping);
                    }
                });
                
                return [...flattenedConfirmed, ...unconfirmed, ...concern];
            },
            
            // Get total unique alias count across all datasets (deduplicating by alias key)
            getTotalAliasCount: function() {
                const allAliases = this.getAllAliases();
                
                // Create a set of unique alias keys to handle potential duplicates across datasets
                const uniqueAliasKeys = new Set();
                
                // Helper function to create a comparable key for an alias (same as in coverage calculation)
                const isPlaceholderValue = (value) => {
                    return !value || value === '' || value === 'n/a' || value === 'N/A' || 
                           value === null || value === undefined;
                };
                
                const createAliasKey = (alias) => {
                    const keyParts = [];
                    cve5Properties.forEach(prop => {
                        if (alias[prop] && !isPlaceholderValue(alias[prop])) {
                            keyParts.push(`${prop}:${alias[prop]}`);
                        }
                    });
                    return keyParts.sort().join('|');
                };
                
                // Count unique aliases across all datasets
                allAliases.forEach(alias => {
                    const aliasKey = createAliasKey(alias);
                    if (aliasKey) { // Only count aliases with meaningful data
                        uniqueAliasKeys.add(aliasKey);
                    }
                });
                
                console.debug('üîç Total unique aliases calculation:', {
                    totalAliasesFromDatasets: allAliases.length,
                    uniqueAliasKeys: uniqueAliasKeys.size,
                    deduplicationReduction: allAliases.length - uniqueAliasKeys.size
                });
                
                return uniqueAliasKeys.size;
            },
            
            // Calculate confirmed mapping coverage percentage (intersection-based calculation)
            getConfirmedCoveragePercent: function() {
                console.debug(`[getConfirmedCoveragePercent] Starting coverage calculation...`);
                const confirmed = DataManager.getDataset('confirmedMapping');
                console.debug(`[getConfirmedCoveragePercent] Retrieved ${confirmed.length} confirmed aliases`);
                
                // Get all source aliases for analysis
                const allSourceAliases = this.getAllAliases();
                console.debug(`[getConfirmedCoveragePercent] Retrieved ${allSourceAliases.length} total source aliases`);
                
                // Local helper functions for consistent behavior
                const isPlaceholderValue = (value) => {
                    return !value || value === '' || value === 'n/a' || value === 'N/A' || 
                           value === null || value === undefined;
                };
                
                // Helper function to create a comparable key for an alias
                const createAliasKey = (alias) => {
                    const keyParts = [];
                    cve5Properties.forEach(prop => {
                        if (alias[prop] && !isPlaceholderValue(alias[prop])) {
                            keyParts.push(`${prop}:${alias[prop]}`);
                        }
                    });
                    return keyParts.sort().join('|');
                };
                
                // Get all unique aliases for total count
                const uniqueSourceAliases = new Set();
                allSourceAliases.forEach(alias => {
                    const aliasKey = createAliasKey(alias);
                    if (aliasKey) {
                        uniqueSourceAliases.add(aliasKey);
                    }
                });
                const totalCount = uniqueSourceAliases.size;
                
                // Get all aliases covered by confirmed mappings
                const coveredAliases = new Set();
                const confirmedAliasKeys = []; // Collect keys for debugging
                confirmed.forEach((alias, index) => {
                    // confirmed is already flattened - each item is an alias, not a mapping with nested aliases
                    const aliasKey = createAliasKey(alias);
                    if (aliasKey) { // Only add non-empty keys
                        coveredAliases.add(aliasKey);
                        confirmedAliasKeys.push(aliasKey);
                    }
                    // Debug first few aliases to understand structure
                    if (index < 2) {
                        console.debug(`üîç Sample confirmed alias ${index}:`, alias, `-> key: "${aliasKey}"`);
                        console.debug(`üîç Confirmed alias properties:`, Object.keys(alias));
                        console.debug(`üîç Vendor: "${alias.vendor}", Product: "${alias.product}", Platform: "${alias.platform}"`);
                    }
                });
                
                // Count how many unique source aliases are covered by confirmed mappings
                const coveredCount = coveredAliases.size;
                
                console.debug('üîç Coverage calculation:', {
                    totalUniqueAliases: totalCount,
                    confirmedMappingEntries: confirmed.length,
                    uniqueCoveredAliases: coveredCount,
                    percentage: totalCount > 0 ? ((coveredCount / totalCount) * 100).toFixed(2) : '0',
                    percentageForDisplay: totalCount > 0 ? ((coveredCount / totalCount) * 100).toFixed(1) : '0',
                    exactPercentage: totalCount > 0 ? (coveredCount / totalCount) * 100 : 0,
                    calculationTime: new Date().toISOString(),
                    sampleCoveredKeys: Array.from(coveredAliases).slice(0, 3),
                    sampleConfirmedKeys: confirmedAliasKeys.slice(0, 3),
                    supportedProperties: cve5Properties
                });
                
                return totalCount > 0 ? 
                    ((coveredCount / totalCount) * 100).toFixed(1) + '%' : '0%';
            },
            
            // Get dataset counts for dashboard display (intersection-based confirmed count)
            getDatasetCounts: function() {
                const confirmed = DataManager.getDataset('confirmedMapping');
                const allSourceAliases = this.getAllAliases();
                
                // Use consistent property list
                const isPlaceholderValue = (value) => {
                    return !value || value === '' || value === 'n/a' || value === 'N/A' || 
                           value === null || value === undefined;
                };
                
                // Helper function to create a comparable key for an alias
                const createAliasKey = (alias) => {
                    const keyParts = [];
                    cve5Properties.forEach(prop => {
                        if (alias[prop] && !isPlaceholderValue(alias[prop])) {
                            keyParts.push(`${prop}:${alias[prop]}`);
                        }
                    });
                    return keyParts.sort().join('|');
                };
                
                // Get all aliases covered by confirmed mappings
                const coveredAliases = new Set();
                confirmed.forEach(mapping => {
                    if (mapping.aliases && Array.isArray(mapping.aliases)) {
                        mapping.aliases.forEach(alias => {
                            const aliasKey = createAliasKey(alias);
                            if (aliasKey) { // Only add non-empty keys
                                coveredAliases.add(aliasKey);
                            }
                        });
                    }
                });
                
                // Count how many source aliases are covered
                let coveredCount = 0;
                allSourceAliases.forEach(sourceAlias => {
                    const sourceKey = createAliasKey(sourceAlias);
                    if (sourceKey && coveredAliases.has(sourceKey)) {
                        coveredCount++;
                    }
                });
                
                return {
                    confirmed: coveredCount,
                    unconfirmed: DataManager.getDataset('unconfirmedAliases').length,
                    concerning: DataManager.getDataset('sourceDataConcernAliases').length
                };
            },
            
            // Get unique product count across all datasets using Set-based deduplication
            getUniqueProductCount: function() {
                const allAliases = this.getAllAliases();
                const uniqueProducts = new Set();
                
                allAliases.forEach(alias => {
                    if (alias.vendor && alias.product) {
                        const productKey = `${alias.vendor}:${alias.product}`;
                        uniqueProducts.add(productKey);
                    } else if (alias.product) {
                        uniqueProducts.add(alias.product);
                    }
                });
                
                return uniqueProducts.size;
            },
            
            // Get top aliases by CVE count for analytics
            getTopAliasesByCVE: function(limit = 10) {
                const allAliases = this.getAllAliases();
                
                // Sort by CVE count (frequency or source_cve length) in descending order
                const sortedAliases = allAliases.sort((a, b) => {
                    const scoreA = a.frequency || a.source_cve?.length || 0;
                    const scoreB = b.frequency || b.source_cve?.length || 0;
                    return scoreB - scoreA;
                });
                
                return sortedAliases.slice(0, limit);
            }
        };
        
        /**
         * Update the coverage tooltip with detailed calculation information
         */
        function updateCoverageTooltip(datasetCounts, totalAliases, coveragePercentage) {
            try {
                const tooltipCalculationElement = document.getElementById('tooltipCalculation');
                const tooltipBreakdownElement = document.getElementById('tooltipCoverageBreakdown');
                if (!tooltipCalculationElement || !tooltipBreakdownElement) {
                    console.warn('üîç Coverage tooltip elements not found');
                    return;
                }
                
                // Use the passed values directly - no recalculation
                const confirmedCount = DataManager.getDataset('confirmedMapping').length;
                const unconfirmedCount = DataManager.getDataset('unconfirmedAliases').length;
                const concernCount = DataManager.getDataset('sourceDataConcernAliases').length;
                
                // Extract numeric value from percentage string if needed
                const numericPercentage = typeof coveragePercentage === 'string' ? 
                    parseFloat(coveragePercentage.replace('%', '')) : coveragePercentage;
                
                // Calculate matched count from percentage
                const matchedCount = Math.round((numericPercentage / 100) * totalAliases);
                
                // Update calculation section
                const calculationText = `${matchedCount} √∑ ${totalAliases} = ${coveragePercentage}`;
                tooltipCalculationElement.innerHTML = calculationText;
                
                // Update breakdown section with intersection analysis
                const breakdownText = `‚Ä¢ Total source aliases = ${totalAliases}<br>‚Ä¢ Confirmed aliases: ${matchedCount}<br>‚Ä¢ Unconfirmed aliases: ${totalAliases - matchedCount}<br>‚Ä¢ Source concern aliases: ${DataManager.getDataset('sourceDataConcernAliases').length}<br>‚Ä¢ Total source aliases: ${totalAliases}<br><br><strong>Intersection Analysis:</strong><br>‚Ä¢ Unique confirmed patterns: ${matchedCount}<br>‚Ä¢ Source aliases matched: ${matchedCount} out of ${totalAliases}<br>‚Ä¢ Coverage efficiency: ${numericPercentage.toFixed(1)}% of aliases have confirmed mappings<br>‚Ä¢ Breakdown: ${matchedCount} matched aliases out of ${totalAliases} total aliases`;
                tooltipBreakdownElement.innerHTML = breakdownText;
                
                console.debug('üîç Updated coverage tooltip with calculation details');
                
            } catch (error) {
                console.error('üîç Coverage tooltip update failed:', error.message);
            }
        }
        
        /**
         * Update the alias breakdown tooltip with detailed count information
         */
        function updateAliasTooltip(datasetCounts, totalAliases) {
            try {
                const tooltipCalculationElement = document.getElementById('tooltipAliasCalculation');
                const tooltipBreakdownElement = document.getElementById('tooltipAliasBreakdown');
                if (!tooltipCalculationElement || !tooltipBreakdownElement) {
                    console.warn('üîç Alias tooltip elements not found');
                    return;
                }
                
                // Get actual dataset counts (not intersection-based)
                const confirmedData = DataManager.getDataset('confirmedMapping');
                const unconfirmedData = DataManager.getDataset('unconfirmedAliases');
                const concernData = DataManager.getDataset('sourceDataConcernAliases');
                
                // DataManager.getDataset('confirmedMapping') returns flattened aliases, not mapping structures
                const actualConfirmedCount = confirmedData.length;
                const unconfirmedCount = unconfirmedData.length;
                const concernCount = concernData.length;
                
                // Current Calculation section
                const calculationText = `${actualConfirmedCount} + ${unconfirmedCount} + ${concernCount} = ${totalAliases}`;
                
                // Breakdown section  
                const breakdownText = `‚Ä¢ Confirmed Mapping Aliases: ${actualConfirmedCount}<br>‚Ä¢ Unconfirmed Aliases: ${unconfirmedCount}<br>‚Ä¢ Unconfirmed Aliases - Data Concens : ${concernCount}`;
                
                tooltipCalculationElement.innerHTML = calculationText;
                tooltipBreakdownElement.innerHTML = breakdownText;
                
                console.debug('üîç Updated alias tooltip with breakdown details');
                
            } catch (error) {
                console.error('üîç Alias tooltip update failed:', error.message);
            }
        }
        
        /**
         * Calculate confirmed mapping aliases that are also source data concerns
         */
        function calculateConfirmedConcerns() {
            try {
                const confirmedAliases = DataManager.getDataset('confirmedMapping');
                
                // Count confirmed aliases that have data quality issues
                let concernCount = 0;
                const concernDetails = [];
                
                confirmedAliases.forEach(alias => {
                    const concerns = detectSourceDataConcerns(alias);
                    if (concerns && concerns.length > 0) {
                        concernCount++;
                        concernDetails.push({
                            vendor: alias.vendor,
                            product: alias.product,
                            platform: alias.platform,
                            cpeBaseString: alias.cpeBaseString,
                            concerns: concerns
                        });
                    }
                });
                
                const totalConfirmed = confirmedAliases.length;
                const percentage = totalConfirmed > 0 ? ((concernCount / totalConfirmed) * 100).toFixed(1) : '0.0';
                
                return {
                    count: concernCount,
                    total: totalConfirmed,
                    percentage: percentage,
                    details: concernDetails
                };
                
            } catch (error) {
                console.error('üîç Confirmed concerns calculation failed:', error.message);
                return { count: 0, total: 0, percentage: '0.0', details: [] };
            }
        }
        
        /**
         * Calculate external aliases that are also source data concerns
         */
        function calculateExternalConcerns() {
            try {
                const unconfirmedAliases = DataManager.getDataset('unconfirmedAliases');
                const sourceDataConcernAliases = DataManager.getDataset('sourceDataConcernAliases');
                
                // Combine both external datasets
                const allExternalAliases = [...unconfirmedAliases, ...sourceDataConcernAliases];
                
                // Count external aliases that have data quality issues
                let concernCount = 0;
                const concernDetails = [];
                
                allExternalAliases.forEach(alias => {
                    const concerns = detectSourceDataConcerns(alias);
                    if (concerns && concerns.length > 0) {
                        concernCount++;
                        concernDetails.push({
                            vendor: alias.vendor,
                            product: alias.product,
                            platform: alias.platform,
                            cpeBaseString: alias.cpeBaseString,
                            concerns: concerns
                        });
                    }
                });
                
                const totalExternal = allExternalAliases.length;
                const percentage = totalExternal > 0 ? ((concernCount / totalExternal) * 100).toFixed(1) : '0.0';
                
                return {
                    count: concernCount,
                    total: totalExternal,
                    percentage: percentage,
                    details: concernDetails
                };
                
            } catch (error) {
                console.error('üîç External concerns calculation failed:', error.message);
                return { count: 0, total: 0, percentage: '0.0', details: [] };
            }
        }
        
        /**
         * Update the concern tooltip with detailed information
         */
        function updateConcernTooltip(concernData) {
            try {
                const tooltipCalculationElement = document.getElementById('tooltipConcernCalculation');
                const tooltipBreakdownElement = document.getElementById('tooltipConcernBreakdown');
                if (!tooltipCalculationElement || !tooltipBreakdownElement) {
                    console.warn('üîç Concern tooltip elements not found');
                    return;
                }
                
                // Update calculation section
                const calculationText = `${concernData.count} √∑ ${concernData.total} = ${concernData.percentage}%`;
                tooltipCalculationElement.innerHTML = calculationText;
                
                // Update breakdown section
                const breakdownText = `‚Ä¢ Confirmed Mapping Aliases with Data Concerns: ${concernData.count}<br>‚Ä¢ Total Confirmed Mapping Aliases: ${concernData.total}<br>‚Ä¢ Confirmed Mapping Data Concerns Percentage: ${concernData.percentage}%`;
                tooltipBreakdownElement.innerHTML = breakdownText;
                
                console.debug('üîç Updated concern tooltip with calculation details');
                
            } catch (error) {
                console.error('üîç Concern tooltip update failed:', error.message);
            }
        }
        
        /**
         * Update the external concern tooltip with detailed information
         */
        function updateExternalConcernTooltip(externalConcernData) {
            try {
                const tooltipCalculationElement = document.getElementById('tooltipExternalConcernCalculation');
                const tooltipBreakdownElement = document.getElementById('tooltipExternalConcernBreakdown');
                if (!tooltipCalculationElement || !tooltipBreakdownElement) {
                    console.warn('üîç External concern tooltip elements not found');
                    return;
                }
                
                // Get dataset counts for detailed breakdown
                const unconfirmedCount = DataManager.getDataset('unconfirmedAliases').length;
                const concernAliasesCount = DataManager.getDataset('sourceDataConcernAliases').length;
                
                // Update calculation section
                const calculationText = `${externalConcernData.count} √∑ ${externalConcernData.total} = ${externalConcernData.percentage}%`;
                tooltipCalculationElement.innerHTML = calculationText;
                
                // Update breakdown section with more detail
                const breakdownText = `‚Ä¢ Unconfirmed Aliases with Data Concerns: ${externalConcernData.count}<br>‚Ä¢ Total External Aliases: ${externalConcernData.total}<br>&nbsp;&nbsp;- Unconfirmed Aliases: ${unconfirmedCount}<br>&nbsp;&nbsp;- Unconfirmed Aliases - Data Concerns : ${concernAliasesCount}<br>‚Ä¢ Unconfirmed Alias - Data Concerns Percentage: ${externalConcernData.percentage}%`;
                tooltipBreakdownElement.innerHTML = breakdownText;
                
                console.debug('üîç Updated external concern tooltip with calculation details');
                
            } catch (error) {
                console.error('üîç External concern tooltip update failed:', error.message);
            }
        }
        
        /**
         * Update dashboard stats using DataManager data via query functions
         */
        function updateStatsFromDataManager() {
            try {
                console.debug('üéØ DASHBOARD: Starting statistics update');
                
                // Check if DataManager has data
                const confirmedData = DataManager.getDataset('confirmedMapping');
                const unconfirmedData = DataManager.getDataset('unconfirmedAliases');
                const concernData = DataManager.getDataset('sourceDataConcernAliases');
                
                console.debug('üìä Dataset sizes:', {
                    confirmed: confirmedData.length,
                    unconfirmed: unconfirmedData.length,
                    concern: concernData.length
                });
                
                // Use query functions to get needed data (force fresh calculation)
                const totalAliases = DataQueries.getTotalAliasCount();
                const confirmedMappingCoverage = DataQueries.getConfirmedCoveragePercent();
                const datasetCounts = DataQueries.getDatasetCounts();
                
                console.debug('üîç Fresh calculation results:', {
                    totalAliases,
                    confirmedMappingCoverage,
                    timestamp: new Date().toISOString()
                });
                
                // Calculate confirmed mapping data concerns
                const confirmedConcernData = calculateConfirmedConcerns();
                
                // Calculate external data concerns
                const externalConcernData = calculateExternalConcerns();
                
                console.debug('üìà Calculated stats:', { 
                    totalAliases, 
                    confirmedMappingCoverage, 
                    confirmedConcerns: confirmedConcernData,
                    externalConcerns: externalConcernData 
                });
                
                // Update DOM elements
                const totalAliasesEl = document.getElementById('totalAliases');
                const confirmedMappingCoverageEl = document.getElementById('confirmedMappingCoverage');
                const confirmedConcernCountEl = document.getElementById('confirmedConcernCount');
                const externalConcernCountEl = document.getElementById('externalConcernCount');
                
                console.debug('üîç DOM Elements found:', {
                    totalAliasesEl: !!totalAliasesEl,
                    confirmedMappingCoverageEl: !!confirmedMappingCoverageEl,
                    confirmedConcernCountEl: !!confirmedConcernCountEl,
                    externalConcernCountEl: !!externalConcernCountEl
                });
                
                if (!totalAliasesEl || !confirmedMappingCoverageEl || !confirmedConcernCountEl || !externalConcernCountEl) {
                    console.warn('üéØ DASHBOARD: Missing DOM elements for statistics');
                    return;
                }
                
                // Log current values before update with detailed analysis
                const currentCoverage = confirmedMappingCoverageEl.textContent;
                const newCoverage = confirmedMappingCoverage;
                const coverageChanged = currentCoverage !== newCoverage;
                
                console.debug(`üîÑ DOM UPDATE BEFORE: Total: "${totalAliasesEl.textContent}", Coverage: "${currentCoverage}"`);
                console.debug(`üîÑ DOM UPDATE PLANNED: Total: "${totalAliases}", Coverage: "${newCoverage}"`);
                console.debug(`üîÑ COVERAGE CHANGE CHECK: "${currentCoverage}" ‚Üí "${newCoverage}" (Changed: ${coverageChanged})`);
                
                totalAliasesEl.textContent = totalAliases;
                confirmedMappingCoverageEl.textContent = confirmedMappingCoverage;
                confirmedConcernCountEl.textContent = `${confirmedConcernData.count} (${confirmedConcernData.percentage}%)`;
                externalConcernCountEl.textContent = `${externalConcernData.count} (${externalConcernData.percentage}%)`;
                
                // Log values after update to confirm DOM was actually changed
                console.debug(`üîÑ DOM UPDATE AFTER: Total: "${totalAliasesEl.textContent}", Coverage: "${confirmedMappingCoverageEl.textContent}"`);
                console.debug(`üîÑ DOM UPDATE VERIFICATION: Coverage set to "${confirmedMappingCoverage}" and DOM now shows "${confirmedMappingCoverageEl.textContent}"`);
                console.debug(`üîÑ UPDATE SUMMARY: ${coverageChanged ? 'COVERAGE CHANGED' : 'COVERAGE UNCHANGED'} from "${currentCoverage}" to "${confirmedMappingCoverageEl.textContent}"`);
                
                // Update tooltips with detailed calculations
                updateAliasTooltip(datasetCounts, totalAliases);
                updateCoverageTooltip(datasetCounts, totalAliases, confirmedMappingCoverage);
                updateConcernTooltip(confirmedConcernData);
                updateExternalConcernTooltip(externalConcernData);
                
                console.info(`üéØ DASHBOARD: Updated stats - ${totalAliases} aliases, ${confirmedMappingCoverage} coverage`);
                
            } catch (error) {
                console.error('üéØ DASHBOARD ERROR: Statistics update failed:', error.message);
            }
        }
        
        /**
         * Initialize charts and UI using query functions
         */
        function initializeChartsAndUI() {
            try {
                console.debug('üéØ DASHBOARD: Starting charts and UI initialization');
                
                // Show main content and hide loading
                loadingMessage.style.display = 'none';
                mainContent.style.display = 'block';
                
                // Generate charts using query functions
                const allAliases = DataQueries.getAllAliases();
                const topAliases = DataQueries.getTopAliasesByCVE(10);
                
                console.debug('üìä Chart data:', { allAliases: allAliases.length, topAliases: topAliases.length });
                
                // Initialize filter system
                initializeFilter();
                
                console.info('üéØ DASHBOARD: Charts and UI initialized successfully');
                
            } catch (error) {
                console.error('üéØ DASHBOARD ERROR: Charts/UI initialization failed:', error.message);
            }
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        function hideError() {
            errorMessage.style.display = 'none';
        }

        // ========== PROCESSING OVERLAY FUNCTIONS ==========
        
        function showProcessingOverlay(title = 'Processing Data', message = 'Please wait while we process your request...') {
            const overlay = document.getElementById('processingOverlay');
            const titleElement = document.getElementById('processingTitle');
            const messageElement = document.getElementById('processingMessage');
            const progressBar = document.getElementById('processingProgressBar');
            const detailsElement = document.getElementById('processingDetails');
            
            if (!overlay) {
                console.error('Processing overlay element not found!');
                return;
            }
            
            titleElement.textContent = title;
            messageElement.textContent = message;
            progressBar.style.width = '0%';
            detailsElement.textContent = '';
            
            overlay.style.display = 'flex';
            overlay.style.visibility = 'visible';
        }
        
        function updateProcessingProgress(progress, details = '') {
            const progressBar = document.getElementById('processingProgressBar');
            const detailsElement = document.getElementById('processingDetails');
            
            // Ensure progress is between 0 and 100
            progress = Math.max(0, Math.min(100, progress));
            progressBar.style.width = progress + '%';
            
            if (details) {
                detailsElement.textContent = details;
            }
        }
        
        function hideProcessingOverlay() {
            const overlay = document.getElementById('processingOverlay');
            overlay.style.display = 'none';
        }
        
        function showProcessingWithSteps(title, steps, currentStep = 0) {
            showProcessingOverlay(title, steps[currentStep] || 'Processing...');
            
            if (steps.length > 0) {
                const progress = (currentStep / steps.length) * 100;
                updateProcessingProgress(progress, `Step ${currentStep + 1} of ${steps.length}`);
            }
        }


        function displayAliasesByFrequency(sortedAliases) {
            const container = document.getElementById('aliasGroups');
            container.innerHTML = '';

            // Filter out any invalid or corrupted aliases before storing
            const validAliases = sortedAliases.filter(alias => {
                // An alias must have at least an ID and some identifying information
                return alias && 
                       alias.id && 
                       (alias.vendor || alias.product || alias.alias || alias.packageName);
            });

            // Store current alias data for selection functionality
            storeCurrentAliasData(validAliases);

            if (validAliases.length === 0) {
                container.innerHTML = '<div class="no-data">No alias data available</div>';
                return;
            }

            // Separate confirmed mappings from other aliases
            const confirmedMappings = validAliases.filter(alias => 
                alias.isConfirmedMapping === true);
            const otherAliases = validAliases.filter(alias => 
                alias.isConfirmedMapping !== true);

            // Create sections - confirmed mappings first (grouped by CPE), then consolidated others
            const sections = [];
            
            if (confirmedMappings.length > 0) {
                // Group confirmed mappings by CPE base string
                const cpeGroups = {};
                console.log(`Processing ${confirmedMappings.length} confirmed mappings for display grouping`);
                confirmedMappings.forEach((alias, index) => {
                    console.log(`Confirmed mapping ${index + 1}:`, {
                        vendor: alias.vendor,
                        product: alias.product,
                        cpeBaseString: alias.cpeBaseString,
                        hasProperty: !!alias.cpeBaseString
                    });
                    if (!alias.cpeBaseString) {
                        console.warn(`Confirmed mapping alias missing cpeBaseString, skipping:`, alias);
                        return; // Skip this alias instead of throwing error
                    }
                    const cpeKey = alias.cpeBaseString;
                    if (!cpeGroups[cpeKey]) {
                        cpeGroups[cpeKey] = [];
                    }
                    cpeGroups[cpeKey].push(alias);
                });
                
                console.log(`Created ${Object.keys(cpeGroups).length} CPE groups:`, Object.keys(cpeGroups));
                
                // Add a single parent section for all confirmed mappings
                sections.push({
                    title: `Confirmed Mappings (${confirmedMappings.length} aliases)`, 
                    aliases: [], // Will be rendered as CPE groups 
                    priority: 'confirmed-parent',
                    collapsed: true,
                    description: 'Previously validated CPE mappings from authoritative sources',
                    isConfirmedParent: true,
                    cpeGroups: cpeGroups
                });
            }
            
            if (otherAliases.length > 0) {
                sections.push({
                    title: `Unconfirmed Aliases (${otherAliases.length} aliases)`, 
                    aliases: otherAliases, 
                    priority: 'unconfirmed',
                    collapsed: false,
                    description: 'Aliases requiring manual validation and CPE mapping'
                });
            }

            sections.forEach(section => {
                // Simple section header with collapse functionality
                const sectionHeader = document.createElement('div');
                const isCpeGroup = section.isCpeGroup;
                const isConfirmedSection = section.priority.startsWith('confirmed');
                const toggleId = `section-${section.priority}`;
                
                const headerColor = isCpeGroup ? 
                    'linear-gradient(135deg, #2E7D32, #4CAF50)' : 
                    isConfirmedSection ? 
                        'linear-gradient(135deg, #4CAF50, #66BB6A)' : 
                        'linear-gradient(135deg, #4CAF50, #66BB6A)';
                
                sectionHeader.className = 'aliases-section-header gradient-green';
                sectionHeader.style.background = headerColor;
                
                sectionHeader.innerHTML = `
                    <div class="section-header-flex">
                        <div style="text-align: left; flex: 1;">
                            <span style="font-weight: 600;">${section.title}</span>
                            <div style="font-size: 0.8em; opacity: 0.9; margin-top: 1px;">${section.description}</div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                            ${section.isConfirmedParent ? `
                                <button id="${toggleId}-download" class="download-btn" title="Download Confirmed Mappings JSON" 
                                        style="background: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.3); 
                                               border-radius: 4px; padding: 4px 8px; color: white; font-size: 0.85em; 
                                               cursor: pointer; display: flex; align-items: center; gap: 4px;
                                               transition: all 0.2s ease;">
                                    <i class="fas fa-download" style="font-size: 0.8em;"></i>
                                    <span>JSON</span>
                                </button>
                            ` : ''}
                            <span id="${toggleId}-toggle" class="collapsible-toggle" style="font-size: 1.1em;">
                                ${section.collapsed ? '‚ñ∂' : '‚ñº'}
                            </span>
                        </div>
                    </div>
                `;
                
                // Add click handler for collapse/expand with smooth transitions
                sectionHeader.addEventListener('click', (e) => {
                    // Don't collapse/expand if clicking the download button
                    if (e.target.closest('.download-btn')) {
                        return;
                    }
                    
                    const content = document.getElementById(toggleId + '-content');
                    const toggle = document.getElementById(toggleId + '-toggle');
                    const isCollapsed = content.classList.contains('collapsed');
                    
                    if (isCollapsed) {
                        content.classList.remove('collapsed');
                        toggle.textContent = '‚ñº';
                        toggle.classList.add('rotated');
                    } else {
                        content.classList.add('collapsed');
                        toggle.textContent = '‚ñ∂';
                        toggle.classList.remove('rotated');
                    }
                });
                
                // Add download button functionality for confirmed mappings
                if (section.isConfirmedParent) {
                    const downloadBtn = sectionHeader.querySelector(`#${toggleId}-download`);
                    if (downloadBtn) {
                        // Add hover effects
                        downloadBtn.addEventListener('mouseenter', () => {
                            downloadBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                            downloadBtn.style.transform = 'translateY(-1px)';
                        });
                        
                        downloadBtn.addEventListener('mouseleave', () => {
                            downloadBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                            downloadBtn.style.transform = 'translateY(0)';
                        });
                        
                        // Add download functionality
                        downloadBtn.addEventListener('click', (e) => {
                            e.stopPropagation(); // Prevent section collapse/expand
                            downloadConfirmedMappingsJSON(section.cpeGroups);
                        });
                    }
                }
                
                container.appendChild(sectionHeader);

                // Section container with smooth collapse support
                const sectionContainer = document.createElement('div');
                sectionContainer.id = toggleId + '-content';
                sectionContainer.className = `aliases-section-container collapsible-content ${section.collapsed ? 'collapsed' : ''}`;

                // Special handling for confirmed parent section - render CPE groups
                if (section.isConfirmedParent && section.cpeGroups) {
                    Object.keys(section.cpeGroups).sort().forEach((cpeString, cpeIndex) => {
                        const aliases = section.cpeGroups[cpeString];
                        
                        // Create CPE group header
                        const cpeGroupDiv = document.createElement('div');
                        cpeGroupDiv.className = 'cpe-group-div white-card-compact';
                        
                        const cpeHeader = document.createElement('div');
                        const cpeToggleId = `cpe-group-${cpeIndex}`;
                        cpeHeader.className = 'cpe-header gradient-green-dark';
                        cpeHeader.innerHTML = `
                            <span>${cpeString} (${aliases.length} aliases)</span>
                            <span id="${cpeToggleId}-toggle" class="collapsible-toggle">‚ñ∂</span>
                        `;
                        
                        // CPE group content with smooth transitions
                        const cpeContent = document.createElement('div');
                        cpeContent.id = cpeToggleId + '-content';
                        cpeContent.className = 'cpe-collapsible-content collapsed';
                        
                        // Add click handler for CPE group collapse/expand with dynamic height calculation
                        cpeHeader.addEventListener('click', () => {
                            const content = document.getElementById(cpeToggleId + '-content');
                            const toggle = document.getElementById(cpeToggleId + '-toggle');
                            const isCollapsed = content.classList.contains('collapsed');
                            
                            if (isCollapsed) {
                                content.classList.remove('collapsed');
                                toggle.textContent = '‚ñº';
                                toggle.classList.add('rotated');
                                setCpeContentHeight(content, true);
                            } else {
                                content.classList.add('collapsed');
                                toggle.textContent = '‚ñ∂';
                                toggle.classList.remove('rotated');
                                setCpeContentHeight(content, false);
                            }
                        });
                        
                        // Render aliases within this CPE group using the same system as unconfirmed aliases
                        console.log(`Rendering ${aliases.length} aliases for CPE: ${cpeString}`);
                        aliases.forEach((alias, aliasIndex) => {
                            try {
                                console.log(`Processing alias ${aliasIndex + 1}:`, alias.vendor, alias.product, `CVEs: ${alias.source_cve?.length || 0}`);
                                // Mark this alias as confirmed for proper rendering
                                alias.isConfirmedMapping = true;
                            
                            // Create a temporary section structure to reuse the existing rendering logic
                            const tempSection = {
                                aliases: [alias],
                                isCpeGroup: true,
                                priority: 'confirmed'
                            };
                            
                            // Use the same alias rendering logic as unconfirmed aliases
                            const globalIndex = currentAliasData ? currentAliasData.findIndex(item => 
                                item === alias || (
                                    item.vendor === alias.vendor && 
                                    item.product === alias.product && 
                                    item.frequency === alias.frequency &&
                                    item.platform === alias.platform &&
                                    item.version === alias.version &&
                                    item.update === alias.update &&
                                    item.edition === alias.edition &&
                                    item.language === alias.language &&
                                    item.sw_edition === alias.sw_edition &&
                                    item.target_sw === alias.target_sw &&
                                    item.target_hw === alias.target_hw &&
                                    item.other === alias.other &&
                                    JSON.stringify(item.source_cve || []) === JSON.stringify(alias.source_cve || [])
                                )
                            ) : aliasIndex;
                            
                            const aliasDiv = document.createElement('div');
                            aliasDiv.className = 'alias-group';
                            aliasDiv.style.margin = '0';
                            aliasDiv.style.border = 'none';
                            aliasDiv.style.borderBottom = aliasIndex < aliases.length - 1 ? '1px solid #E0E0E0' : 'none';
                            aliasDiv.style.borderRadius = '0';
                            aliasDiv.style.backgroundColor = '#ffffff';

                            const headerDiv = document.createElement('div');
                            headerDiv.className = 'alias-group-header';
                            headerDiv.style.padding = '20px';
                            
                            // This alias is confirmed
                            const isConfirmed = true;
                            
                            // Create comprehensive alias summary using the same logic
                            const aliasProps = [];
                            
                    // Core properties - only show if they exist and are not placeholders
                    if (alias.vendor && alias.vendor !== '' && alias.vendor !== 'N/A' && alias.vendor !== 'n/a' && alias.vendor !== 'unknown') {
                        aliasProps.push(`<strong>Vendor:</strong> ${alias.vendor}`);
                    }
                    if (alias.product && alias.product !== '' && alias.product !== 'N/A' && alias.product !== 'n/a' && alias.product !== 'unknown') {
                        aliasProps.push(`<strong>Product:</strong> ${alias.product}`);
                    }
                    if (alias.platform && alias.platform !== '' && alias.platform !== 'N/A' && alias.platform !== 'n/a' && alias.platform !== 'unknown' && alias.platform !== '*') {
                        aliasProps.push(`<strong>Platform:</strong> ${alias.platform}`);
                    }
                            
                            // Additional CVE 5.X properties that might be present
                            const additionalFields = ['collectionURL', 'packageName', 'programRoutines', 
                                                    'programFiles', 'modules', 'defaultStatus', 'repo'];
                            
                            additionalFields.forEach(field => {
                                if (alias[field] && alias[field] !== 'N/A' && alias[field] !== '') {
                                    let value = alias[field];
                                    if (Array.isArray(value)) {
                                        value = value.join(', ');
                                    }
                                    
                                    // Format field name for display
                                    const displayField = field.charAt(0).toUpperCase() + field.slice(1);
                                    aliasProps.push(`<strong>${displayField}:</strong> ${value}`);
                                }
                            });
                            
                            // Add confirmed metadata if available  
                            if (alias.last_updated) {
                                const updateTime = new Date(alias.last_updated).toLocaleDateString();
                                aliasProps.push(`<strong>Last Updated:</strong> ${updateTime}`);
                            }
                            
                            if (alias.confirmed_by) {
                                const confirmedBy = Array.isArray(alias.confirmed_by) ? alias.confirmed_by.join(', ') : alias.confirmed_by;
                                aliasProps.push(`<strong>Confirmed By:</strong> ${confirmedBy}`);
                            }
                            
                            // Create alias title using the same logic
                            const aliasTitle = alias.vendor && alias.product ? 
                                `${alias.vendor} ${alias.product}` :
                                alias.product || alias.vendor || 
                                alias.packageName || alias.programFiles || 
                                `Alias ${aliasIndex + 1}`;
                            
                            // Use the same header HTML structure as unconfirmed aliases
                            headerDiv.innerHTML = `
                                <div class="alias-header">
                                    <div class="flex-between gap-10">
                                        <div class="flex-start">
                                            <div class="flex-1">
                                                <div class="flex-center mb-6">
                                                    <span class="alias-title">${aliasTitle}</span>
                                                    <span class="confirmed-badge">CONFIRMED</span>
                                                </div>
                                                <div class="alias-properties">
                                                    ${aliasProps.join('<br>')}
                                                </div>
                                                ${alias.container_type ? `<div class="alias-container-info"><strong>Container:</strong> ${alias.container_type}</div>` : ''}
                                            </div>
                                        </div>
                                        <div class="flex-center flex-shrink-0 pt-2">
                                            <span class="cve-count">${alias.frequency || alias.source_cve?.length || 0} CVEs</span>
                                            <div class="expand-caret">‚ñº</div>
                                        </div>
                                    </div>
                                </div>
                            `;

                            // Use the same details structure as unconfirmed aliases
                            const detailsDiv = document.createElement('div');
                            detailsDiv.className = 'alias-details';

                            // Add detailed content using the same system
                            const cveGroups = groupCvesByYear(alias.source_cve || []);
                            const cveGroupsHtml = generateCveGroupsHtml(cveGroups);

                            detailsDiv.innerHTML = `
                                <div class="alias-item" style="margin: 0;">
                                    <div style="margin-bottom: 8px;">
                                        <strong>CVE References by Year:</strong>
                                    </div>
                                    ${cveGroupsHtml}
                                </div>
                            `;

                            aliasDiv.appendChild(headerDiv);
                            aliasDiv.appendChild(detailsDiv);

                            // Use the same click handler logic as unconfirmed aliases
                            headerDiv.addEventListener('click', function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                
                                const isExpanded = detailsDiv.classList.contains('expanded');
                                const caret = headerDiv.querySelector('.expand-caret');
                                
                                if (isExpanded) {
                                    detailsDiv.classList.remove('expanded');
                                    caret.textContent = '‚ñ∂';
                                    caret.classList.remove('rotated');
                                } else {
                                    detailsDiv.classList.add('expanded');
                                    caret.textContent = '‚ñº';
                                    caret.classList.add('rotated');
                                }
                                
                                // Update parent CPE section height after alias expansion/collapse
                                updateCpeContentHeight(detailsDiv);
                            });

                            cpeContent.appendChild(aliasDiv);
                            } catch (error) {
                                console.error(`Error rendering confirmed alias ${aliasIndex}:`, error, alias);
                                // Create a minimal error display for this alias
                                const errorDiv = document.createElement('div');
                                errorDiv.className = 'alias-group';
                                errorDiv.style.padding = '10px';
                                errorDiv.style.backgroundColor = '#ffeaea';
                                errorDiv.innerHTML = `<div style="color: #d32f2f;">Error rendering alias: ${getDisplayValue(alias.vendor, 'Unknown Vendor')} ${getDisplayValue(alias.product, 'Unknown Product')}</div>`;
                                cpeContent.appendChild(errorDiv);
                            }
                        });
                        
                        cpeGroupDiv.appendChild(cpeHeader);
                        cpeGroupDiv.appendChild(cpeContent);
                        sectionContainer.appendChild(cpeGroupDiv);
                    });
                } else {
                    // Normal section rendering for unconfirmed aliases
                    section.aliases.forEach((alias, index) => {
                    // Find the global index of this alias in currentAliasData using comprehensive comparison
                    const globalIndex = currentAliasData ? currentAliasData.findIndex(item => 
                        item === alias || (
                            item.vendor === alias.vendor && 
                            item.product === alias.product && 
                            item.frequency === alias.frequency &&
                            item.platform === alias.platform &&
                            item.version === alias.version &&
                            item.update === alias.update &&
                            item.edition === alias.edition &&
                            item.language === alias.language &&
                            item.sw_edition === alias.sw_edition &&
                            item.target_sw === alias.target_sw &&
                            item.target_hw === alias.target_hw &&
                            item.other === alias.other &&
                            JSON.stringify(item.source_cve || []) === JSON.stringify(alias.source_cve || [])
                        )
                    ) : index;
                    
                    const aliasDiv = document.createElement('div');
                    aliasDiv.className = 'alias-group';
                    aliasDiv.style.margin = '0';
                    aliasDiv.style.border = 'none';
                    aliasDiv.style.borderBottom = index < section.aliases.length - 1 ? '1px solid #E0E0E0' : 'none';
                    aliasDiv.style.borderRadius = '0';
                    aliasDiv.style.backgroundColor = '#ffffff';

                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'alias-group-header';
                    headerDiv.style.padding = '20px';
                    
                    // Check if this is a confirmed mapping
                    const isConfirmed = section.isCpeGroup || section.priority.startsWith('confirmed') || 
                                       alias.isConfirmedMapping === true;
                    
                    // Create comprehensive alias summary
                    const aliasProps = [];
                    
                    // Show confirmed mapping indicator or frequency priority
                    if (isConfirmed) {
                        // For confirmed mappings, just show basic alias properties - no extra indicators
                    }
                    // Note: Removed frequency-based priority and group display as requested
                    
                    // Core properties - only show if they exist and are not placeholders
                    if (alias.vendor && alias.vendor !== '' && alias.vendor !== 'N/A' && alias.vendor !== 'n/a' && alias.vendor !== 'unknown') {
                        aliasProps.push(`<strong>Vendor:</strong> ${alias.vendor}`);
                    }
                    if (alias.product && alias.product !== '' && alias.product !== 'N/A' && alias.product !== 'n/a' && alias.product !== 'unknown') {
                        aliasProps.push(`<strong>Product:</strong> ${alias.product}`);
                    }
                    if (alias.platform && alias.platform !== '' && alias.platform !== 'N/A' && alias.platform !== 'n/a' && alias.platform !== 'unknown' && alias.platform !== '*') {
                        aliasProps.push(`<strong>Platform:</strong> ${alias.platform}`);
                    }
                    
                    // Additional CVE 5.X properties that might be present
                    const additionalFields = ['collectionURL', 'packageName', 'programRoutines', 
                                            'programFiles', 'modules', 'defaultStatus', 'repo'];
                    
                    additionalFields.forEach(field => {
                        if (alias[field] && alias[field] !== 'N/A' && alias[field] !== '') {
                            let value = alias[field];
                            if (Array.isArray(value)) {
                                value = value.join(', ');
                            }
                            if (typeof value === 'string' && value.length > 50) {
                                value = value.substring(0, 47) + '...';
                            }
                            aliasProps.push(`<strong>${field}:</strong> ${value}`);
                        }
                    });
                    
                    // Enhanced property display features
                    if (alias.lastUpdated || alias.last_updated) {
                        const updateTime = alias.lastUpdated || alias.last_updated;
                        aliasProps.push(`<strong>Last Updated:</strong> ${updateTime}`);
                    }
                    
                    if (alias.confirmedBy || alias.confirmed_by) {
                        const confirmedBy = alias.confirmedBy || alias.confirmed_by;
                        aliasProps.push(`<strong>Confirmed By:</strong> ${confirmedBy}`);
                    }
                    
                    // Create alias title from vendor/product or other identifying fields
                    const aliasTitle = alias.vendor && alias.product ? 
                        `${alias.vendor} ${alias.product}` :
                        alias.product || alias.vendor || 
                        alias.packageName || alias.programFiles || 
                        `Alias ${globalIndex + 1}`;
                    
                    headerDiv.innerHTML = `
                        <div class="alias-header">
                            <div class="flex-between gap-10">
                                <div class="flex-start">
                                    ${!isConfirmed ? `<input type="checkbox" class="alias-selection-checkbox" 
                                           onchange="toggleAliasSelection(this, ${alias.id}, '${alias.aliasGroup}', 'unconfirmedAliases')" 
                                           onclick="event.stopPropagation()"
                                           class="mt-2">` : ''}
                                    <div class="flex-1">
                                        <div class="flex-center mb-6">
                                            <span class="alias-title">${aliasTitle}</span>
                                            ${isConfirmed ? '<span class="confirmed-badge">CONFIRMED</span>' : ''}
                                        </div>
                                        <div class="alias-properties">
                                            ${aliasProps.join('<br>')}
                                        </div>
                                        ${alias.container_type ? `<div class="alias-container-info"><strong>Container:</strong> ${alias.container_type}</div>` : ''}
                                    </div>
                                </div>
                                ${!isConfirmed ? `<div class="flex-center flex-shrink-0 pt-2">
                                    <span class="cve-count">${alias.frequency || alias.source_cve?.length || 0} CVEs</span>
                                    <div class="expand-caret">‚ñº</div>
                                </div>` : ''}
                            </div>
                        </div>
                    `;

                    const detailsDiv = document.createElement('div');
                    detailsDiv.className = 'alias-details';

                    // Only add detailed content for non-confirmed mappings
                    if (!isConfirmed) {
                        // Group CVEs by year for better organization
                        const cveGroups = groupCvesByYear(alias.source_cve);
                        const cveGroupsHtml = generateCveGroupsHtml(cveGroups);

                        // Show detailed CVE information with year grouping
                        detailsDiv.innerHTML = `
                            <div class="alias-item" style="margin: 0;">
                                <div style="margin-bottom: 8px;">
                                    <strong>CVE References by Year:</strong>
                                </div>
                                <div class="cve-year-groups">
                                    ${cveGroupsHtml}
                                </div>
                            </div>
                        `;

                        headerDiv.addEventListener('click', function() {
                            const icon = headerDiv.querySelector('.expand-icon') || headerDiv.querySelector('.expand-caret');
                            const isExpanded = detailsDiv.classList.contains('expanded');
                            
                            if (isExpanded) {
                                detailsDiv.classList.remove('expanded');
                                headerDiv.classList.remove('expanded');
                                if (icon) icon.classList.remove('rotated');
                            } else {
                                detailsDiv.classList.add('expanded');
                                headerDiv.classList.add('expanded');
                                if (icon) icon.classList.add('rotated');
                            }
                        });
                    }

                    aliasDiv.appendChild(headerDiv);
                    aliasDiv.appendChild(detailsDiv);
                    sectionContainer.appendChild(aliasDiv);
                });
                } // Close the else block for normal section rendering

                container.appendChild(sectionContainer);
            });
        }

        function displaySourceDataConcerns(concerningAliases) {
            const container = document.getElementById('sourceDataConcernGroups');
            container.innerHTML = '';

            if (concerningAliases.length === 0) {
                return; // Don't show anything if no concerns
            }

            // Store concerning aliases data for selection functionality
            if (!currentAliasData) {
                currentAliasData = [];
            }
            
            // Add concerning aliases to current data with unique identifiers
            concerningAliases.forEach((alias, index) => {
                const concernIndex = `concern_${index}`;
                currentAliasData[concernIndex] = alias;
            });

            // Create the main section header
            const sectionHeader = document.createElement('div');
            const toggleId = 'source-data-concerns';
            
            sectionHeader.className = 'aliases-section-header gradient-green';
            
            sectionHeader.innerHTML = `
                <div class="section-header-flex">
                    <div style="text-align: left; flex: 1;">
                        <span style="font-weight: 600;">Unconfirmed Aliases - Data Concerns (${concerningAliases.length} aliases)</span>
                        <div style="font-size: 0.8em; opacity: 0.9; margin-top: 1px;">Aliases that likely require upstream data contributor attention</div>
                    </div>
                    <span id="${toggleId}-toggle" class="collapsible-toggle" style="font-size: 1.1em; flex-shrink: 0;">‚ñº</span>
                </div>
            `;
            
            // Add click handler for collapse/expand with smooth transitions
            sectionHeader.addEventListener('click', () => {
                const content = document.getElementById(toggleId + '-content');
                const toggle = document.getElementById(toggleId + '-toggle');
                const isCollapsed = content.classList.contains('collapsed');
                
                if (isCollapsed) {
                    content.classList.remove('collapsed');
                    toggle.textContent = '‚ñº';
                    toggle.classList.add('rotated');
                } else {
                    content.classList.add('collapsed');
                    toggle.textContent = '‚ñ∂';
                    toggle.classList.remove('rotated');
                }
            });
            
            container.appendChild(sectionHeader);

            // Section container with smooth transitions
            const sectionContainer = document.createElement('div');
            sectionContainer.id = toggleId + '-content';
            sectionContainer.className = 'aliases-section-container collapsible-content';

            // Render aliases exactly like the main unconfirmed aliases section
            concerningAliases.forEach((alias, aliasIndex) => {
                // Create a unique index for this section to avoid conflicts with main section
                const concernGlobalIndex = `concern_${aliasIndex}`;
                
                const aliasDiv = document.createElement('div');
                aliasDiv.className = 'alias-group';
                aliasDiv.style.margin = '0';
                aliasDiv.style.border = 'none';
                aliasDiv.style.borderBottom = aliasIndex < concerningAliases.length - 1 ? '1px solid #E0E0E0' : 'none';
                aliasDiv.style.borderRadius = '0';
                aliasDiv.style.backgroundColor = '#ffffff';

                const headerDiv = document.createElement('div');
                headerDiv.className = 'alias-group-header';
                headerDiv.style.padding = '20px';

                // Use the exact same format as the main unconfirmed aliases
                headerDiv.innerHTML = `
                    <div style="margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #E0E0E0;">
                        <div class="section-header-flex-start">
                            <div style="display: flex; align-items: flex-start; gap: 8px;">
                                <input type="checkbox" class="alias-selection-checkbox" 
                                       onchange="toggleAliasSelection(this, ${alias.id}, '${alias.aliasGroup}', 'sourceDataConcernAliases')" 
                                       onclick="event.stopPropagation()"
                                       style="margin-top: 2px;"
                                       data-alias-data='${JSON.stringify(alias).replace(/'/g, "&apos;")}'>
                                <div style="flex: 1; min-width: 0;">
                                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                        <span style="color: #333; font-size: 0.95em; font-weight: 600;">
                                            ${[getDisplayValue(alias.vendor), getDisplayValue(alias.product, 'Product')].filter(v => v).join(' ')}
                                        </span>
                                    </div>
                                    <div style="font-size: 0.85em; line-height: 1.3;">
                                        ${!isPlaceholderValue(alias.vendor) ? `<strong>Vendor:</strong> ${alias.vendor}<br>` : ''}
                                        ${!isPlaceholderValue(alias.product) ? `<strong>Product:</strong> ${alias.product}<br>` : ''}
                                        ${!isPlaceholderValue(alias.platform) ? `<strong>Platform:</strong> ${alias.platform}<br>` : ''}
                                    </div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px; flex-shrink: 0; padding-top: 2px;">
                                <span style="color: #666; font-size: 0.85em; font-weight: 600;">${alias.cveCount} CVEs</span>
                                <div class="expand-icon" style="font-size: 1.2em; color: #666; cursor: pointer;">‚ñº</div>
                            </div>
                        </div>
                    </div>
                `;

                const detailsDiv = document.createElement('div');
                detailsDiv.className = 'alias-details';

                // Generate concern details with full issue descriptions
                const concernDetails = alias.concerns.map(concern => {
                    // Use the detailed issue description captured during detection
                    return concern.issue || `${concern.field}: ${concern.value}`;
                }).join('<br>');

                // Group CVEs by year for better organization
                const cveGroups = groupCvesByYear(alias.source_cve);
                const cveGroupsHtml = generateCveGroupsHtml(cveGroups);

                detailsDiv.innerHTML = `
                    <div class="alias-item" style="margin: 0;">
                        <div style="margin-bottom: 12px;">
                            <strong>Concern(s) Identified:</strong><br>
                            <div class="concern-details">
                                ${concernDetails}
                            </div>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>CVE References by Year:</strong>
                        </div>
                        <div class="cve-year-groups">
                            ${cveGroupsHtml}
                        </div>
                    </div>
                `;

                headerDiv.addEventListener('click', function() {
                    const icon = headerDiv.querySelector('.expand-icon') || headerDiv.querySelector('.expand-caret');
                    const isExpanded = detailsDiv.classList.contains('expanded');
                    
                    if (isExpanded) {
                        detailsDiv.classList.remove('expanded');
                        headerDiv.classList.remove('expanded');
                        if (icon) icon.classList.remove('rotated');
                    } else {
                        detailsDiv.classList.add('expanded');
                        headerDiv.classList.add('expanded');
                        if (icon) icon.classList.add('rotated');
                    }
                });

                aliasDiv.appendChild(headerDiv);
                aliasDiv.appendChild(detailsDiv);
                sectionContainer.appendChild(aliasDiv);
            });

            container.appendChild(sectionContainer);
        }

        // Toggle CVE year group visibility
        function toggleCveYear(header) {
            const content = header.nextElementSibling;
            const toggle = header.querySelector('.cve-year-toggle');
            
            // Check computed style instead of inline style
            const isHidden = window.getComputedStyle(content).display === 'none';
            
            if (isHidden) {
                content.style.display = 'block';
                toggle.style.transform = 'rotate(180deg)';
                toggle.textContent = '‚ñ≤';
            } else {
                content.style.display = 'none';
                toggle.style.transform = 'rotate(0deg)';
                toggle.textContent = '‚ñº';
            }
            
            // Update parent CPE section height after CVE expansion/collapse
            updateCpeContentHeight(content);
        }

        function updateCpeContentHeight(changedElement) {
            // Find the parent CPE content container
            let cpeContent = changedElement;
            while (cpeContent && !cpeContent.classList.contains('cpe-collapsible-content')) {
                cpeContent = cpeContent.parentElement;
            }
            
            if (cpeContent && !cpeContent.classList.contains('collapsed')) {
                // Calculate the natural height of all content
                const originalHeight = cpeContent.style.height;
                cpeContent.style.height = 'auto';
                const newHeight = cpeContent.scrollHeight;
                cpeContent.style.height = originalHeight;
                
                // Animate to the new height
                requestAnimationFrame(() => {
                    cpeContent.style.height = newHeight + 'px';
                });
            }
        }

        function setCpeContentHeight(cpeContent, isExpanding) {
            if (isExpanding) {
                // Set height to auto temporarily to measure content
                cpeContent.style.height = 'auto';
                const height = cpeContent.scrollHeight;
                cpeContent.style.height = '0px';
                
                // Force a reflow and then animate to full height
                requestAnimationFrame(() => {
                    cpeContent.style.height = height + 'px';
                });
            } else {
                // Animate to zero height
                const height = cpeContent.scrollHeight;
                cpeContent.style.height = height + 'px';
                
                requestAnimationFrame(() => {
                    cpeContent.style.height = '0px';
                });
            }
        }

        // Allow drag and drop
        document.addEventListener('DOMContentLoaded', function() {
            const container = document.querySelector('.container');

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                container.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                container.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                container.addEventListener(eventName, unhighlight, false);
            });

            function highlight(e) {
                container.style.opacity = '0.8';
            }

            function unhighlight(e) {
                container.style.opacity = '1';
            }

            container.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;

                if (files.length > 0) {
                    fileInput.files = files;
                    loadFile();
                }
            }
        });

        // Alias Selection and Consolidation Functions
        let selectedAliases = new Set();
        let currentAliasData = null;
        let currentConsolidatedData = null; // Store the raw consolidated data

        function makeDraggable() {
            const modal = document.getElementById('modalContent');
            const header = document.getElementById('modalHeader');
            let isDragging = false;
            let currentX = 0;
            let currentY = 0;
            let initialX = 0;
            let initialY = 0;

            header.addEventListener('mousedown', function(e) {
                initialX = e.clientX - currentX;
                initialY = e.clientY - currentY;
                
                if (e.target === header || e.target.tagName === 'H3') {
                    isDragging = true;
                }
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    
                    modal.style.transform = `translate(${currentX}px, ${currentY}px)`;
                }
            });

            document.addEventListener('mouseup', function() {
                isDragging = false;
            });
        }

        function toggleAliasSelection(checkbox, aliasId, aliasGroup, sourceDataset) {
            // Stop event propagation to prevent row expansion
            event.stopPropagation();
            
            const selectionKey = `${aliasId}:${sourceDataset}`;
            
            if (checkbox.checked) {
                // Store the ID and source dataset for efficient lookup
                selectedAliases.add(selectionKey);
            } else {
                // Remove the selection
                selectedAliases.delete(selectionKey);
            }
            updateSelectionPanel();
            
            // Update modal content if it's open
            if (currentConsolidatedData) {
                updateConsolidatedOutput();
            }
        }

        function updateSelectionPanel() {
            const panel = document.getElementById('selectionPanel');
            const countSpan = document.getElementById('selectionCount');
            const listDiv = document.getElementById('selectionList');
            const consolidateBtn = document.getElementById('consolidateBtn');

            countSpan.textContent = selectedAliases.size;
            
            if (selectedAliases.size === 0) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';
            
            // Update selection list
            listDiv.innerHTML = '';
            selectedAliases.forEach(selectionKey => {
                // Parse the selection key: "id:sourceDataset"
                const [aliasId, sourceDataset] = selectionKey.split(':');
                const numericId = parseInt(aliasId);
                
                // Find the alias using ID in the specified dataset
                let alias = null;
                let aliasTitle = '';
                
                if (DataManager.datasets[sourceDataset]) {
                    alias = DataManager.datasets[sourceDataset].find(item => item.id === numericId);
                }
                
                if (alias) {
                    aliasTitle = alias.vendor && alias.product ? 
                        `${alias.vendor} ${alias.product}` :
                        alias.product || alias.vendor || 
                        alias.packageName || alias.programFiles || 
                        alias.aliasGroup || 'Unknown Alias';
                } else {
                    aliasTitle = `Unknown Alias (ID: ${aliasId})`;
                }
                
                const item = document.createElement('div');
                item.className = 'selection-item';
                item.innerHTML = `
                    <span>${aliasTitle}</span>
                `;
                listDiv.appendChild(item);
            });

            consolidateBtn.disabled = selectedAliases.size < 1;
            
            // Update modal button state when selection changes
            updateModalButtonState();
        }

        function consolidateAliases() {
            if (selectedAliases.size < 1) {
                alert('Please select at least 1 alias to consolidate.');
                return;
            }

            // Collect all selected aliases using ID and source dataset
            const aliasesToConsolidate = Array.from(selectedAliases).map(selectionKey => {
                // Parse the selection key: "id:sourceDataset"
                const [aliasId, sourceDataset] = selectionKey.split(':');
                const numericId = parseInt(aliasId);
                
                // Find the alias using ID in the specified dataset
                let alias = null;
                
                if (DataManager.datasets[sourceDataset]) {
                    alias = DataManager.datasets[sourceDataset].find(item => item.id === numericId);
                }
                
                return alias;
            }).filter(alias => alias);

            // Store the raw consolidated data
            currentConsolidatedData = [];

            // Create separate entry for each selected alias (no consolidation)
            aliasesToConsolidate.forEach(alias => {
                const aliasEntry = {};

                // Include relevant properties only if they exist and have valid values
                ['vendor', 'product', 'version', 'update', 'edition', 'language', 'sw_edition', 'target_sw', 'target_hw', 'other'].forEach(prop => {
                    if (!isPlaceholderValue(alias[prop])) {
                        // Convert arrays to single string values
                        if (Array.isArray(alias[prop])) {
                            aliasEntry[prop] = alias[prop][0]; // Take first element
                        } else {
                            aliasEntry[prop] = alias[prop];
                        }
                    }
                });

                // Handle special properties - only include if they exist, convert arrays to strings
                if (!isPlaceholderValue(alias.platform)) {
                    if (Array.isArray(alias.platform)) {
                        aliasEntry.platform = alias.platform[0]; // Take first platform
                    } else {
                        aliasEntry.platform = alias.platform;
                    }
                }
                
                if (!isPlaceholderValue(alias.collectionURL)) {
                    if (Array.isArray(alias.collectionURL)) {
                        aliasEntry.collectionURL = alias.collectionURL[0];
                    } else {
                        aliasEntry.collectionURL = alias.collectionURL;
                    }
                }
                
                if (!isPlaceholderValue(alias.packageName)) {
                    if (Array.isArray(alias.packageName)) {
                        aliasEntry.packageName = alias.packageName[0];
                    } else {
                        aliasEntry.packageName = alias.packageName;
                    }
                }
                
                if (alias.programRoutines && alias.programRoutines !== '' && alias.programRoutines !== 'unknown' && alias.programRoutines !== 'n/a') {
                    if (Array.isArray(alias.programRoutines)) {
                        aliasEntry.programRoutines = alias.programRoutines[0];
                    } else {
                        aliasEntry.programRoutines = alias.programRoutines;
                    }
                }
                
                if (alias.programFiles && alias.programFiles !== '' && alias.programFiles !== 'unknown' && alias.programFiles !== 'n/a') {
                    if (Array.isArray(alias.programFiles)) {
                        aliasEntry.programFiles = alias.programFiles[0];
                    } else {
                        aliasEntry.programFiles = alias.programFiles;
                    }
                }
                
                if (alias.modules && alias.modules !== '' && alias.modules !== 'unknown' && alias.modules !== 'n/a') {
                    if (Array.isArray(alias.modules)) {
                        aliasEntry.modules = alias.modules[0];
                    } else {
                        aliasEntry.modules = alias.modules;
                    }
                }
                
                if (alias.repo && alias.repo !== '' && alias.repo !== 'unknown' && alias.repo !== 'n/a') {
                    if (Array.isArray(alias.repo)) {
                        aliasEntry.repo = alias.repo[0];
                    } else {
                        aliasEntry.repo = alias.repo;
                    }
                }

                // Only add the entry if it has at least some properties
                if (Object.keys(aliasEntry).length > 0) {
                    currentConsolidatedData.push(aliasEntry);
                }
            });

            // Clear the CPE input and show modal
            const cpeInput = document.getElementById('cpeBaseString');
            cpeInput.value = 'cpe:2.3:';
            handleCpeInput(cpeInput); // Initialize the display
            populateExistingCpeDropdown();
            updateConsolidatedOutput();
            document.getElementById('outputModal').style.display = 'flex';
            
            // Initialize button state
            updateModalButtonState();
            
            // Initialize draggable functionality
            makeDraggable();
        }

        function populateExistingCpeDropdown() {
            const select = document.getElementById('existingCpeSelect');
            select.innerHTML = '<option value="">Or select from existing CPE strings...</option>';

            // Use DataManager's confirmed mapping dataset
            if (!DataManager || !DataManager.datasets || !DataManager.datasets.confirmedMapping) {
                return;
            }

            const existingCpeStrings = new Set();

            // Collect all existing CPE base strings from confirmed mappings
            DataManager.datasets.confirmedMapping.forEach(mapping => {
                // Support both property name formats for compatibility
                const cpeString = mapping.cpeBaseString || mapping.cpe_base_string;
                if (!cpeString) {
                    console.warn('Missing CPE base string in confirmed mapping:', mapping);
                    return;
                }
                existingCpeStrings.add(cpeString);
            });

            // Add options to dropdown, sorted alphabetically
            Array.from(existingCpeStrings).sort().forEach(cpeString => {
                const option = document.createElement('option');
                option.value = cpeString;
                option.textContent = cpeString;
                select.appendChild(option);
            });
        }

        function selectExistingCpe() {
            const select = document.getElementById('existingCpeSelect');
            const input = document.getElementById('cpeBaseString');
            
            if (select.value) {
                // Ensure CPE base string format when selecting from dropdown
                input.value = ensureCpeBaseString(select.value);
                handleCpeInput(input); // Trigger validation and update
            }
        }

        function updateConsolidatedOutput() {
            if (!currentConsolidatedData) return;

            const input = document.getElementById('cpeBaseString');
            const inputValue = input.value.trim();
            
            // Get the final CPE (either generated or validated input)
            const finalCpe = input.getAttribute('data-final-cpe') || inputValue;
            
            let outputData;
            
            if (finalCpe && finalCpe.startsWith('cpe:2.3:')) {
                // Get existing aliases for this CPE base string
                const existingAliases = getExistingAliasesForCpe(finalCpe);
                
                // Combine existing aliases with new ones
                const allAliases = [...existingAliases, ...currentConsolidatedData];
                
                // Include cpeBaseString in the structure
                outputData = {
                    "cpeBaseString": finalCpe,
                    "aliases": allAliases
                };
            } else {
                // No valid CPE base string
                outputData = {
                    "aliases": currentConsolidatedData
                };
            }

            // Use JSON.stringify with proper replacer to handle escaping
            const jsonOutput = JSON.stringify(outputData, (key, value) => {
                // Ensure proper JSON string escaping for all string values
                if (typeof value === 'string') {
                    // JSON.stringify already handles proper escaping, but let's be explicit about CPE strings
                    return value;
                }
                return value;
            }, 2);
            
            document.getElementById('outputContent').textContent = jsonOutput;
        }

        function getExistingAliasesForCpe(cpeBaseString) {
            // Modal now only operates on confirmed mappings with CPE strings
            if (!DataManager.confirmedMapping) return [];

            const existingAliases = [];

            DataManager.confirmedMapping.forEach(alias => {
                // Check if this alias has the matching CPE base string
                if (!alias.cpeBaseString) {
                    throw new Error(`Missing required cpeBaseString in confirmed mapping alias: ${JSON.stringify(alias)}`);
                }
                if (alias.cpeBaseString === cpeBaseString) {
                    if (mapping.aliases) {
                        // Add all aliases from this mapping
                        mapping.aliases.forEach(alias => {
                            // Clean the alias - remove internal fields and ensure string properties
                            const cleanAlias = {};
                            
                            ['vendor', 'product', 'version', 'update', 'edition', 'language', 'sw_edition', 'target_sw', 'target_hw', 'other'].forEach(prop => {
                                if (alias[prop] && alias[prop] !== '' && alias[prop] !== 'unknown' && alias[prop] !== 'n/a') {
                                    if (Array.isArray(alias[prop])) {
                                        cleanAlias[prop] = alias[prop][0];
                                    } else {
                                        cleanAlias[prop] = alias[prop];
                                    }
                                }
                            });

                            // Handle special properties
                            if (alias.platform && alias.platform !== '' && alias.platform !== 'unknown' && alias.platform !== 'n/a') {
                                if (Array.isArray(alias.platform)) {
                                    cleanAlias.platform = alias.platform[0];
                                } else {
                                    cleanAlias.platform = alias.platform;
                                }
                            }
                            
                            ['collectionURL', 'packageName', 'programRoutines', 'programFiles', 'modules', 'repo'].forEach(prop => {
                                if (alias[prop] && alias[prop] !== '' && alias[prop] !== 'unknown' && alias[prop] !== 'n/a') {
                                    if (Array.isArray(alias[prop])) {
                                        cleanAlias[prop] = alias[prop][0];
                                    } else {
                                        cleanAlias[prop] = alias[prop];
                                    }
                                }
                            });

                            if (Object.keys(cleanAlias).length > 0) {
                                existingAliases.push(cleanAlias);
                            }
                        });
                    }
                }
                
                // Also check individual aliases with cpeBaseString
                if (mapping.aliases) {
                    mapping.aliases.forEach(alias => {
                        if (!alias.cpe_base_string) {
                            throw new Error(`Missing required cpe_base_string in alias: ${JSON.stringify(alias)}`);
                        }
                        if (alias.cpe_base_string === cpeBaseString) {
                            const cleanAlias = {};
                            
                            ['vendor', 'product', 'version', 'update', 'edition', 'language', 'sw_edition', 'target_sw', 'target_hw', 'other'].forEach(prop => {
                                if (alias[prop] && alias[prop] !== '' && alias[prop] !== 'unknown' && alias[prop] !== 'n/a') {
                                    if (Array.isArray(alias[prop])) {
                                        cleanAlias[prop] = alias[prop][0];
                                    } else {
                                        cleanAlias[prop] = alias[prop];
                                    }
                                }
                            });

                            if (alias.platform && alias.platform !== '' && alias.platform !== 'unknown' && alias.platform !== 'n/a') {
                                if (Array.isArray(alias.platform)) {
                                    cleanAlias.platform = alias.platform[0];
                                } else {
                                    cleanAlias.platform = alias.platform;
                                }
                            }

                            ['collectionURL', 'packageName', 'programRoutines', 'programFiles', 'modules', 'repo'].forEach(prop => {
                                if (alias[prop] && alias[prop] !== '' && alias[prop] !== 'unknown' && alias[prop] !== 'n/a') {
                                    if (Array.isArray(alias[prop])) {
                                        cleanAlias[prop] = alias[prop][0];
                                    } else {
                                        cleanAlias[prop] = alias[prop];
                                    }
                                }
                            });

                            if (Object.keys(cleanAlias).length > 0) {
                                existingAliases.push(cleanAlias);
                            }
                        }
                    });
                }
            });

            return existingAliases;
        }

        function closeOutputModal() {
            document.getElementById('outputModal').style.display = 'none';
            currentConsolidatedData = null;
        }

        function updateConfirmedMappings() {
            try {
                // Get the CPE base string from input
                const cpeInput = document.getElementById('cpeBaseString');
                let cpeBaseString = cpeInput.value.trim();
                
                // Normalize the CPE string
                cpeBaseString = normalizeCpeString(cpeBaseString);
                
                // Ensure CPE base string format: version and update must be wildcards
                cpeBaseString = ensureCpeBaseString(cpeBaseString);
                
                // Double-check validation (should already be valid due to button state)
                const validation = validateCpeString(cpeBaseString);
                if (!validation.valid) {
                    console.error('Button should be disabled for invalid CPE:', validation);
                    return; // Exit silently since button should be disabled
                }
                
                // Double-check aliases selection (should already have aliases due to button state)
                if (selectedAliases.size === 0) {
                    console.error('Button should be disabled when no aliases selected');
                    return; // Exit silently since button should be disabled
                }
                
                const updateBtn = document.getElementById('outputModal').querySelector('.modal-btn-primary');
                const originalText = updateBtn.textContent;
                
                // Show processing overlay
                showProcessingOverlay(
                    'Updating Confirmed Mappings',
                    `Processing ${selectedAliases.size} selected aliases...`
                );
                
                // Also update button state
                updateBtn.textContent = 'Processing...';
                updateBtn.disabled = true;
                
                // Use setTimeout to allow overlay to render, then process asynchronously
                setTimeout(async () => {
                    await processSelectedAliasesAsync(cpeBaseString, updateBtn, originalText);
                }, 100);
                
            } catch (error) {
                console.error('updateConfirmedMappings failed:', error);
                
                // Hide processing overlay
                hideProcessingOverlay();
                
                const updateBtn = document.getElementById('outputModal').querySelector('.modal-btn-primary');
                
                // Show error feedback
                updateBtn.textContent = '‚úó Update Failed';
                updateBtn.style.background = '#ff4444';
                
                // Reset after 3 seconds
                setTimeout(() => {
                    updateBtn.textContent = 'Update Confirmed Mappings';
                    updateBtn.style.background = '';
                    updateBtn.disabled = false;
                }, 3000);
                
                // Show error to user
                alert(`Update failed: ${error.message}`);
            }
        }

        // Async processing function that yields to UI thread
        async function processSelectedAliasesAsync(cpeBaseString, updateBtn, originalText) {
            try {
                let successCount = 0;
                let errorCount = 0;
                const errors = [];
                
                console.log(`Processing ${selectedAliases.size} selected aliases for CPE: ${cpeBaseString}`);
                console.log('Selected aliases:', Array.from(selectedAliases));
                
                const aliasArray = Array.from(selectedAliases);
                
                for (let i = 0; i < aliasArray.length; i++) {
                    const selectionKey = aliasArray[i];
                    
                    // Parse the selection key: "id:sourceDataset"
                    const [aliasId, sourceDataset] = selectionKey.split(':');
                    const numericId = parseInt(aliasId);
                    
                    console.log(`Processing alias ${numericId} from ${sourceDataset} (attempt ${i + 1}/${aliasArray.length})`);
                    
                    // Update progress
                    const currentProgress = (i / aliasArray.length) * 100;
                    updateProcessingProgress(
                        currentProgress,
                        `Processing alias ${i + 1} of ${aliasArray.length}`
                    );
                    
                    // Use DataManager helper function to move the alias
                    const result = DataManager.mergeWithConfirmed(numericId, sourceDataset, cpeBaseString);
                    
                    if (result.success) {
                        successCount++;
                        console.log(`‚úì Successfully processed alias ${numericId} (${successCount}/${aliasArray.length})`);
                    } else {
                        errorCount++;
                        errors.push(`ID ${aliasId}: ${result.error}`);
                        console.error(`‚úó Failed to process alias ${numericId}: ${result.error}`);
                    }
                    
                    // Yield control back to UI thread after each alias
                    if (i < aliasArray.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                // Update to 100% complete
                updateProcessingProgress(100, `Completed: ${successCount} successful, ${errorCount} errors`);
                
                console.log(`Final processing results: ${successCount} successful, ${errorCount} errors`);
                console.log('Processing summary:', { 
                    totalSelected: aliasArray.length, 
                    successful: successCount, 
                    errors: errorCount,
                    errorDetails: errors 
                });
                
                // Show results
                if (errorCount === 0) {
                    updateBtn.textContent = `‚úì Updated ${successCount} aliases!`;
                    updateBtn.style.background = '#4CAF50';
                    
                    // Update overlay message for refresh phase
                    const messageElement = document.getElementById('processingMessage');
                    messageElement.textContent = 'Refreshing display and updating statistics...';
                    
                    // Yield before refresh to show message update
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Refresh the display and stats to show updated data
                    updateStatsFromDataManager();
                    const displayResult = updateDatasetDisplay(['confirmedMapping', 'unconfirmedAliases', 'sourceDataConcernAliases']);
                    if (!displayResult.success) {
                        console.warn(`Display refresh failed: ${displayResult.error}`);
                    }
                    
                    // Hide overlay and clean up after short delay
                    setTimeout(() => {
                        hideProcessingOverlay();
                        selectedAliases.clear();
                        updateSelectionPanel();
                        closeOutputModal();
                        updateBtn.textContent = originalText;
                        updateBtn.style.background = '';
                        updateBtn.disabled = false;
                    }, 1500);
                } else {
                    hideProcessingOverlay();
                    throw new Error(`${errorCount} errors occurred: ${errors.join('; ')}`);
                }
                
            } catch (error) {
                console.error('processSelectedAliasesAsync failed:', error);
                
                // Hide processing overlay
                hideProcessingOverlay();
                
                // Show error feedback
                updateBtn.textContent = '‚úó Update Failed';
                updateBtn.style.background = '#ff4444';
                
                // Reset after 3 seconds
                setTimeout(() => {
                    updateBtn.textContent = 'Update Confirmed Mappings';
                    updateBtn.style.background = '';
                    updateBtn.disabled = false;
                    // Re-validate button state
                    updateModalButtonState();
                }, 3000);
                
                // Log error instead of showing alert
                console.error(`Update failed: ${error.message}`);
            }
        }

        // Store alias data when displaying
        function storeCurrentAliasData(aliases) {
            currentAliasData = aliases;
            selectedAliases.clear();
            updateSelectionPanel();
        }

        // Modal interaction enhancements for confirmed mappings
        function showModalConfirmed(confirmedMapping) {
            // Show modal specific to confirmed mapping data
            const modal = document.getElementById('outputModal');
            const content = document.getElementById('outputContent');
            
            content.textContent = JSON.stringify({
                "modal": "confirmed mapping data",
                "cve": confirmedMapping.cve,
                "platform": confirmedMapping.platform,
                "aliases": confirmedMapping.aliases
            }, null, 2);
            
            modal.style.display = 'flex';
        }

        function openModalConfirmed(mappingData) {
            // Open modal with confirmed mapping context
            const modalData = {
                "confirmedMappings": mappingData,
                "enhanced": true
            };
            showModalConfirmed(modalData);
        }

        function populateModalConfirmed(data) {
            // Populate modal with data from confirmedMappings array
            if (data && data.confirmedMappings) {
                data.confirmedMappings.forEach(mapping => {
                    // Modal data confirmedMappings processing
                    console.log('Modal processing:', mapping);
                });
            }
        }
    </script>

    <!-- Selection Panel -->
    <div class="selection-panel white-card" id="selectionPanel">
        <h4>Selected Aliases (<span id="selectionCount">0</span>)</h4>
        <div class="selection-list" id="selectionList"></div>
        <button class="consolidate-btn" id="consolidateBtn" onclick="consolidateAliases()">
            Update Confirmed Mappings
        </button>
    </div>

    <!-- Output Modal -->
    <div class="output-modal" id="outputModal">
        <div class="output-modal-content white-card" id="modalContent">
            <div class="modal-header" id="modalHeader">
                <h3>Update Confirmed Mappings</h3>
            </div>
            <div style="margin-bottom: 16px;">
                <label for="cpeBaseString" style="display: block; margin-bottom: 4px; font-weight: 500;">CPE Base String:</label>
                
                <!-- CPE Builder Input -->
                <div style="margin-bottom: 6px;">
                    <input type="text" id="cpeBaseString" placeholder="a:vendor:product" 
                           class="code-input"
                           oninput="handleCpeInput(this)"
                           onkeydown="handleCpeKeydown(event)">
                    <div id="cpeValidationMessage" style="font-size: 0.75em; margin-top: 2px; height: 18px; overflow: hidden; line-height: 1.2;"></div>
                    <div id="cpePreview" class="code-preview" style="height: 14px; overflow: hidden;"></div>
                </div>
                
                <!-- Existing CPE Dropdown -->
                <div>
                    <select id="existingCpeSelect" 
                            onchange="selectExistingCpe()" 
                            class="form-select"
                            style="width: 100%;">
                        <option value="">Or select from existing CPE strings...</option>
                    </select>
                </div>
            </div>
            <pre id="outputContent" class="code-output"></pre>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-primary" onclick="updateConfirmedMappings()">Update Confirmed Mappings</button>
                <button class="modal-btn modal-btn-secondary" onclick="closeOutputModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Processing Overlay (positioned at body level for maximum z-index effectiveness) -->
    <div id="processingOverlay" class="processing-overlay">
        <div class="processing-card">
            <div class="processing-spinner"></div>
            <div id="processingTitle" class="processing-title">Processing Data</div>
            <div id="processingMessage" class="processing-message">Please wait while we process your request...</div>
            <div class="processing-progress">
                <div id="processingProgressBar" class="processing-progress-bar" style="width: 0%;"></div>
            </div>
            <div id="processingDetails" class="processing-details"></div>
        </div>
    </div>

</body>
</html>
