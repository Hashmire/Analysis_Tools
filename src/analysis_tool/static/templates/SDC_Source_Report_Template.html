<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hashmire/Analysis_Tools {{TOOL_VERSION}} - Source Data Concern Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- SDC Dashboard Styles -->
    <link rel="stylesheet" href="css/sdc_dashboard.css">
</head>
<body>
    <div id="main_container_01" class="container-fluid">
        <!-- Page Header Section -->
        <div id="ph_section_01" class="header">
            <h1 class="dashboard-title">Source Data Concern Dashboard</h1>
            <p id="ph_subtitle_01">
                CVE List Data Contribution Review for CPE Automation <br />
                Hashmire/Analysis_Tools {{TOOL_VERSION}}
            </p>
        </div>

        <!-- Report Status and Documentation Section -->
        <div id="rl_section_01" class="file-selector">            
            <!-- Status Bar -->
            <div id="rl_content_01" class="file-input-container">
                <div class="status-bar-wrapper">
                    <div class="status-bar" id="status-bar" style="display: block;">
                        <div class="status-filename" id="status-filename">Source Data Concern Report (Pre-loaded)</div>
                        <div class="status-details">
                            <div class="status-item">
                                <span>Generated: <span id="generation-time">--</span></span>
                            </div>
                            <div class="status-item">
                                <span id="file-size">-- KB</span> ‚Ä¢ <span>Loaded <span id="load-time">--</span></span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Documentation Toggle - Right Aligned -->
                <div class="doc-toggle" onclick="toggleDocumentation()">
                    <div class="doc-header">
                        <div class="doc-header-content">
                            <div class="doc-icon">‚ÑπÔ∏è</div>
                            <div>
                                <h3 class="doc-title">What am I looking at?</h3>
                                <p class="doc-subtitle">Click to learn how to use this dashboard</p>
                            </div>
                        </div>
                        <div class="doc-chevron" id="doc-chevron">‚ñº</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Documentation Content Section -->
        <div class="documentation-content" id="documentation-content">
            <div class="doc-intro">
                <strong>Overview:</strong>
                <p>
                    The Source Data Concern Dashboard is designed to help CVE Program stakeholders systematically review and refine the data they have contributed to CVE records for improved platform identification automation. 
                    Targeting <a href="https://github.com/Hashmire/Analysis_Tools/blob/main/documentation/cpe_automation_challenges.md#problem-domain-3-source-data-contribution-usefulness" target="_blank">Problem Domain #3 Source Data Contribution Usefulness</a>, this dashboard guides organizations on how they may improve the usefulness of platform identification data they provide.
                    The dashboard displays and organizes analysis of source data contributions within CVE 5.X formatted records and identifies specific data quality concerns that may exascerbate platform automation challenges related to <a href="https://github.com/Hashmire/Analysis_Tools/blob/main/documentation/cpe_automation_challenges.md#problem-domain-1---cpe-base-string-determination" target="_blank">CPE Base String Determination</a> and <a href="https://github.com/Hashmire/Analysis_Tools/blob/main/documentation/cpe_automation_challenges.md#problem-domain-2-CPE-Applicability-Statement-Generation" target="_blank">CPE Applicability Statement Generation</a>.
                </p>
                <strong>Goals:</strong>
                <p>
                    Dramatically improve the usefulness of platform identification data within the CVE List. This goal is limited based on the active involvement and response of external data contributors. <br />
                    Dramatically reduce the amount of customized parsing and post-processing required by downstream consumers of CVE data for all use cases.
                </p>
                <strong>Feedback:</strong>
                <p>
                    For technical issues, feature requests, or questions; please visit the <a href="https://github.com/Hashmire/Analysis_Tools/issues" target="_blank">Repository Issues page</a>. <br />
                    Community feedback and contributions to improve the dashboard's functionality and user experience are always encouraged!
                </p>
            </div>

            <div class="doc-sections">
                <div class="doc-section">
                    <h4>üéØ How to Use</h4>
                    <ul>
                        <li><strong>Review Overview</strong> - Examine the overview statistics cards showing total CVEs, platform entries, and concern distribution</li>
                        <li><strong>Navigate Sources</strong> - Use the search field to filter sources or browse all source cards sorted by concern count</li>
                        <li><strong>Examine Source Details</strong> - Review pie charts and concern type breakdowns for each source</li>
                        <li><strong>Explore CVE Records</strong> - Expand "View CVE Entries" sections and click CVE cards for detailed concern analysis</li>
                        <li><strong>Review Detailed Concerns</strong> - Click concern badges to open detailed analysis of identified platform entry concerns</li>
                    </ul>
                </div>

                <div class="doc-section">
                    <h4>üìä Understanding Source Cards</h4>
                    <ul>
                        <li><strong>Source Statistics</strong> - CVE records processed, platform entries analyzed, and pie charts showing concern distribution</li>
                        <li><strong>Concern Type Analysis</strong> - Top concern types with counts and subcategory breakdowns</li>
                        <li><strong>CVE Entry Details</strong> - Expandable sections showing individual CVE records with concern breakdowns</li>
                        <li><strong>Concern Details</strong> - Each CVE entry contains clickable badges that display granular problem, source data and resolution guidance</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="dashboard-content">
            <!-- Overview Statistics Section -->
            <div id="stats-section-container" class="section" style="margin-top: 0;">
                <details id="overview-stats-details">
                    <summary class="section-header">
                        <div>
                            <h2 id="os_title_01" class="section-title">Overview Statistics</h2>
                            <p id="os_subtitle_01" class="section-subtitle">Comprehensive metrics for source data quality assessment</p>
                        </div>
                        <span class="expand-arrow">‚ñº</span>
                    </summary>
                    <div id="os_content_01" class="section-content">
                        <div id="stats-section" class="stats-grid">
                            <!-- Statistics will be populated here -->
                        </div>
                    </div>
                </details>
            </div>

            <!-- Source Analysis Section -->
            <div id="analysis-section" class="section">
                <div id="sa_header_01" class="section-header">
                    <h2 id="sa_sourceName_01" class="section-title">Source Analysis</h2>
                    <p id="sa_subtitle_01" class="section-subtitle">Detailed source data concerns organized by source with comprehensive CVE analysis and hierarchical concern type breakdown</p>
                </div>
                <div id="sa_content_01" class="section-content">
                    <div class="search-container">
                        <div class="search-wrapper">
                            <input type="text" id="source-search" class="search-input" placeholder="Search sources, detection groups, sub-types, or CVE IDs...">
                            <div class="search-icon">üîç</div>
                        </div>
                        <div class="search-results-summary" id="search-results-summary" style="display: none;">
                            Showing <span id="visible-sources">0</span> of <span id="total-sources">0</span> sources
                        </div>
                        <div class="search-loading" id="search-loading">Searching large dataset</div>
                    </div>
                    <div id="sources-list">
                        <div class="loading">No data loaded</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Data Injection Point -->
    
    <script>
        let dashboardData = null;
        let searchDebounceTimeout = null;
        
        // Documentation toggle functionality
        function toggleDocumentation() {
            const content = document.getElementById('documentation-content');
            const chevron = document.getElementById('doc-chevron');
            
            if (!content || !chevron) {
                console.error('Documentation elements not found:', { content, chevron });
                return;
            }
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                chevron.textContent = '‚ñº';
                chevron.style.transform = 'rotate(0deg)';
            } else {
                content.classList.add('expanded');
                chevron.textContent = '‚ñ≤';
                chevron.style.transform = 'rotate(180deg)';
            }
        }
        

        
        // Concern type display names mapping (aligned with enhanced table categories)
        const concernTypeNames = {
            'placeholderData': 'Placeholder Detection',
            'mathematicalComparators': 'Mathematical Comparator Detection',
            'textComparators': 'Text Comparator Detection',
            'whitespaceIssues': 'Whitespace Detection',
            'invalidCharacters': 'Invalid Character Detection',
            'versionGranularity': 'Version Granularity Detection',
            'overlappingRanges': 'Overlapping Ranges',
            'allVersionsPatterns': 'All Versions Patterns',
            'bloatTextDetection': 'Bloat Text Detection'
        };

        // ===== DISPLAY NAME MAPPING FUNCTIONS =====
        
        /**
         * Generate display names for field-based categories
         */
        function getFieldDisplayName(fieldKey, detectionType) {
            return `${fieldKey} ${detectionType}`;
        }
        
        /**
         * Generate display names for whitespace categories
         */
        function getWhitespaceDisplayName(whitespaceType) {
            const whitespaceDisplayNames = {
                'leading': 'Leading Whitespace',
                'trailing': 'Trailing Whitespace',
                'excessive': 'Excessive Whitespace'
            };
            // Presentation layer: Display friendly name or raw value for graceful UI
            return whitespaceDisplayNames[whitespaceType] || whitespaceType;
        }
        
        // ===== COMPREHENSIVE CONCERN CATEGORIZATION SYSTEM =====
        
        /**
         * Field classification utilities for consistent categorization
         */
        function isCPEBaseField(field, cpeFields = ['vendor', 'product', 'packageName']) {
            if (!cpeFields || !Array.isArray(cpeFields)) {
                cpeFields = ['vendor', 'product', 'packageName'];
            }
            return cpeFields.some(cpeField => 
                field === cpeField || field.startsWith(`${cpeField}[`) || field.startsWith('platforms[')
            );
        }
        
        function isVersionField(field) {
            return field.includes('version') || 
                   field.includes('lessThan') || 
                   field.includes('changes[') ||
                   field.includes('.at');
        }
        
        /**
         * Unified field-based categorization pattern for concern types that span multiple domains
         */
        function categorizeByFieldDomain(concerns, customCPEFields = null) {
            const categories = {
                'CPE Base String Issues': [],
                'Version Parsing Issues': []
            };
            
            concerns.forEach(concern => {
                // Presentation layer: Extract field safely for categorization display
                const field = concern.field || '';
                
                if (isCPEBaseField(field, customCPEFields)) {
                    categories['CPE Base String Issues'].push(concern);
                } else if (isVersionField(field)) {
                    categories['Version Parsing Issues'].push(concern);
                } else {
                    // Log error and continue processing without categorizing unrecognized fields
                    console.error(`Unknown field domain in concern - skipping categorization:`, {
                        field: field,
                        concernType: 'fieldDomain',
                        sourceValue: concern.sourceValue,
                        message: 'Field domain not recognized by frontend categorization logic. Continuing without categorization.'
                    });
                }
            });
            
            return categories;
        }
        
        /**
         * Categorize Text Comparator concerns into semantic sub-categories (Version-focused, no fallbacks)
         */
        function categorizeTextComparators(concerns) {
            const categories = {};
            
            concerns.forEach(concern => {
                const patternType = concern.detectedPattern?.patternType;
                
                if (patternType) {
                    // Use backend-provided pattern type for categorization
                    if (!categories[patternType]) {
                        categories[patternType] = [];
                    }
                    categories[patternType].push(concern);
                } else {
                    // Log error and continue processing without categorizing malformed concerns
                    console.error(`Text comparator concern missing patternType - skipping categorization:`, {
                        field: concern.field,
                        sourceValue: concern.sourceValue,
                        detectedPattern: concern.detectedPattern,
                        message: 'Concern processed by backend without patternType assignment. Continuing without categorization.'
                    });
                }
            });
            
            return categories;
        }
        
        /**
         * Categorize Placeholder Data concerns into field-based sub-categories
         */
        function categorizePlaceholderData(concerns) {
            const categories = {};
            const fieldKeys = ['vendor', 'product', 'platforms', 'version', 'lessThan', 'lessThanOrEqual', 'changes', 'packageName'];
            
            // Initialize categories with display names
            fieldKeys.forEach(key => {
                categories[getFieldDisplayName(key, 'Placeholder')] = [];
            });
            
            concerns.forEach(concern => {
                const field = concern.field || '';
                
                if (field === 'vendor') {
                    categories[getFieldDisplayName('vendor', 'Placeholder')].push(concern);
                } else if (field === 'product') {
                    categories[getFieldDisplayName('product', 'Placeholder')].push(concern);
                } else if (field === 'packageName') {
                    categories[getFieldDisplayName('packageName', 'Placeholder')].push(concern);
                } else if (field.startsWith('platforms[')) {
                    categories[getFieldDisplayName('platforms', 'Placeholder')].push(concern);
                } else if (field === 'version') {
                    categories[getFieldDisplayName('version', 'Placeholder')].push(concern);
                } else if (field === 'lessThan') {
                    categories[getFieldDisplayName('lessThan', 'Placeholder')].push(concern);
                } else if (field === 'lessThanOrEqual') {
                    categories[getFieldDisplayName('lessThanOrEqual', 'Placeholder')].push(concern);
                } else if (field.includes('changes[') && field.includes('.at')) {
                    categories[getFieldDisplayName('changes', 'Placeholder')].push(concern);
                } else if (isVersionField(field)) {
                    // Presentation layer: Categorize unknown version fields for graceful display
                    categories[getFieldDisplayName('version', 'Placeholder')].push(concern);
                } else {
                    // Log error and continue processing without categorizing unrecognized fields
                    console.error(`Unknown field type in placeholder detection - skipping categorization:`, {
                        field: field,
                        concernType: 'placeholderData',
                        sourceValue: concern.sourceValue,
                        message: 'Field type not recognized by frontend categorization logic. Continuing without categorization.'
                    });
                }
            });
            
            return categories;
        }
        
        /**
         * Categorize Mathematical Comparator concerns into field-based sub-categories
         */
        function categorizeMathematicalComparators(concerns) {
            const categories = {};
            const fieldKeys = ['vendor', 'product', 'platforms', 'version', 'lessThan', 'lessThanOrEqual', 'changes', 'packageName'];
            
            // Initialize categories with display names
            fieldKeys.forEach(key => {
                categories[getFieldDisplayName(key, 'Comparators')] = [];
            });
            
            concerns.forEach(concern => {
                const field = concern.field || '';
                
                if (field === 'vendor') {
                    categories[getFieldDisplayName('vendor', 'Comparators')].push(concern);
                } else if (field === 'product') {
                    categories[getFieldDisplayName('product', 'Comparators')].push(concern);
                } else if (field === 'packageName') {
                    categories[getFieldDisplayName('packageName', 'Comparators')].push(concern);
                } else if (field.startsWith('platforms[')) {
                    categories[getFieldDisplayName('platforms', 'Comparators')].push(concern);
                } else if (field === 'version') {
                    categories[getFieldDisplayName('version', 'Comparators')].push(concern);
                } else if (field === 'lessThan') {
                    categories[getFieldDisplayName('lessThan', 'Comparators')].push(concern);
                } else if (field === 'lessThanOrEqual') {
                    categories[getFieldDisplayName('lessThanOrEqual', 'Comparators')].push(concern);
                } else if (field.includes('changes[') && field.includes('.at')) {
                    categories[getFieldDisplayName('changes', 'Comparators')].push(concern);
                } else if (isVersionField(field)) {
                    // Presentation layer: Categorize unknown version fields for graceful display
                    categories[getFieldDisplayName('version', 'Comparators')].push(concern);
                } else {
                    // Log error and continue processing without categorizing unrecognized fields
                    console.error(`Unknown field type in mathematical comparator detection - skipping categorization:`, {
                        field: field,
                        concernType: 'mathematicalComparators',
                        sourceValue: concern.sourceValue,
                        message: 'Field type not recognized by frontend categorization logic. Continuing without categorization.'
                    });
                }
            });
            
            return categories;
        }
        
        /**
         * Categorize Whitespace Issues by whitespace pattern type
         */
        function categorizeWhitespaceIssues(concerns) {
            const categories = {};
            const whitespaceTypes = ['leading', 'trailing', 'excessive'];
            
            // Initialize categories with display names
            whitespaceTypes.forEach(type => {
                categories[getWhitespaceDisplayName(type)] = [];
            });
            
            concerns.forEach(concern => {
                const whitespaceTypes = concern.detectedPattern?.whitespaceTypes || [];
                
                // Each concern can have multiple whitespace types, add to all applicable categories
                whitespaceTypes.forEach(type => {
                    const displayName = getWhitespaceDisplayName(type);
                    if (categories[displayName]) {
                        categories[displayName].push(concern);
                    } else {
                        // Log error for unknown whitespace types
                        console.error(`Unknown whitespace type - skipping categorization:`, {
                            whitespaceType: type,
                            concernType: 'whitespaceIssues',
                            field: concern.field,
                            sourceValue: concern.sourceValue,
                            message: 'Whitespace type not recognized by frontend categorization logic.'
                        });
                    }
                });
            });
            
            return categories;
        }
        
        /**
         * Categorize Invalid Character concerns into field-based sub-categories
         */
        function categorizeInvalidCharacters(concerns) {
            const categories = {};
            const fieldKeys = ['vendor', 'product', 'platforms', 'version', 'lessThan', 'lessThanOrEqual', 'changes', 'packageName'];
            
            // Initialize categories with display names
            fieldKeys.forEach(key => {
                categories[getFieldDisplayName(key, 'Invalid Characters')] = [];
            });
            
            concerns.forEach(concern => {
                const field = concern.field || '';
                
                if (field === 'vendor') {
                    categories[getFieldDisplayName('vendor', 'Invalid Characters')].push(concern);
                } else if (field === 'product') {
                    categories[getFieldDisplayName('product', 'Invalid Characters')].push(concern);
                } else if (field === 'packageName') {
                    categories[getFieldDisplayName('packageName', 'Invalid Characters')].push(concern);
                } else if (field.startsWith('platforms[')) {
                    categories[getFieldDisplayName('platforms', 'Invalid Characters')].push(concern);
                } else if (field === 'version') {
                    categories[getFieldDisplayName('version', 'Invalid Characters')].push(concern);
                } else if (field === 'lessThan') {
                    categories[getFieldDisplayName('lessThan', 'Invalid Characters')].push(concern);
                } else if (field === 'lessThanOrEqual') {
                    categories[getFieldDisplayName('lessThanOrEqual', 'Invalid Characters')].push(concern);
                } else if (field.includes('changes[') && field.includes('.at')) {
                    categories[getFieldDisplayName('changes', 'Invalid Characters')].push(concern);
                } else if (isVersionField(field)) {
                    // Presentation layer: Categorize unknown version fields for graceful display
                    categories[getFieldDisplayName('version', 'Invalid Characters')].push(concern);
                } else {
                    // Log error and continue processing without categorizing unrecognized fields
                    console.error(`Unknown field type in invalid character detection - skipping categorization:`, {
                        field: field,
                        concernType: 'invalidCharacters',
                        sourceValue: concern.sourceValue,
                        message: 'Field type not recognized by frontend categorization logic. Continuing without categorization.'
                    });
                }
            });
            
            return categories;
        }
        
        /**
         * Categorize Version Granularity concerns by count of unique granularities
         */
        function categorizeVersionGranularity(concerns) {
            const categories = {};
            
            if (!concerns || concerns.length === 0) {
                return categories;
            }
            
            // Group concerns by base version and count unique granularities per base
            const baseGroups = {};
            
            concerns.forEach(concern => {
                if (!concern.detectedPattern || !concern.detectedPattern.base || !concern.detectedPattern.granularity) {
                    // Handle concerns without proper pattern
                    const categoryName = 'Unknown Granularity';
                    if (!categories[categoryName]) categories[categoryName] = [];
                    categories[categoryName].push(concern);
                    return;
                }
                
                const base = concern.detectedPattern.base;
                const granularity = concern.detectedPattern.granularity;
                
                if (!baseGroups[base]) {
                    baseGroups[base] = {
                        granularities: new Set(),
                        concerns: []
                    };
                }
                
                baseGroups[base].granularities.add(granularity);
                baseGroups[base].concerns.push(concern);
            });
            
            // Create categories based on count of unique granularities
            Object.values(baseGroups).forEach(group => {
                const uniqueGranularityCount = group.granularities.size;
                const categoryName = uniqueGranularityCount === 1 ? 
                    `${uniqueGranularityCount} Granularity` : 
                    `${uniqueGranularityCount} Granularities`;
                
                if (!categories[categoryName]) categories[categoryName] = [];
                categories[categoryName].push(...group.concerns);
            });
            
            return categories;
        }
        
        /**
         * Categorize Overlapping Ranges concerns into scope-based sub-categories
         * Aligned with actual codebase output patterns
         */
        function categorizeOverlappingRanges(concerns) {
            const categories = {
                'Cross-Entry Conflicts': [],
                'Range Boundary Conflicts': [],
                'Identical Ranges': [],
                'Version Array Overlaps': []
            };
            
            if (!concerns || concerns.length === 0) {
                return categories;
            }
            
            concerns.forEach(concern => {
                const overlapType = concern.detectedPattern?.overlapType || '';
                
                // Align with actual codebase output patterns
                if (overlapType === 'wildcard_multiple_bounds') {
                    // Wildcard overlaps with multiple bounds
                    categories['Version Array Overlaps'].push(concern);
                } else if (overlapType === 'identical_ranges') {
                    // Exact duplicate ranges
                    categories['Identical Ranges'].push(concern);
                } else if (['partial_overlap', 'range1_contains_range2', 'range2_contains_range1'].includes(overlapType)) {
                    // Standard numeric range overlaps (but not identical)
                    categories['Range Boundary Conflicts'].push(concern);
                } else {
                    // Default fallback for any other types
                    categories['Cross-Entry Conflicts'].push(concern);
                }
            });
            
            return categories;
        }

        /**
         * Categorize All Versions Patterns concerns into field-based sub-categories
         */
        function categorizeAllVersionsPatterns(concerns) {
            const categories = {};
            const fieldKeys = ['vendor', 'product', 'platforms', 'version', 'lessThan', 'lessThanOrEqual', 'changes', 'packageName'];
            
            // Initialize categories with display names
            fieldKeys.forEach(key => {
                categories[getFieldDisplayName(key, 'All-Versions Pattern')] = [];
            });
            
            concerns.forEach(concern => {
                const field = concern.field || '';
                
                if (field === 'vendor') {
                    categories[getFieldDisplayName('vendor', 'All-Versions Pattern')].push(concern);
                } else if (field === 'product') {
                    categories[getFieldDisplayName('product', 'All-Versions Pattern')].push(concern);
                } else if (field === 'packageName') {
                    categories[getFieldDisplayName('packageName', 'All-Versions Pattern')].push(concern);
                } else if (field.startsWith('platforms[')) {
                    categories[getFieldDisplayName('platforms', 'All-Versions Pattern')].push(concern);
                } else if (field === 'version') {
                    categories[getFieldDisplayName('version', 'All-Versions Pattern')].push(concern);
                } else if (field === 'lessThan') {
                    categories[getFieldDisplayName('lessThan', 'All-Versions Pattern')].push(concern);
                } else if (field === 'lessThanOrEqual') {
                    categories[getFieldDisplayName('lessThanOrEqual', 'All-Versions Pattern')].push(concern);
                } else if (field.includes('changes[') && field.includes('.at')) {
                    categories[getFieldDisplayName('changes', 'All-Versions Pattern')].push(concern);
                } else if (isVersionField(field)) {
                    // Presentation layer: Categorize unknown version fields for graceful display
                    categories[getFieldDisplayName('version', 'All-Versions Pattern')].push(concern);
                } else {
                    // Log error and continue processing without categorizing unrecognized fields
                    console.error(`Unknown field type in all versions pattern detection - skipping categorization:`, {
                        field: field,
                        concernType: 'allVersionsPatterns',
                        sourceValue: concern.sourceValue,
                        message: 'Field type not recognized by frontend categorization logic. Continuing without categorization.'
                    });
                }
            });
            
            return categories;
        }
        
        /**
         * Categorize Bloat Text Detection concerns into field-based sub-categories
         */
        function categorizeBloatTextDetection(concerns) {
            const categories = {};
            const fieldKeys = ['vendor', 'product', 'platforms', 'version', 'lessThan', 'lessThanOrEqual', 'changes', 'packageName'];
            
            // Initialize categories with display names
            fieldKeys.forEach(key => {
                categories[getFieldDisplayName(key, 'Bloat Text')] = [];
            });
            
            concerns.forEach(concern => {
                const field = concern.field || '';
                
                if (field === 'vendor') {
                    categories[getFieldDisplayName('vendor', 'Bloat Text')].push(concern);
                } else if (field === 'product') {
                    categories[getFieldDisplayName('product', 'Bloat Text')].push(concern);
                } else if (field === 'packageName') {
                    categories[getFieldDisplayName('packageName', 'Bloat Text')].push(concern);
                } else if (field.startsWith('platforms[')) {
                    categories[getFieldDisplayName('platforms', 'Bloat Text')].push(concern);
                } else if (field === 'version') {
                    categories[getFieldDisplayName('version', 'Bloat Text')].push(concern);
                } else if (field === 'lessThan') {
                    categories[getFieldDisplayName('lessThan', 'Bloat Text')].push(concern);
                } else if (field === 'lessThanOrEqual') {
                    categories[getFieldDisplayName('lessThanOrEqual', 'Bloat Text')].push(concern);
                } else if (field.includes('changes[') && field.includes('.at')) {
                    categories[getFieldDisplayName('changes', 'Bloat Text')].push(concern);
                } else if (isVersionField(field)) {
                    // Presentation layer: Categorize unknown version fields for graceful display
                    categories[getFieldDisplayName('version', 'Bloat Text')].push(concern);
                } else {
                    // Log error and continue processing without categorizing unrecognized fields
                    console.error(`Unknown field type in bloat text detection - skipping categorization:`, {
                        field: field,
                        concernType: 'bloatTextDetection',
                        sourceValue: concern.sourceValue,
                        message: 'Field type not recognized by frontend categorization logic. Continuing without categorization.'
                    });
                }
            });
            
            return categories;
        }
        
        /**
         * Master function to categorize concerns by type - Unified Architecture
         */
        function categorizeConcernsByType(concernType, concerns) {
            if (!concerns || concerns.length === 0) return {};
            
            // Categorization controller mapping
            const categorizers = {
                'placeholderData': categorizePlaceholderData,
                'mathematicalComparators': categorizeMathematicalComparators,
                'textComparators': categorizeTextComparators,
                'whitespaceIssues': categorizeWhitespaceIssues,
                'invalidCharacters': categorizeInvalidCharacters,
                'versionGranularity': categorizeVersionGranularity,
                'overlappingRanges': categorizeOverlappingRanges,
                'allVersionsPatterns': categorizeAllVersionsPatterns,
                'bloatTextDetection': categorizeBloatTextDetection
            };
            
            const categorizer = categorizers[concernType];
            if (!categorizer) {
                console.warn(`No categorizer found for concern type: ${concernType}`);
                return { 'Uncategorized': concerns };
            }
            
            return categorizer(concerns);
        }
        
        /**
         * Generate HTML for categorized concerns
         */
        function generateCategorizedConcernHTML(categorizedConcerns, concernType) {
            if (!categorizedConcerns || Object.keys(categorizedConcerns).length === 0) {
                return '<div class="no-concerns">No concerns in this category</div>';
            }
            
            const nonEmptyCategories = Object.entries(categorizedConcerns)
                .filter(([category, concerns]) => concerns && concerns.length > 0);
            
            if (nonEmptyCategories.length === 0) {
                return '<div class="no-concerns">No concerns found after categorization</div>';
            }
            
            return nonEmptyCategories.map(([category, concerns]) => `
                <div class="concern-subcategory">
                    <h8 class="subcategory-header">${category} (${concerns.length})</h8>
                    <div class="subcategory-items">
                        ${concerns.map((concern, index) => `
                            <div class="concern-item">
                                <div class="concern-details">
                                    <!-- Presentation layer: Display concern content gracefully across different data formats -->
                                    ${concern.concern || concern.issue || concern.message || 'No details available'}
                                    ${concern.field ? `<span class="concern-field">Field: ${concern.field}</span>` : ''}
                                    ${concern.value ? `<span class="concern-value">Value: "${concern.value}"</span>` : ''}
                                    ${concern.details ? `<div class="concern-context">${concern.details}</div>` : ''}
                                    ${concern.context ? `<div class="concern-context">${concern.context}</div>` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }

        /**
         * Analyze concern details across all entries for a source to get subcategory breakdown
         */
        function analyzeConcernBreakdown(sourceData) {
            const concernBreakdowns = {};
            
            // Iterate through all entries for this source
            sourceData.entries.forEach(entry => {
                if (entry.concerns_detail && entry.concerns_detail.length > 0) {
                    entry.concerns_detail.forEach(detailGroup => {
                        const concernType = detailGroup.concern_type;
                        const concerns = detailGroup.concerns || [];
                        
                        if (!concernBreakdowns[concernType]) {
                            concernBreakdowns[concernType] = [];
                        }
                        
                        // Add all concerns from this entry to the breakdown
                        concernBreakdowns[concernType].push(...concerns);
                    });
                }
            });
            
            // Now categorize each concern type
            const categorizedBreakdowns = {};
            Object.entries(concernBreakdowns).forEach(([concernType, concerns]) => {
                categorizedBreakdowns[concernType] = categorizeConcernsByType(concernType, concerns);
            });
            
            return categorizedBreakdowns;
        }
        
        /**
         * Generate subcategory summary for a concern type
         */
        function generateSubcategorySummary(concernType, categorizedConcerns) {
            if (!categorizedConcerns || Object.keys(categorizedConcerns).length === 0) {
                return '';
            }
            
            const nonEmptyCategories = Object.entries(categorizedConcerns)
                .filter(([category, concerns]) => concerns && concerns.length > 0)
                .sort((a, b) => b[1].length - a[1].length); // Sort by count descending
            
            if (nonEmptyCategories.length === 0) {
                return '';
            }
            
            // Calculate total concerns for percentage calculation
            const totalConcerns = nonEmptyCategories.reduce((sum, [, concerns]) => sum + concerns.length, 0);
            
            // Show ALL subcategories with percentages using separate aligned divs
            const summary = nonEmptyCategories
                .map(([category, concerns]) => {
                    const percentage = ((concerns.length / totalConcerns) * 100).toFixed(1);
                    return `<div class="breakdown-line">
                        <span class="breakdown-category">${category}:</span>
                        <span class="breakdown-count">${concerns.length}</span>
                        <span class="breakdown-percent">(${percentage}%)</span>
                    </div>`;
                })
                .join('');
            
            return summary;
        }

        function formatFileSize(bytes) {
            if (!bytes || bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffSecs = Math.floor(diffMs / 1000);
            const diffMins = Math.floor(diffSecs / 60);
            const diffHours = Math.floor(diffMins / 60);
            const diffDays = Math.floor(diffHours / 24);

            if (diffSecs < 60) return 'just now';
            if (diffMins < 60) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
            if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
            return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
        }

        // File loading removed - reports now use pre-injected data only

        function toggleCveDetails(cardId) {
            console.log('toggleCveDetails called with cardId:', cardId);
            const card = document.getElementById(cardId);
            if (!card) {
                console.log('Card not found for ID:', cardId);
                return;
            }
            console.log('Card found, proceeding with toggle');
            
            const container = card.closest('.cve-cards-container');
            const contentDisplay = card.querySelector('.cve-content-display');
            const detailSections = card.querySelectorAll('.cve-section-details');
            const chevron = card.querySelector('.chevron');
            const clickIndicator = card.querySelector('.click-details-indicator span');
            const expandedContent = card.querySelector('.cve-expanded-content');
            
            // Add expanding class for enhanced transition timing
            card.classList.add('expanding');
            
            if (card.classList.contains('expanded')) {
                // Simple collapse: hide content and reset layout cleanly
                if (expandedContent) {
                    expandedContent.style.display = 'none';
                }
                
                // Reset all card states and layout
                const allCards = container.querySelectorAll('.cve-card');
                allCards.forEach(c => {
                    c.classList.remove('moved-down', 'expanding-row');
                });
                
                card.classList.remove('expanded');
                contentDisplay.classList.remove('expanded');
                container.classList.remove('has-expanded');
                
                // Restore collapsed constraints
                card.style.minHeight = '120px';
                card.style.maxHeight = '180px';
                
                // Update UI elements
                chevron.textContent = '‚Øà';
                clickIndicator.textContent = 'Click for details';
                
                // Clean up after transition
                setTimeout(() => {
                    card.classList.remove('expanding');
                }, 350);
                
            } else {
                // First, collapse any other expanded cards in this container
                const otherExpandedCards = container.querySelectorAll('.cve-card.expanded');
                otherExpandedCards.forEach(otherCard => {
                    if (otherCard !== card) {
                        toggleCveDetails(otherCard.id);
                    }
                });
                
                // Calculate row positions based on container width and card arrangement
                const allCards = Array.from(container.querySelectorAll('.cve-card'));
                const cardIndex = allCards.indexOf(card);
                
                // Calculate cards per row based on container width
                const containerWidth = container.clientWidth;
                const cardWidth = Math.floor(containerWidth * 0.30); // 30% width
                const cardMargin = Math.floor(containerWidth * 0.02); // 1% margin each side
                const totalCardWidth = cardWidth + (cardMargin * 2);
                const cardsPerRow = Math.floor(containerWidth / totalCardWidth);
                
                // Find cards in the actual same row
                const currentRow = Math.floor(cardIndex / cardsPerRow);
                const rowStartIndex = currentRow * cardsPerRow;
                const rowEndIndex = Math.min(rowStartIndex + cardsPerRow - 1, allCards.length - 1);
                
                const sameRowCards = [];
                for (let i = rowStartIndex; i <= rowEndIndex; i++) {
                    if (i !== cardIndex && allCards[i]) {
                        sameRowCards.push(allCards[i]);
                    }
                }
                
                // Simple expansion: all changes happen together cleanly
                card.classList.add('expanding-row');
                card.classList.add('expanded');
                contentDisplay.classList.add('expanded');
                
                // Move other cards in the same row
                sameRowCards.forEach(otherCard => {
                    otherCard.classList.add('moved-down');
                });
                
                // Update container and card constraints
                container.classList.add('has-expanded');
                card.style.minHeight = '';
                card.style.maxHeight = '';
                
                // Generate and show content
                generateExpandedCveContent(card, cardId);
                if (expandedContent) {
                    expandedContent.style.display = 'block';
                }
                
                // Update UI elements
                chevron.textContent = '‚Øá';
                clickIndicator.textContent = 'Click to collapse';
                
                // Scroll into view after transition
                setTimeout(() => {
                    card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 350);
                
                // Update UI elements
                chevron.textContent = '‚Øá';
                clickIndicator.textContent = 'Click to collapse';
                
                // Clean up after transition
                setTimeout(() => {
                    card.classList.remove('expanding');
                }, 400);
            }
        }
        
        /**
         * Generate rich expanded content for CVE cards reusing existing categorization logic
         */
        function generateExpandedCveContent(card, cardId) {
            const expandedContent = card.querySelector('.cve-expanded-content');
            if (!expandedContent) return;
            
            // Find the CVE data for this card
            const cveId = card.querySelector('.cve-id').textContent;
            
            if (!dashboardData || !dashboardData.cve_data) {
                expandedContent.innerHTML = '<div class="placeholder-content">No data loaded</div>';
                return;
            }
            
            const cveData = dashboardData.cve_data.find(cve => cve.cve_id === cveId);
            
            if (!cveData || !cveData.platform_entries || cveData.platform_entries.length === 0) {
                expandedContent.innerHTML = '<div class="placeholder-content">No platform entries</div>';
                return;
            }
            
            // Generate sleek platform entry badges with array indices
            let content = `
                <div class="cve-concern-section" data-type="platformEntries">
                    <div class="cve-section-summary">
                        <span class="cve-concern-type">Platform Entries with Concerns:</span>
                        <span class="cve-concern-count">${cveData.platform_entries.length}</span>
                    </div>
                    <div class="cve-section-details show">
                        cve.containers.*.affected[*]
                    </div>
                </div>
                <div class="sdc-entries-flow">`;
            
            cveData.platform_entries.forEach((entry, index) => {
                // Store entry data for modal access
                const entryId = `${cveId}_${entry.table_index}`;
                window.platformEntryData = window.platformEntryData || {};
                window.platformEntryData[entryId] = entry;
                
                // Create compact array index badge
                const concernCount = entry.total_concerns || 0;
                const btnClass = concernCount > 0 ? 'sdc-badge-concerns' : 'sdc-badge-clean';
                
                content += `
                    <button class="sdc-entry-badge ${btnClass}" onclick="showSDCModal('${entryId}')" title="Platform Entry [${entry.table_index}] - ${concernCount} concerns">
                        <span class="sdc-index">[${entry.table_index}]</span>
                        <span class="sdc-count">${concernCount}</span>
                    </button>
                `;
            });
            
            content += '</div>';
            expandedContent.innerHTML = content;
        }
        
        // SDC Modal display function - matches badge modal system structure
        function showSDCModal(entryId) {
            const entry = window.platformEntryData[entryId];
            if (!entry) return;
            
            // Extract CVE ID from entryId (format: "CVE-XXXX-XXXX_tableIndex")
            const cveId = entryId.split('_')[0];
            const modalTitle = `${cveId} | cve.containers.*.affected[${entry.table_index}] | Data Concerns (${entry.total_concerns || 0})`;
            const modalBody = generateSDCModalContent(entry);
            
            // Create and show Bootstrap modal with dashboard theme styling
            const modalHtml = `
                <div class="modal fade" id="sdcModal" tabindex="-1">
                    <div class="modal-dialog modal-xl">
                        <div class="modal-content modal-content-styled">
                            <div class="modal-header modal-header-styled">
                                <h5 class="modal-title modal-title-styled">${modalTitle}</h5>
                                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                            </div>
                            <div class="modal-body modal-body-styled">
                                ${modalBody}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Remove existing modal if any
            const existingModal = document.getElementById('sdcModal');
            if (existingModal) existingModal.remove();
            
            // Add modal to page and show it
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            const modal = new bootstrap.Modal(document.getElementById('sdcModal'));
            modal.show();
        }
        
        function generateSDCModalContent(entry) {
            let content = '';
            
            if (!entry.concerns_detail || entry.concerns_detail.length === 0) {
                content += '<div class="alert alert-success">‚úÖ No concerns detected for this platform entry.</div>';
                return content;
            }
            
            // Create concern tabs like badge modal system
            content += '<div class="sdc-concern-tabs">';
            const concernTypes = {
                'placeholderData': { label: 'üü£ Placeholder Detection', color: '#6f42c1' },
                'mathematicalComparators': { label: 'üü£ Mathematical Comparators', color: '#6f42c1' },
                'textComparators': { label: 'üü£ Text Comparators', color: '#6f42c1' },
                'whitespaceIssues': { label: 'üü£ Whitespace Issues', color: '#6f42c1' },
                'invalidCharacters': { label: 'üü£ Invalid Characters', color: '#6f42c1' },
                'versionGranularity': { label: 'üü£ Version Granularity', color: '#6f42c1' },
                'overlappingRanges': { label: 'üü£ Overlapping Ranges', color: '#6f42c1' },
                'allVersionsPatterns': { label: 'üü£ All Versions Patterns', color: '#6f42c1' },
                'bloatTextDetection': { label: 'üü£ Bloat Text Detection', color: '#6f42c1' }
            };
            
            entry.concerns_detail.forEach((concernGroup, index) => {
                const isActive = index === 0 ? 'active' : '';
                const concernType = concernTypes[concernGroup.concern_type] || { label: concernGroup.concern_type, color: '#6c757d' };
                
                content += `
                    <button class="sdc-tab-btn ${isActive}" onclick="showSDCTab('${concernGroup.concern_type}')" data-tab="${concernGroup.concern_type}">
                        ${concernType.label} (${concernGroup.concerns.length})
                    </button>
                `;
            });
            
            content += '</div>';
            
            // Tab content panels
            content += '<div class="sdc-tab-content">';
            entry.concerns_detail.forEach((concernGroup, index) => {
                const isActive = index === 0 ? 'active' : '';
                content += `
                    <div class="sdc-tab-panel ${isActive}" data-panel="${concernGroup.concern_type}">
                        <div class="sdc-concern-list">
                `;
                
                // Special handling for version granularity - group by base
                if (concernGroup.concern_type === 'versionGranularity') {
                    const baseGroups = {};
                    concernGroup.concerns.forEach(concern => {
                        // Presentation layer: Extract base version for display with fallback
                        const base = concern.detectedPattern?.base || 'unknown';
                        if (!baseGroups[base]) baseGroups[base] = [];
                        baseGroups[base].push(concern);
                    });
                    
                    let issueNumber = 1;
                    Object.entries(baseGroups).forEach(([base, concerns]) => {
                        content += `
                            <div class="sdc-concern-item mb-2 p-2 border rounded sdc-concern-item-styled">
                                <div class="concern-header mb-2">
                                    <div class="d-flex justify-content-between align-items-center">
                                        <h6 class="mb-0 text-danger fw-bold concern-header-styled">Concern #${issueNumber}</h6>
                                    </div>
                                </div>
                                ${generateVersionGranularityGroupContent(base, concerns)}
                            </div>
                        `;
                        issueNumber++;
                    });
                } else {
                    // Standard handling for other concern types
                    concernGroup.concerns.forEach((concern, concernIndex) => {
                        const issueNumber = concernIndex + 1;
                        content += `
                            <div class="sdc-concern-item mb-2 p-2 border rounded sdc-concern-item-styled">
                                <div class="concern-header mb-2">
                                    <div class="d-flex justify-content-between align-items-center">
                                        <h6 class="mb-0 text-danger fw-bold concern-header-styled">Concern #${issueNumber}</h6>
                                    </div>
                                </div>
                                ${generateConcernContent(concernGroup.concern_type, concern)}
                            </div>
                        `;
                    });
                }
                
                content += '</div></div>';
            });
            
            content += '</div>';
            return content;
        }
        
        function showSDCTab(tabName) {
            // Hide all panels and deactivate all tabs
            document.querySelectorAll('.sdc-tab-panel').forEach(panel => panel.classList.remove('active'));
            document.querySelectorAll('.sdc-tab-btn').forEach(btn => btn.classList.remove('active'));
            
            // Show selected panel and activate tab
            const panel = document.querySelector(`[data-panel="${tabName}"]`);
            const tab = document.querySelector(`[data-tab="${tabName}"]`);
            if (panel) panel.classList.add('active');
            if (tab) tab.classList.add('active');
        }
        
        /**
         * Extract version array context information from concern data
         */
        function getVersionContextInfo(concern) {
            if (!concern.sourceValue || typeof concern.sourceValue !== 'object') {
                return '';
            }
            
            // Handle versions array with multiple entries
            if (Array.isArray(concern.sourceValue) && concern.sourceValue.length > 0) {
                const versionIndices = concern.sourceValue
                    .filter(v => v.version_idx !== undefined)
                    .map(v => `[${v.version_idx}]`)
                    .join(', ');
                
                if (versionIndices) {
                    return ` (versions${versionIndices})`;
                }
            }
            
            // Handle single version entry with index
            if (concern.sourceValue.version_idx !== undefined) {
                return ` (versions[${concern.sourceValue.version_idx}])`;
            }
            
            return '';
        }
        
        function generateConcernContent(concernType, concern) {
            // Route to appropriate content generator based on concern type
            switch(concernType) {
                case 'placeholderData':
                    return generatePlaceholderDataContent(concern);
                case 'mathematicalComparators':
                    return generateMathematicalComparatorsContent(concern);
                case 'textComparators':
                    return generateTextComparatorsContent(concern);
                case 'whitespaceIssues':
                    return generateWhitespaceIssuesContent(concern);
                case 'invalidCharacters':
                    return generateInvalidCharactersContent(concern);
                case 'versionGranularity':
                    return generateVersionGranularityContent(concern);
                case 'overlappingRanges':
                    return generateOverlappingRangesContent(concern);
                case 'allVersionsPatterns':
                    return generateAllVersionsPatternsContent(concern);
                case 'bloatTextDetection':
                    return generateBloatTextDetectionContent(concern);
                default:
                    return generateGenericConcernContent(concern);
            }
        }
        
        function generatePlaceholderDataContent(concern) {
            // Determine if this is an array field or regular field
            const isArrayField = concern.field.includes('platforms[');
            
            let problemText = `<code>${concern.field}</code> contains placeholder data which prevents platform identification.`;
            let resolutionText = `Replace placeholder data with an appropriate <code>${concern.field}</code> value.`;
            
            if (isArrayField) {
                problemText = `<code>${concern.field}</code> contains placeholder data which prevents platform identification.`;
                resolutionText = `Replace placeholder data with an appropriate <code>${concern.field}</code> value or leave platforms array empty.`;
            }
            
            // Handle different detectedPattern formats
            let detectedValue = 'placeholder pattern';
            if (typeof concern.detectedPattern === 'string') {
                detectedValue = concern.detectedPattern;
            } else if (concern.detectedPattern && concern.detectedPattern.detectedValue) {
                detectedValue = concern.detectedPattern.detectedValue;
            }
            
            return `
                <div class="sdc-concern-problem mb-2">
                    <strong>Problem:</strong> ${problemText}
                </div>
                <div class="sdc-concern-data mb-2">
                    <strong>Data:</strong> Pattern <code>${detectedValue}</code> detected in <code>${concern.field}</code> <strong>-</strong> <code>"${concern.field}": "${concern.sourceValue}"</code>
                </div>
                <div class="sdc-concern-resolution">
                    <strong>Resolution:</strong> ${resolutionText}
                </div>
            `;
        }
        
        function generateMathematicalComparatorsContent(concern) {
            // Determine problem description based on field type
            const cpeBaseStringFields = ['vendor', 'product', 'packageName'];
            const versionFields = ['version', 'lessThan', 'lessThanOrEqual'];
            const isVersionField = versionFields.some(field => concern.field.includes(field)) || 
                                  concern.field.includes('changes[') && concern.field.includes('.at');
            const isPlatformsField = concern.field.includes('platforms[');
            
            let problemText = `<code>${concern.field}</code> contains mathematical comparators which may impact processing.`;
            let resolutionText = "Remove mathematical comparators from field values.";
            
            if (cpeBaseStringFields.some(field => concern.field.includes(field)) || isPlatformsField) {
                problemText = `<code>${concern.field}</code> contains mathematical comparators which may impact platform identification.`;
                resolutionText = `Remove mathematical comparators within <code>${concern.field}</code> content.`;
            } else if (isVersionField) {
                problemText = `<code>${concern.field}</code> contains mathematical comparators which may impact version identification and CPE-AS generation.`;
                resolutionText = `Use the <code>defaultStatus</code>, <code>version</code>, <code>lessThan</code>, <code>lessThanOrEqual</code>, <code>changes[*].at</code> and/or <code>changes[*].status</code> syntax to precisely represent the intended range boundaries. Example: <code>"version": "&lt;=1.2.3"</code> should become <code>"lessThanOrEqual": "1.2.3"</code>.`;
            }
            
            // Handle different detectedPattern formats
            let detectedValue = 'mathematical comparators';
            if (typeof concern.detectedPattern === 'string') {
                detectedValue = concern.detectedPattern;
            } else if (concern.detectedPattern && concern.detectedPattern.detectedValue) {
                detectedValue = concern.detectedPattern.detectedValue;
            }
            
            return `
                <div class="sdc-concern-problem mb-2">
                    <strong>Problem:</strong> ${problemText}
                </div>
                <div class="sdc-concern-data mb-2">
                    <strong>Data:</strong> Pattern <code>${detectedValue}</code> detected in <code>${concern.field}</code> - <code>"${concern.field}": "${concern.sourceValue}"</code>
                </div>
                <div class="sdc-concern-resolution">
                    <strong>Resolution:</strong> ${resolutionText}
                </div>
            `;
        }
        
        function generateTextComparatorsContent(concern) {
            // Handle different detectedPattern formats
            let detectedValue = 'text comparator';
            if (typeof concern.detectedPattern === 'string') {
                detectedValue = concern.detectedPattern;
            } else if (concern.detectedPattern && concern.detectedPattern.detectedValue) {
                detectedValue = concern.detectedPattern.detectedValue;
            }
            
            return `
                <div class="sdc-concern-problem mb-2">
                    <strong>Problem:</strong> <code>${concern.field}</code> contains text based comparator which may impact version identification and CPE-AS generation.
                </div>
                <div class="sdc-concern-data mb-2">
                    <strong>Data:</strong> Pattern <code>${detectedValue}</code> detected in <code>${concern.field}</code> - <code>"${concern.field}": "${concern.sourceValue}"</code>
                </div>
                <div class="sdc-concern-resolution">
                    <strong>Resolution:</strong> Use <code>defaultStatus</code>, <code>version</code>, <code>lessThan</code>, <code>lessThanOrEqual</code>, <code>changes[*].at</code> syntax for precise boundaries. Example: <code>"version": "before 1.2.3"</code> ‚ûî <code>"lessThan": "1.2.3"</code>
                </div>
            `;
        }
        
        function generateWhitespaceIssuesContent(concern) {
            // Extract whitespace types and replaced text from structured detectedPattern
            let whitespaceType = "whitespace";
            let replacedText = concern.sourceValue;
            
            if (concern.detectedPattern && typeof concern.detectedPattern === 'object') {
                const types = concern.detectedPattern.whitespaceTypes || [];
                replacedText = concern.detectedPattern.replacedText || concern.sourceValue;
                
                if (types.length > 1) {
                    whitespaceType = types.join('/') + ' whitespace';
                } else if (types.length === 1) {
                    whitespaceType = types[0] + ' whitespace';
                }
            } else if (typeof concern.detectedPattern === 'string') {
                whitespaceType = concern.detectedPattern;
            }
            
            let problemText = `<strong><code>${concern.field}</code></strong> has ${whitespaceType} which may impact processing.`;
            let resolutionText = `Remove whitespace from <strong><code>${concern.field}</code></strong> content.`;
            
            // Field-specific problem descriptions
            const versionFields = ['version', 'lessThan', 'lessThanOrEqual'];
            const isVersionField = versionFields.some(field => concern.field.includes(field)) || 
                                  concern.field.includes('changes[') && concern.field.includes('.at');
            
            if (isVersionField) {
                problemText = `<strong><code>${concern.field}</code></strong> has ${whitespaceType} which may impact version identification and CPE-AS generation.`;
            } else {
                problemText = `<strong><code>${concern.field}</code></strong> has ${whitespaceType} which may impact platform identification.`;
            }
            
            return `
                <div class="sdc-concern-problem mb-2">
                    <strong>Problem:</strong> ${problemText}
                </div>
                <div class="sdc-concern-data mb-2">
                    <strong>Data:</strong> <code>${whitespaceType}</code> detected in <code>${concern.field}</code> - <code>Original: "${concern.field}": "${concern.sourceValue}"</code> <code>Processed: "${concern.field}": "${replacedText}"</code>
                </div>
                <div class="sdc-concern-resolution">
                    <strong>Resolution:</strong> ${resolutionText}
                </div>
            `;
        }
        
        function generateInvalidCharactersContent(concern) {
            // Handle different detectedPattern formats for invalid characters
            let invalidChars = 'invalid characters';
            let charDescription = '';
            
            if (typeof concern.detectedPattern === 'string') {
                invalidChars = concern.detectedPattern;
            } else if (concern.detectedPattern && concern.detectedPattern.detectedValue) {
                invalidChars = concern.detectedPattern.detectedValue;
            }
            
            // Make whitespace and special characters more visible
            if (invalidChars === ' ') {
                charDescription = ' (space character)';
                invalidChars = '&nbsp;'; // Use non-breaking space for visibility
            } else if (invalidChars === '\t') {
                charDescription = ' (tab character)';
                invalidChars = '\\t';
            } else if (invalidChars === '\n') {
                charDescription = ' (newline character)';
                invalidChars = '\\n';
            } else if (invalidChars === '\r') {
                charDescription = ' (carriage return)';
                invalidChars = '\\r';
            } else if (invalidChars.length === 1) {
                // For single characters, show the character and its description
                const charCode = invalidChars.charCodeAt(0);
                if (charCode < 32 || charCode > 126) {
                    charDescription = ` (Unicode: U+${charCode.toString(16).padStart(4, '0').toUpperCase()})`;
                }
            }
            
            return `
                <div class="sdc-concern-problem mb-2">
                    <strong>Problem:</strong> <code>${concern.field}</code> contains invalid characters which may impact version identification and CPE-AS generation.
                </div>
                <div class="sdc-concern-data mb-2">
                    <strong>Data:</strong> Invalid character <code class="invalid-char-highlight">${invalidChars}</code>${charDescription} detected in <code>${concern.field}</code> - <code>"${concern.field}": "${concern.sourceValue}"</code>
                </div>
                <div class="sdc-concern-resolution">
                    <strong>Resolution:</strong> Review character usage and remove inappropriate characters from <strong><code>${concern.field}</code></strong> content.
                </div>
            `;
        }
        
        
        function generateVersionGranularityGroupContent(base, concerns) {
            // Extract granularities and create detailed field list
            const fieldDetails = concerns.map(concern => {
                const granularity = concern.detectedPattern?.granularity || '?';
                return `<code>"${concern.field}": "${concern.sourceValue}"</code>`;
            }).join('<br>');
            
            const granularities = concerns.map(c => c.detectedPattern?.granularity || '?');
            const uniqueGranularities = [...new Set(granularities)].sort();
            
            return `
                <div class="sdc-concern-problem mb-2">
                    <strong>Problem:</strong> Version related fields contain granularity differences which may affect platform matching precision.
                </div>
                <div class="sdc-concern-data mb-2">
                    <strong>Data:</strong> Base <code>${base}</code> version group contains ${concerns.length} fields with different granularities:<br>
                    ${fieldDetails}
                </div>
                <div class="sdc-concern-resolution">
                    <strong>Resolution:</strong> Standardize version granularity across all fields within the same base version group for consistent platform matching.
                </div>
            `;
        }
        
        function generateOverlappingRangesContent(concern) {
            const detectedPattern = concern.detectedPattern || {};
            const overlapType = detectedPattern.overlapType || 'overlap';
            
            // Handle wildcard multiple bounds (as generated by codebase)
            if (overlapType === 'wildcard_multiple_bounds') {
                // Build transparent property displays from the actual sourceValue array
                let propertyDisplays = [];
                if (Array.isArray(concern.sourceValue)) {
                    propertyDisplays = concern.sourceValue.map(item => {
                        const source = item.source || 'unknown';
                        let properties = [];
                        
                        // Show actual properties as they exist
                        if (item.version !== undefined) properties.push(`"version": "${item.version}"`);
                        if (item.lessThan !== undefined && item.lessThan !== null) properties.push(`"lessThan": "${item.lessThan}"`);
                        if (item.lessThanOrEqual !== undefined && item.lessThanOrEqual !== null) properties.push(`"lessThanOrEqual": "${item.lessThanOrEqual}"`);
                        if (item.status !== undefined) properties.push(`"status": "${item.status}"`);
                        
                        return `<code>"${source}": { ${properties.join(', ')} }</code>`;
                    });
                }
                
                const propertyDisplay = propertyDisplays.length > 0 
                    ? propertyDisplays.join('<br>')
                    : 'multiple wildcard entries with different bounds';
                
                // Generate dynamic overlap explanation for wildcard case
                let overlapNote = '';
                if (Array.isArray(concern.sourceValue) && concern.sourceValue.length > 1) {
                    const rangeCount = concern.sourceValue.length;
                    const branches = detectedPattern.branches || [];
                    const uniqueBounds = branches.length;
                    
                    // Check if all ranges start with wildcard
                    const allWildcard = concern.sourceValue.every(item => item.version === '*');
                    
                    if (allWildcard && uniqueBounds > 1) {
                        overlapNote = `<div class="mt-2"><em>All ${rangeCount} wildcard ranges overlap because they start from "*" (beginning of time) but have ${uniqueBounds} different upper bounds: ${branches.join(', ')}.</em></div>`;
                    } else if (allWildcard) {
                        overlapNote = `<div class="mt-2"><em>All ${rangeCount} wildcard ranges overlap because they start from "*" with different boundary types.</em></div>`;
                    } else {
                        overlapNote = `<div class="mt-2"><em>All ${rangeCount} ranges overlap due to conflicting version patterns.</em></div>`;
                    }
                }
                
                return `
                    <div class="sdc-concern-problem mb-2">
                        <strong>Problem:</strong> Multiple wildcard patterns create ambiguous range definitions with different upper bounds.
                    </div>
                    <div class="sdc-concern-data mb-2">
                        <strong>Data:</strong> Wildcard usage causing overlapping ranges detected:<br>
                        ${propertyDisplay}
                        ${overlapNote}
                    </div>
                    <div class="sdc-concern-resolution">
                        <strong>Resolution:</strong> Consolidate wildcard patterns or use explicit version ranges to eliminate ambiguity.
                    </div>
                `;
            }
            
            // Handle standard range overlaps (as generated by codebase)
            const range1 = detectedPattern.range1 || 'N/A';
            const range2 = detectedPattern.range2 || 'N/A';
            const range1Source = detectedPattern.range1Source || 'N/A';
            const range2Source = detectedPattern.range2Source || 'N/A';
            
            // Generate human-readable description based on overlap type
            let humanReadableDescription = 'Version range overlap detected';
            if (overlapType === 'identical_ranges') {
                humanReadableDescription = 'Identical version ranges detected';
            } else if (overlapType === 'partial_overlap') {
                humanReadableDescription = 'Partial version range overlap detected';
            } else if (overlapType === 'range1_contains_range2') {
                humanReadableDescription = 'Range containment overlap detected where one range fully contains another';
            } else if (overlapType === 'range2_contains_range1') {
                humanReadableDescription = 'Range containment overlap detected where one range fully contains another';
            }
            
            // Simple overlap indication for standard range cases
            const overlapSources = `${range1Source} ‚Üî ${range2Source}`;
            
            return `
                <div class="sdc-concern-problem mb-2">
                    <strong>Problem:</strong> Overlapping version ranges create ambiguous range definitions which may affect platform matching precision.
                </div>
                <div class="sdc-concern-data mb-2">
                    <strong>Data:</strong> ${humanReadableDescription}:<br>
                    <code>${range1Source}: ${range1}</code><br>
                    <code>${range2Source}: ${range2}</code><br>
                    <em>Overlapping ranges: ${overlapSources}</em>
                </div>
                <div class="sdc-concern-resolution">
                    <strong>Resolution:</strong> Use precise range syntax to eliminate overlapping ranges and improve platform matching accuracy.
                </div>
            `;
        }

        function generateAllVersionsPatternsContent(concern) {
            const detectedValue = concern.detectedPattern?.detectedValue || 'Unknown';
            
            return `
                <div class="sdc-concern-problem mb-2">
                    <strong>Problem:</strong> ${concern.field} contains "all versions" pattern which creates additional downstream parsing complexity and may impact version identification or CPE-AS generation.
                </div>
                <div class="sdc-concern-data mb-2">
                    <strong>Data:</strong> Pattern <strong>${detectedValue}</strong> detected in <strong>${concern.field}</strong> content<br>
                    <code>"${concern.field}": "${concern.sourceValue}"</code>
                </div>
                <div class="sdc-concern-resolution">
                    <strong>Resolution:</strong> Use "*" for consistent representation of "all versions". Example: <code>"${concern.field}": "*"</code>
                </div>
            `;
        }
        
        function generateBloatTextDetectionContent(concern) {
            const detectedValue = concern.detectedPattern?.detectedValue || 'Unknown';
            
            // Enhanced vendor redundancy handling
            if (concern.detectedPattern.patternType === 'vendor_redundancy') {
                const suggestedProduct = concern.sourceValue.replace(detectedValue, '').trim();
                return `
                    <div class="sdc-concern-problem mb-2">
                        <strong>Problem:</strong> Product field contains redundant vendor value which creates additional downstream parsing complexity and may impact platform identification.
                    </div>
                    <div class="sdc-concern-data mb-2">
                        <strong>Data:</strong> Pattern <strong>${detectedValue}</strong> detected in <code>${concern.field}</code> content <code>"${concern.field}": "${concern.sourceValue}"</code>
                    </div>
                    <div class="sdc-concern-resolution">
                        <strong>Resolution:</strong><br>
                        Remove the redundant vendor value from <code>${concern.field}</code>
                    </div>
                `;
            }
            
            return `
                <div class="sdc-concern-problem mb-2">
                    <strong>Problem:</strong> ${concern.field} contains bloat text which creates additional downstream parsing complexity and may impact version identification or CPE-AS generation.
                </div>
                <div class="sdc-concern-data mb-2">
                    <strong>Data:</strong> Pattern <strong>${detectedValue}</strong> detected in <strong>${concern.field}</strong> content<br>
                    <code>"${concern.field}": "${concern.sourceValue}"</code>
                </div>
                <div class="sdc-concern-resolution">
                    <strong>Resolution:</strong> Remove bloat text from version fields. Example: <code>"${concern.field}": "Version 2.011"</code> should be represented as <code>"${concern.field}": "2.011"</code>
                </div>
            `;
        }
        
        function generateGenericConcernContent(concern) {
            return `
                <div class="sdc-concern-problem mb-2">
                    <strong>Problem:</strong> Data quality issue detected
                </div>
                <div class="sdc-concern-data mb-2">
                    <strong>Data:</strong><br>
                    <code>${JSON.stringify(concern)}</code>
                </div>
                <div class="sdc-concern-resolution">
                    <strong>Resolution:</strong> Contact source data provider for correction
                </div>
            `;
        }
        

        // File loading removed - reports now use pre-injected data only
        
        function updateStatusBar(file, data) {
            const statusBar = document.getElementById('status-bar');
            const statusFilename = document.getElementById('status-filename');
            const generationTimeEl = document.getElementById('generation-time');
            const fileSizeEl = document.getElementById('file-size');
            const loadTimeEl = document.getElementById('load-time');
            
            // Set filename
            statusFilename.textContent = file.name;
            
            // Set generation time
            let generationTime = 'Unknown';
            let timeAgo = '';
            
            if (data.metadata && data.metadata.run_started_at) {
                const genDate = new Date(data.metadata.run_started_at);
                generationTime = genDate.toLocaleString();
                timeAgo = ` (${getTimeAgo(genDate)})`;
            }
            
            generationTimeEl.textContent = generationTime + timeAgo;
            
            // Set file size
            const fileSizeKB = (file.size / 1024).toFixed(1);
            fileSizeEl.textContent = `${fileSizeKB} KB`;
            
            // Set load time
            const now = new Date();
            loadTimeEl.textContent = now.toLocaleTimeString();
            
            // Show status bar
            statusBar.style.display = 'block';
        }
        
        function processLoadedData() {
            if (!dashboardData) return;
            
            // Store data globally for expanded content generation
            window.currentData = dashboardData.cve_data;
            
            // Clear previous search index to prevent memory leaks

            
            // Show dashboard content
            document.querySelector('.dashboard-content').style.display = 'block';
            
            // Populate sections
            populateStats();
            populateSources();
            
            // Scroll to dashboard content
            document.querySelector('.dashboard-content').scrollIntoView({ 
                behavior: 'smooth' 
            });
        }
        
        function populateStats() {
            const metadata = dashboardData.metadata;
            const cveData = dashboardData.cve_data;
            
            // Calculate statistics
            const totalCVEs = metadata.total_cves_processed;
            const totalEntries = metadata.total_platform_entries;
            const entriesWithConcerns = metadata.entries_with_concerns;
            const totalConcernTypes = metadata.concern_type_counts ? metadata.concern_type_counts.length : 0;
            const totalConcerns = metadata.concern_type_counts ? 
                metadata.concern_type_counts.reduce((sum, item) => sum + item.count, 0) : 0;
            
            // Count unique sources
            const uniqueSources = new Set();
            cveData.forEach(cve => {
                cve.platform_entries.forEach(entry => {
                    uniqueSources.add(entry.source_id);
                });
            });
            
            const statsSection = document.getElementById('stats-section');
            statsSection.innerHTML = `
                <div id="os_card_01" class="stat-card purple">
                    <div id="os_badge_01" class="stat-number">${totalCVEs}</div>
                    <div class="stat-label">CVE Records</div>
                </div>
                <div id="os_card_02" class="stat-card grey">
                    <div id="os_badge_02" class="stat-number">${totalEntries}</div>
                    <div class="stat-label">Platform Entries</div>
                </div>
                <div id="os_card_03" class="stat-card purple">
                    <div id="os_badge_03" class="stat-number">${totalConcerns}</div>
                    <div class="stat-label">Concerns</div>
                </div>
                <div id="os_card_04" class="stat-card grey">
                    <div id="os_badge_04" class="stat-number">${uniqueSources.size}</div>
                    <div class="stat-label">Unique Sources</div>
                </div>
                <div id="os_card_05" class="stat-card purple">
                    <div id="os_badge_05" class="stat-number">${entriesWithConcerns}</div>
                    <div class="stat-label">Entries with Concerns</div>
                </div>
                <div id="os_card_06" class="stat-card grey">
                    <div id="os_badge_06" class="stat-number">${totalConcernTypes}</div>
                    <div class="stat-label">Concern Types</div>
                </div>
            `;
        }
        
        /**
         * Create a user-friendly display name from source name or source ID
         */
        function createDisplaySourceName(sourceName, sourceId) {
            // If we have a proper source name, use it
            if (sourceName && sourceName !== sourceId && !isUUID(sourceName)) {
                return sourceName;
            }
            
            // If the source name is a UUID or missing, create a friendly name
            if (isUUID(sourceId)) {
                return `Source ${sourceId.substring(0, 8)}...`;
            }
            
            // Fallback to the source ID if it's not a UUID
            return sourceId;
        }
        
        /**
         * Check if a string is a UUID
         */
        function isUUID(str) {
            const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
            return uuidRegex.test(str);
        }
        
        function applyCveCardDynamicSizing() {
            // Apply consistent collapsed constraints to all CVE cards
            const cveCards = document.querySelectorAll('.cve-card');
            
            cveCards.forEach(card => {
                const contentDisplay = card.querySelector('.cve-content-display');
                
                if (!contentDisplay) return;
                
                // Skip if card is already expanded
                if (card.classList.contains('expanded')) {
                    return;
                }
                
                // Apply consistent collapsed constraints
                card.style.minHeight = '120px';
                card.style.maxHeight = '180px';
                
                // Debug logging for development
                if (window.location.search.includes('debug=true')) {
                    console.log(`CVE Card ${card.id}: Applied consistent collapsed dimensions`);
                }
            });
        }
        
        function populateSources() {
            const sourcesList = document.getElementById('sources-list');
            const sourceData = {};
            
            // First pass: Track ALL CVEs processed per source and determine concern status per CVE per source
            dashboardData.cve_data.forEach(cve => {
                const cveSourceConcerns = {}; // Track whether this CVE has concerns for each source
                
                // Check platform entries with concerns
                if (cve.platform_entries && cve.platform_entries.length > 0) {
                    cve.platform_entries.forEach(entry => {
                        if (!sourceData[entry.source_id]) {
                            sourceData[entry.source_id] = {
                                source_id: entry.source_id,
                                source_name: createDisplaySourceName(entry.source_name, entry.source_id),
                                total_concerns: 0,
                                cve_records: new Set(),
                                cve_records_with_concerns: new Set(),
                                cve_records_without_concerns: new Set(),
                                concern_breakdown: {},
                                entries: []
                            };
                        }
                        
                        // Track if this CVE has concerns for this source
                        if (entry.total_concerns > 0) {
                            cveSourceConcerns[entry.source_id] = true;
                        } else if (cveSourceConcerns[entry.source_id] === undefined) {
                            cveSourceConcerns[entry.source_id] = false;
                        }
                    });
                }
                
                // Check platform entries with no concerns (new data structure)
                if (cve.clean_platform_entries && cve.clean_platform_entries.length > 0) {
                    cve.clean_platform_entries.forEach(cleanEntry => {
                        const sourceId = cleanEntry.sourceID;
                        
                        if (!sourceData[sourceId]) {
                            // Use embedded source name if available, otherwise create display name
                            const sourceName = cleanEntry.source_name || createDisplaySourceName(null, sourceId);
                            
                            sourceData[sourceId] = {
                                source_id: sourceId,
                                source_name: sourceName,
                                total_concerns: 0,
                                cve_records: new Set(),
                                cve_records_with_concerns: new Set(),
                                cve_records_without_concerns: new Set(),
                                concern_breakdown: {},
                                entries: []
                            };
                        }
                        
                        // Only mark as no concerns if not already marked as having concerns
                        if (cveSourceConcerns[sourceId] === undefined) {
                            cveSourceConcerns[sourceId] = false;
                        }
                    });
                }
                
                // Now categorize this CVE per source based on overall concern status
                Object.entries(cveSourceConcerns).forEach(([sourceId, hasConcerns]) => {
                    const source = sourceData[sourceId];
                    source.cve_records.add(cve.cve_id);
                    
                    if (hasConcerns) {
                        source.cve_records_with_concerns.add(cve.cve_id);
                    } else {
                        source.cve_records_without_concerns.add(cve.cve_id);
                    }
                });
            });
            
            // Second pass: Aggregate concern data
            dashboardData.cve_data.forEach(cve => {
                cve.platform_entries.forEach(entry => {
                    if (!sourceData[entry.source_id]) {
                        sourceData[entry.source_id] = {
                            source_id: entry.source_id,
                            source_name: createDisplaySourceName(entry.source_name, entry.source_id),
                            total_concerns: 0,
                            cve_records: new Set(),
                            concern_breakdown: {},
                            entries: []
                        };
                    }
                    
                    const source = sourceData[entry.source_id];
                    source.total_concerns += entry.total_concerns;
                    source.cve_records.add(cve.cve_id);
                    source.entries.push({
                        cve_id: cve.cve_id,
                        vendor: entry.vendor,
                        product: entry.product,
                        table_index: entry.table_index,
                        concerns: entry.total_concerns,
                        concern_breakdown: entry.concern_breakdown || {},
                        concern_types: entry.concern_types || Object.keys(entry.concern_breakdown || {}),
                        concerns_detail: entry.concerns_detail || []  // Include the detailed concern data
                    });
                    
                    // Merge concern breakdown
                    Object.entries(entry.concern_breakdown || {}).forEach(([type, count]) => {
                        const displayName = concernTypeNames[type] || type;
                        source.concern_breakdown[displayName] = (source.concern_breakdown[displayName] || 0) + count;
                    });
                });
            });
            
            // Calculate total platform entries for each source (including entries with no concerns)
            Object.values(sourceData).forEach(source => {
                // Count platform entries with no concerns from clean_platform_entries data
                let totalCleanEntries = 0;
                dashboardData.cve_data.forEach(cve => {
                    if (cve.clean_platform_entries) {
                        const cleanEntry = cve.clean_platform_entries.find(entry => entry.sourceID === source.source_id);
                        if (cleanEntry) {
                            totalCleanEntries += cleanEntry.cleanPlatformCount;
                        }
                    }
                });
                
                // Add totals to source data
                source.clean_platform_entries = totalCleanEntries;
                source.total_platform_entries = source.entries.length + totalCleanEntries;
            });
            
            // Sort by total concerns
            const sortedSources = Object.entries(sourceData)
                .sort((a, b) => b[1].total_concerns - a[1].total_concerns);
            
            if (sortedSources.length === 0) {
                sourcesList.innerHTML = '<div class="loading">No source data available.</div>';
                return;
            }
            
            const sourcesHTML = sortedSources.map(([sourceId, data], sourceIndex) => {
                const topConcerns = Object.entries(data.concern_breakdown)
                    .filter(([type, count]) => count > 0)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5);
                
                // Calculate total concerns for percentage calculation
                const totalConcerns = Object.values(data.concern_breakdown).reduce((sum, count) => sum + count, 0);
                
                // Analyze concern breakdowns for subcategory information
                const concernBreakdowns = analyzeConcernBreakdown(data);
                
                const cardId = `sa_card_${String(sourceIndex + 1).padStart(2, '0')}`;
                const titleId = `sa_title_${String(sourceIndex + 1).padStart(2, '0')}`;
                const contentId = `sa_content_${String(sourceIndex + 1).padStart(2, '0')}`;
                const listId = `sa_list_${String(sourceIndex + 1).padStart(2, '0')}`;
                const detailsId = `sa_details_${String(sourceIndex + 1).padStart(2, '0')}`;
                const entriesListId = `sa_list_${String(sourceIndex + 1).padStart(2, '0')}_entries`;
                
                // Simplified badge IDs with semantic CSS classes for styling
                const badge1Id = `sa_badge_${String(sourceIndex + 1).padStart(2, '0')}_01`; // Total concerns
                const badge2Id = `sa_badge_${String(sourceIndex + 1).padStart(2, '0')}_02`; // CVE records
                const badge3Id = `sa_badge_${String(sourceIndex + 1).padStart(2, '0')}_03`; // Platform entries
                

                
                return `
                    <div id="${cardId}" class="source-item" data-source-index="${sourceIndex}">
                        <h4 id="${titleId}">${data.source_name}</h4>
                        <div id="${contentId}" class="source-stats">
                            <div class="source-stat">
                                <div class="stat-content">
                                    <div class="stat-text">
                                        <strong id="${badge2Id}" class="stat-badge stat-total">${data.cve_records.size}</strong> CVE records
                                        <span class="stat-detail">
                                            <strong class="stat-badge stat-concern">${data.cve_records_with_concerns.size}</strong> with concerns detected
                                            <br />
                                            <strong class="stat-badge stat-clean">${data.cve_records_without_concerns.size}</strong> with no concerns
                                        </span>
                                    </div>
                                    <div class="stat-chart-container">
                                        <canvas id="cve-chart-${sourceIndex}" class="stat-pie-chart"></canvas>
                                    </div>
                                </div>
                            </div>
                            <div class="source-stat">
                                <div class="stat-content">
                                    <div class="stat-text">
                                        <strong id="${badge3Id}" class="stat-badge stat-total">${data.total_platform_entries}</strong> platform entries
                                        <span class="stat-detail">
                                            <strong class="stat-badge stat-concern">${data.entries.length}</strong> with concerns detected
                                            <br />
                                            <strong class="stat-badge stat-clean">${data.clean_platform_entries}</strong> with no concerns
                                        </span>
                                    </div>
                                    <div class="stat-chart-container">
                                        <canvas id="platform-chart-${sourceIndex}" class="stat-pie-chart"></canvas>
                                    </div>
                                </div>
                            </div>
                            <div class="source-stat">
                                <div class="stat-content">
                                    <div class="stat-text">
                                        <strong id="${badge1Id}" class="stat-badge stat-concern">${data.total_concerns}</strong> total concerns
                                        <span class="stat-detail">Concern types breakdown ‚ûî</span>
                                    </div>
                                    <div class="stat-chart-container">
                                        <canvas id="concerns-chart-${sourceIndex}" class="stat-pie-chart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="${listId}" class="top-concerns">
                            <strong>Detection Groups:</strong>
                            ${topConcerns.length > 0 ? 
                                topConcerns.map(([type, count], concernIndex) => {
                                    const itemId = `sa_item_${String(sourceIndex + 1).padStart(2, '0')}_${String(concernIndex + 1).padStart(2, '0')}`;
                                    
                                    // Calculate percentage of ALL concerns (not just top 5)
                                    const percentage = totalConcerns > 0 ? ((count / totalConcerns) * 100).toFixed(1) : '0.0';
                                    
                                    // Get the concern type key from display name
                                    const concernTypeKey = Object.keys(concernTypeNames).find(key => 
                                        concernTypeNames[key] === type
                                    ) || type.toLowerCase().replace(/\s+/g, '');
                                    
                                    // Get subcategory breakdown
                                    const subcategorySummary = concernBreakdowns[concernTypeKey] 
                                        ? generateSubcategorySummary(concernTypeKey, concernBreakdowns[concernTypeKey])
                                        : '';
                                    
                                    return `
                                        <div id="${itemId}" class="top-concern">
                                            <div class="concern-header">
                                                <span class="concern-title">${type}</span>
                                                <span class="concern-count-badge">${count} (${percentage}%)</span>
                                            </div>
                                            ${subcategorySummary ? `
                                                <div class="concern-breakdown">
                                                    <span class="breakdown-text">${subcategorySummary}</span>
                                                </div>
                                            ` : ''}
                                        </div>
                                    `;
                                }).join('') :
                                '<div class="top-concern no-concerns-detected">No concerns detected</div>'
                            }
                        </div>
                        <details id="${detailsId}">
                            ${(() => {
                                // Group entries by CVE ID to count unique CVEs
                                const cveGroups = {};
                                data.entries.forEach((entry, entryIndex) => {
                                    if (!cveGroups[entry.cve_id]) {
                                        cveGroups[entry.cve_id] = [];
                                    }
                                    cveGroups[entry.cve_id].push({...entry, entryIndex});
                                });
                                const uniqueCveCount = Object.keys(cveGroups).length;
                                const entriesWithConcerns = data.entries.filter(entry => entry.total_concerns > 0).length;
                                return `<summary id="${entriesListId}_summary">View CVE Entries (${uniqueCveCount})</summary>`;
                            })()}
                            <div id="${entriesListId}" class="cve-cards-container">
                                ${(() => {
                                    // Group entries by CVE ID
                                    const cveGroups = {};
                                    data.entries.forEach((entry, entryIndex) => {
                                        if (!cveGroups[entry.cve_id]) {
                                            cveGroups[entry.cve_id] = [];
                                        }
                                        cveGroups[entry.cve_id].push({...entry, entryIndex});
                                    });

                                    return Object.entries(cveGroups).map(([cveId, cveEntries]) => {
                                        const totalConcerns = cveEntries.reduce((sum, entry) => sum + entry.concerns, 0);
                                        const cardId = `cve_card_${String(sourceIndex + 1).padStart(2, '0')}_${cveId.replace(/[^a-zA-Z0-9]/g, '_')}`;
                                        
                                        // Aggregate concern types across all entries for this CVE
                                        const concernTypeCounts = {};
                                        cveEntries.forEach(entry => {
                                            Object.entries(entry.concern_breakdown || {}).forEach(([type, count]) => {
                                                concernTypeCounts[type] = (concernTypeCounts[type] || 0) + count;
                                            });
                                        });

                                        const concernTypeEntries = Object.entries(concernTypeCounts)
                                            .filter(([type, count]) => count > 0)
                                            .sort(([,a], [,b]) => b - a);

                                        const githubUrl = `https://hashmire.github.io/cpeApplicabilityGeneratorPages/generated_pages/${cveId}.html`;

                                        // Collect all concern details for this CVE for subcategory analysis
                                        const allConcernDetails = {};
                                        cveEntries.forEach(entry => {
                                            if (entry.concerns_detail) {
                                                entry.concerns_detail.forEach(detailGroup => {
                                                    if (!allConcernDetails[detailGroup.concern_type]) {
                                                        allConcernDetails[detailGroup.concern_type] = [];
                                                    }
                                                    allConcernDetails[detailGroup.concern_type].push(...detailGroup.concerns);
                                                });
                                            }
                                        });

                                        return `
                                            <div class="cve-card" id="${cardId}">
                                                <div class="cve-card-left-content">
                                                    <div class="cve-card-header">
                                                        <a href="${githubUrl}" target="_blank" class="cve-id-link">
                                                            <span class="cve-id">${cveId}</span>
                                                        </a>
                                                        <span class="cve-entries-count">${cveEntries.length} entries</span>
                                                    </div>
                                                    <div class="cve-card-content" onclick="toggleCveDetails('${cardId}')">
                                                        <div class="cve-card-main-content">
                                                            <div class="cve-content-display">
                                                                ${totalConcerns > 0 ? 
                                                                    concernTypeEntries.map(([type, count]) => {
                                                                        const displayName = concernTypeNames[type] || type;
                                                                        const percentage = ((count / totalConcerns) * 100).toFixed(1);
                                                                        const concernDetails = allConcernDetails[type] || [];
                                                                        const categorizedConcerns = categorizeConcernsByType(type, concernDetails);
                                                                        const subcategorySummary = generateSubcategorySummary(type, categorizedConcerns);
                                                                        
                                                                        return `
                                                                            <div class="cve-concern-section" data-type="${type}">
                                                                                <div class="cve-section-summary">
                                                                                    <span class="cve-concern-type">${displayName}:</span>
                                                                                    <span class="cve-concern-count">${count} (${percentage}%)</span>
                                                                                </div>
                                                                                <div class="cve-section-details">
                                                                                    ${subcategorySummary || 'No subcategory details available'}
                                                                                </div>
                                                                            </div>
                                                                        `;
                                                                    }).join('') 
                                                                    : `
                                                                        <div class="cve-concern-section">
                                                                            <div class="cve-section-summary">
                                                                                <span class="cve-concern-type clean-status">No concerns detected</span>
                                                                            </div>
                                                                        </div>
                                                                    `
                                                                }
                                                            </div>
                                                        </div>
                                                        <div class="click-details-indicator">
                                                            <span>Click for details</span>
                                                            <span class="chevron">‚Øà</span>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div class="cve-card-right-content cve-expanded-content" style="display: none;">
                                                    <!-- Platform entry badge tabs and modal content will be generated here -->
                                                </div>
                                            </div>
                                        `;
                                    }).join('');
                                })()}
                            </div>
                        </details>
                    </div>
                `;
            }).join('');
            
            sourcesList.innerHTML = sourcesHTML;
            
            // Apply dynamic sizing to CVE cards based on content
            applyCveCardDynamicSizing();
            
            // Create charts for each source
            createSourceCharts(sortedSources);
            
            // Initialize search functionality
            initializeSimpleSearch();
            
            // Re-apply dynamic sizing after any layout changes from charts
            setTimeout(() => {
                applyCveCardDynamicSizing();
            }, 100);
        }
        
        function createSourceCharts(sortedSources) {
            // Define sage green and royal purple color palettes with lighter fills and deeper borders
            const concernColors = [
                '#9F7AEA', '#B794F6', '#D6BCFA', '#E9D8FD', '#F7FAFC',  // Royal purple gradient (lighter fills)
                '#68D391', '#9AE6B4', '#C6F6D5', '#F0FFF4', '#F7FAFC'   // Sage green gradient (lighter fills)
            ];
            
            const concernBorderColors = [
                '#553C9A', '#6B46C1', '#7C3AED', '#8B5CF6', '#9F7AEA',  // Deeper royal purple borders
                '#276749', '#2F855A', '#38A169', '#48BB78', '#68D391'   // Deeper sage green borders
            ];
            
            const cleanColor = '#9AE6B4';      // Light sage green for "No Concerns" entries
            const cleanBorderColor = '#2F855A'; // Deep sage green border
            const concernColor = '#B794F6';    // Light royal purple for "Concerns Detected" entries
            const concernBorderColor = '#6B46C1'; // Deep royal purple border
            
            // Custom tooltip positioner to center tooltips
            Chart.Tooltip.positioners.center = function(elements, eventPosition) {
                if (!elements.length) {
                    return false;
                }
                
                // Get the chart area
                const chart = this.chart;
                const {chartArea: {left, top, right, bottom}} = chart;
                
                // Return center position of chart area
                return {
                    x: (left + right) / 2,
                    y: (top + bottom) / 2
                };
            };
            
            sortedSources.forEach(([sourceId, data], sourceIndex) => {
                // 1. CVE Distribution Chart
                const cveCanvas = document.getElementById(`cve-chart-${sourceIndex}`);
                if (cveCanvas) {
                    new Chart(cveCanvas, {
                        type: 'doughnut',
                        data: {
                            labels: ['Concerns Detected', 'No Concerns'],
                            datasets: [{
                                data: [data.cve_records_with_concerns.size, data.cve_records_without_concerns.size],
                                backgroundColor: [concernColor, cleanColor],
                                borderColor: [concernBorderColor, cleanBorderColor],
                                borderWidth: 3,
                                hoverOffset: 18,
                                hoverBorderWidth: 4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    position: 'center', // Pin tooltip to center of chart
                                    displayColors: false,
                                    titleFont: { size: 0 }, // Hide title completely
                                    bodyFont: { size: 11, weight: '600' }, // Smaller, centered font
                                    padding: 4, // Reduced padding
                                    bodyAlign: 'center', // Center the text within tooltip
                                    callbacks: {
                                        title: function() {
                                            return ''; // No title
                                        },
                                        label: function(context) {
                                            const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                            const percentage = ((context.parsed / total) * 100).toFixed(1);
                                            const count = context.parsed;
                                            // Split multi-word labels into separate lines
                                            const labelWords = context.label.split(' ');
                                            const labelLines = labelWords.length > 1 ? labelWords : [context.label];
                                            return [...labelLines, `${count} (${percentage}%)`];
                                        }
                                    }
                                }
                            },
                            cutout: '50%' // Increased thickness from 60% to 50%
                        }
                    });
                }
                
                // 2. Platform Entries Chart
                const platformCanvas = document.getElementById(`platform-chart-${sourceIndex}`);
                if (platformCanvas) {
                    new Chart(platformCanvas, {
                        type: 'doughnut',
                        data: {
                            labels: ['Concerns Detected', 'No Concerns'],
                            datasets: [{
                                data: [data.entries.length, data.clean_platform_entries],
                                backgroundColor: [concernColor, cleanColor],
                                borderColor: [concernBorderColor, cleanBorderColor],
                                borderWidth: 3,
                                hoverOffset: 18,
                                hoverBorderWidth: 4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    position: 'center', // Pin tooltip to center of chart
                                    displayColors: false,
                                    titleFont: { size: 0 }, // Hide title completely
                                    bodyFont: { size: 11, weight: '600' }, // Smaller, centered font
                                    padding: 4, // Reduced padding
                                    bodyAlign: 'center', // Center the text within tooltip
                                    callbacks: {
                                        title: function() {
                                            return ''; // No title
                                        },
                                        label: function(context) {
                                            const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                            const percentage = ((context.parsed / total) * 100).toFixed(1);
                                            const count = context.parsed;
                                            // Split multi-word labels into separate lines
                                            const labelWords = context.label.split(' ');
                                            const labelLines = labelWords.length > 1 ? labelWords : [context.label];
                                            return [...labelLines, `${count} (${percentage}%)`];
                                        }
                                    }
                                }
                            },
                            cutout: '50%' // Increased thickness from 60% to 50%
                        }
                    });
                }
                
                // 3. Concern Types Breakdown Chart
                const concernsCanvas = document.getElementById(`concerns-chart-${sourceIndex}`);
                if (concernsCanvas && data.total_concerns > 0) {
                    const topConcerns = Object.entries(data.concern_breakdown)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5); // Top 5 concerns
                    
                    if (topConcerns.length > 0) {
                        new Chart(concernsCanvas, {
                            type: 'doughnut',
                            data: {
                                labels: topConcerns.map(([type, count]) => type),
                                datasets: [{
                                    data: topConcerns.map(([type, count]) => count),
                                    backgroundColor: concernColors.slice(0, topConcerns.length),
                                    borderColor: concernBorderColors.slice(0, topConcerns.length),
                                    borderWidth: 3,
                                    hoverOffset: 18,
                                    hoverBorderWidth: 4
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: { display: false },
                                    tooltip: {
                                        position: 'center', // Pin tooltip to center of chart
                                        displayColors: false,
                                        titleFont: { size: 0 }, // Hide title completely
                                        bodyFont: { size: 11, weight: '600' }, // Smaller, centered font
                                        padding: 4, // Reduced padding
                                        bodyAlign: 'center', // Center the text within tooltip
                                        callbacks: {
                                            title: function() {
                                                return ''; // No title
                                            },
                                            label: function(context) {
                                                // Use total of ALL concerns, not just the slice shown in chart
                                                const allConcernsTotal = Object.values(data.concern_breakdown).reduce((sum, count) => sum + count, 0);
                                                const percentage = ((context.parsed / allConcernsTotal) * 100).toFixed(1);
                                                const count = context.parsed;
                                                // Split multi-word labels into separate lines
                                                const labelWords = context.label.split(' ');
                                                const labelLines = labelWords.length > 1 ? labelWords : [context.label];
                                                return [...labelLines, `${count} (${percentage}%)`];
                                            }
                                        }
                                    }
                                },
                                cutout: '40%' // Increased thickness from 50% to 40%
                            }
                        });
                    }
                } else if (concernsCanvas) {
                    // Show "No Concerns" chart
                    new Chart(concernsCanvas, {
                        type: 'doughnut',
                        data: {
                            labels: ['No Concerns'],
                            datasets: [{
                                data: [1],
                                backgroundColor: [cleanColor],
                                borderColor: [cleanBorderColor],
                                borderWidth: 3,
                                hoverOffset: 18,
                                hoverBorderWidth: 4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    position: 'center', // Pin tooltip to center of chart
                                    displayColors: false,
                                    titleFont: { size: 0 }, // Hide title completely
                                    bodyFont: { size: 11 },
                                    padding: 4, // Reduced from 8 to minimize tooltip padding
                                    callbacks: {
                                        title: function() {
                                            return ''; // No title
                                        },
                                        label: function() {
                                            return 'No Concerns:\n100%';
                                        }
                                    }
                                }
                            },
                            cutout: '50%' // Increased thickness from 60% to 50%
                        }
                    });
                }
            });
        }
        
        function showError(message) {
            console.error(message);
            // Could add a simple alert or toast notification here if needed
        }
        
        function showSuccess(message) {
            // Could add a simple toast notification here if needed
        }

        function initializeSimpleSearch() {
            const searchInput = document.getElementById('source-search');
            const searchSummary = document.getElementById('search-results-summary');
            const searchLoading = document.getElementById('search-loading');
            const totalSourcesSpan = document.getElementById('total-sources');
            const visibleSourcesSpan = document.getElementById('visible-sources');
            const sourcesList = document.getElementById('sources-list');
            
            if (!searchInput) return;
            
            // Count total sources and set initial UI state
            const allSourceCards = sourcesList.querySelectorAll('[id^="sa_card_"]');
            const totalSources = allSourceCards.length;
            totalSourcesSpan.textContent = totalSources;
            visibleSourcesSpan.textContent = totalSources;
            
            function updateCveSummaries() {
                // Update all CVE summaries to show visible vs total counts
                const allSummaries = document.querySelectorAll('[id$="_summary"]');
                
                allSummaries.forEach(summary => {
                    const summaryId = summary.id;
                    const entriesListId = summaryId.replace('_summary', '');
                    const cveContainer = document.getElementById(entriesListId);
                    
                    if (!cveContainer) return;
                    
                    const allCveCards = cveContainer.querySelectorAll('.cve-card');
                    const visibleCveCards = Array.from(allCveCards).filter(card => 
                        card.style.display !== 'none'
                    );
                    
                    const totalCount = allCveCards.length;
                    const visibleCount = visibleCveCards.length;
                    
                    // Update summary text based on whether filtering is active
                    if (visibleCount === totalCount) {
                        // No filtering active - show total count only
                        summary.textContent = `View CVE Entries (${totalCount})`;
                    } else {
                        // Filtering active - show visible/total
                        summary.textContent = `View CVE Entries (${visibleCount}/${totalCount})`;
                    }
                });
            }

            function performHierarchicalSearch(searchTerm) {
                searchLoading.style.display = 'none';
                
                if (searchTerm === '') {
                    // Show all content
                    allSourceCards.forEach(card => {
                        card.style.display = '';
                        // Show all child elements
                        card.querySelectorAll('[id^="sa_item_"], .cve-card').forEach(child => {
                            child.style.display = '';
                        });
                    });
                    
                    visibleSourcesSpan.textContent = totalSources;
                    searchSummary.style.display = 'none';
                    
                    // Update CVE summaries to show total counts
                    updateCveSummaries();
                    
                    // Remove no-results message
                    const noResults = sourcesList.querySelector('.no-results');
                    if (noResults) noResults.remove();
                    return;
                }
                
                let visibleSourceCount = 0;
                const searchWords = searchTerm.split(/\s+/).filter(word => word.length > 0);
                
                allSourceCards.forEach(card => {
                    let cardHasMatch = false;
                    
                    // Check source name (sa_title_)
                    const sourceTitle = card.querySelector('[id^="sa_title_"]');
                    if (sourceTitle && matchesSearch(sourceTitle.textContent, searchWords)) {
                        cardHasMatch = true;
                    }
                    
                    // Check and filter Top Concerns (Detection Groups)
                    const topConcernItems = card.querySelectorAll('[id^="sa_item_"]');
                    topConcernItems.forEach(item => {
                        let itemHasMatch = false;
                        
                        // Check concern-title (Detection Group)
                        const concernTitle = item.querySelector('.concern-title');
                        if (concernTitle && matchesSearch(concernTitle.textContent, searchWords)) {
                            itemHasMatch = true;
                        }
                        
                        // Check breakdown-category (Sub-Type Grouping)
                        const breakdownCategories = item.querySelectorAll('.breakdown-category');
                        breakdownCategories.forEach(category => {
                            if (matchesSearch(category.textContent, searchWords)) {
                                itemHasMatch = true;
                            }
                        });
                        
                        if (itemHasMatch) {
                            item.style.display = '';
                            cardHasMatch = true;
                        } else {
                            item.style.display = 'none';
                        }
                    });
                    
                    // Check and filter CVE entries
                    const cveCards = card.querySelectorAll('.cve-card');
                    cveCards.forEach(cveCard => {
                        let cveHasMatch = false;
                        
                        // Check CVE ID
                        const cveIdElement = cveCard.querySelector('.cve-id, [class*="cve-id"]');
                        if (cveIdElement && matchesSearch(cveIdElement.textContent, searchWords)) {
                            cveHasMatch = true;
                        }
                        
                        // Check cve-concern-type (Detection Group in CVE context)
                        const cveConcernTypes = cveCard.querySelectorAll('.cve-concern-type, [class*="concern-type"]');
                        cveConcernTypes.forEach(type => {
                            if (matchesSearch(type.textContent, searchWords)) {
                                cveHasMatch = true;
                            }
                        });
                        
                        // Check breakdown-category (Sub-Type Grouping within CVE cards)
                        const cveBreakdownCategories = cveCard.querySelectorAll('.breakdown-category');
                        cveBreakdownCategories.forEach(category => {
                            if (matchesSearch(category.textContent, searchWords)) {
                                cveHasMatch = true;
                            }
                        });
                        
                        if (cveHasMatch) {
                            cveCard.style.display = '';
                            cardHasMatch = true;
                        } else {
                            cveCard.style.display = 'none';
                        }
                    });
                    
                    // Show/hide entire source card based on whether any children matched
                    if (cardHasMatch) {
                        card.style.display = '';
                        visibleSourceCount++;
                    } else {
                        card.style.display = 'none';
                    }
                });
                
                // Update UI
                visibleSourcesSpan.textContent = visibleSourceCount;
                searchSummary.style.display = 'block';
                
                // Update CVE summaries to show filtered counts
                updateCveSummaries();
                
                // Handle no results
                const existingNoResults = sourcesList.querySelector('.no-results');
                if (visibleSourceCount === 0 && !existingNoResults) {
                    const noResultsDiv = document.createElement('div');
                    noResultsDiv.className = 'no-results';
                    noResultsDiv.innerHTML = `
                        <div>No matches found for "${searchTerm}"</div>
                        <div class="search-suggestions">
                            Search targets: Source names, Detection Groups, Sub-Types, or CVE IDs
                        </div>
                    `;
                    sourcesList.appendChild(noResultsDiv);
                } else if (visibleSourceCount > 0 && existingNoResults) {
                    existingNoResults.remove();
                }
            }
            
            function matchesSearch(text, searchWords) {
                if (!text) return false;
                const lowerText = text.toLowerCase();
                return searchWords.every(word => lowerText.includes(word));
            }
            
            // Event listeners
            searchInput.addEventListener('input', function(e) {
                const searchTerm = e.target.value.toLowerCase().trim();
                
                if (searchDebounceTimeout) {
                    clearTimeout(searchDebounceTimeout);
                }
                
                searchDebounceTimeout = setTimeout(() => {
                    performHierarchicalSearch(searchTerm);
                }, 250);
            });
            
            searchInput.addEventListener('paste', function(e) {
                setTimeout(() => {
                    const searchTerm = e.target.value.toLowerCase().trim();
                    performHierarchicalSearch(searchTerm);
                }, 10);
            });
            
            searchInput.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    e.target.value = '';
                    performHierarchicalSearch('');
                    e.target.blur();
                }
            });
        }
        
        // ========== PROCESSING OVERLAY FUNCTIONS ==========
        
        function showProcessingOverlay(title = 'Loading Data', message = 'Please wait while we load your data file...') {
            const overlay = document.getElementById('processingOverlay');
            const titleElement = document.getElementById('processingTitle');
            const messageElement = document.getElementById('processingMessage');
            const progressBar = document.getElementById('processingProgressBar');
            const detailsElement = document.getElementById('processingDetails');
            
            if (!overlay) {
                console.error('Processing overlay element not found!');
                return;
            }
            
            titleElement.textContent = title;
            messageElement.textContent = message;
            progressBar.style.width = '0%';
            detailsElement.textContent = '';
            
            overlay.style.display = 'flex';
            overlay.style.visibility = 'visible';
        }
        
        function updateProcessingProgress(progress, details = '') {
            const progressBar = document.getElementById('processingProgressBar');
            const detailsElement = document.getElementById('processingDetails');
            
            // Ensure progress is between 0 and 100
            progress = Math.max(0, Math.min(100, progress));
            progressBar.style.width = progress + '%';
            
            if (details) {
                detailsElement.textContent = details;
            }
        }
        
        function hideProcessingOverlay() {
            const overlay = document.getElementById('processingOverlay');
            overlay.style.display = 'none';
        }
        
        function showProcessingWithSteps(title, steps, currentStep = 0) {
            showProcessingOverlay(title, steps[currentStep] || 'Processing...');
            
            if (steps.length > 0) {
                const progress = (currentStep / steps.length) * 100;
                updateProcessingProgress(progress, `Step ${currentStep + 1} of ${steps.length}`);
            }
        }
        
        // Check for injected data on page load
        function checkForInjectedData() {
            if (typeof injectedDashboardData !== 'undefined' && injectedDashboardData !== null) {
                console.log('‚úì Injected data detected, loading dashboard automatically...');
                dashboardData = injectedDashboardData;
                
                // Update status bar with injected data metadata
                const statusBar = document.getElementById('status-bar');
                const statusFilename = document.getElementById('status-filename');
                const generationTimeEl = document.getElementById('generation-time');
                const fileSizeEl = document.getElementById('file-size');
                const loadTimeEl = document.getElementById('load-time');
                
                if (statusBar) {
                    // Display organization/source name for quick scope identification
                    const sourceName = dashboardData.metadata?.source_name || 'Unknown Source';
                    statusFilename.textContent = sourceName;
                    
                    let generationTime = 'Unknown';
                    if (dashboardData.metadata && dashboardData.metadata.run_started_at) {
                        const genDate = new Date(dashboardData.metadata.run_started_at);
                        generationTime = genDate.toLocaleString();
                    }
                    generationTimeEl.textContent = generationTime;
                    
                    // Calculate approximate data size
                    const dataSize = (JSON.stringify(dashboardData).length / 1024).toFixed(1);
                    fileSizeEl.textContent = `~${dataSize} KB`;
                    
                    const now = new Date();
                    loadTimeEl.textContent = now.toLocaleTimeString();
                    
                    statusBar.style.display = 'block';
                }
                
                // Process the injected data
                processLoadedData();
                return true;
            }
            return false;
        }
        
        // Initialize page - auto-load injected data only
        document.addEventListener('DOMContentLoaded', function() {
            // Check if data was injected
            if (checkForInjectedData()) {
                console.log('Dashboard initialized with injected data');
            } else {
                console.error('No injected data found - this template requires pre-injected data');
                showError('Report data not found. This dashboard requires pre-injected data.');
            }
            
            // Handle window resize for dynamic CVE card sizing
            let resizeTimeout;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (document.querySelectorAll('.cve-card').length > 0) {
                        applyCveCardDynamicSizing();
                    }
                }, 250);
            });
        });
    </script>

    <!-- Processing Overlay (positioned at body level for maximum z-index effectiveness) -->
    <div id="processingOverlay" class="processing-overlay">
        <div class="processing-card">
            <div class="processing-spinner"></div>
            <div id="processingTitle" class="processing-title">Loading Data</div>
            <div id="processingMessage" class="processing-message">Please wait while we load your data file...</div>
            <div class="processing-progress">
                <div id="processingProgressBar" class="processing-progress-bar" style="width: 0%;"></div>
            </div>
            <div id="processingDetails" class="processing-details"></div>
        </div>
    </div>

</body>
</html>
