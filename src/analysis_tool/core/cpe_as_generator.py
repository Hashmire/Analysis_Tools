"""
CPE Applicability Statement Generator for NVD-ish Records

**NVD-ish Integration Component** - Generates CPE Applicability Statements (CPE-AS) from 
CVE 5.X affected[] entries and integrates them into NVD-ish enhanced records.

This module is a core component of the NVD-ish record generation pipeline, producing 
CPE match objects that replicate NVD-style configurations[] arrays. It implements 
pattern-based classification to handle various data quality scenarios while maintaining 
1:1 transformation guarantees.

NVD-ish Integration Points:
    1. nvd_ish_collector.py calls generate_cpe_as() for each affected[] entry
    2. CPE base strings generated by platform_entry_registry.py
    3. Output embedded in enrichedCVEv5Affected[].cpeAsGeneration section
    4. Integration follows PLATFORM_ENTRY_NOTIFICATION_REGISTRY pattern

Data Flow:
    CVE 5.0 affected[] entry → generate_cpe_as() → cpeMatch objects → 
    nvd_ish_collector.py → enrichedCVEv5Affected[].cpeAsGeneration → 
    nvd-ish_2.0_cves/{year}/{dir}/{CVE-ID}.json

Architecture Integration:
- Input: CVE 5.0 affected[] entry + CPE base string (from platform_entry_registry.py)
- Output: NVD-style configurations[] array with cpeMatch objects
- Integration: Embedded in NVD-ish records via nvd_ish_collector.py registry pattern
- Test Suite: test_suites/nvd-ish_collector/test_cpe_as_integration.py

Pattern Categories (Section 3 of CPE_AS_Generation_Refactoring_Requirements.md):
- 3.1: No version data (wildcard version) - IMPLEMENTED & TESTED (Phase 1-2)
- 3.2: No affected platforms (metadata-only) - IMPLEMENTED (Phase 3)
- 3.3: Exact versions (1:1 transformation) - IMPLEMENTED (Phase 4)
- 3.4: Single range per entry (1:1 transformation) - IMPLEMENTED (Phase 5)
- 3.5: Multiple ranges from one entry (1:M transformation) - TODO Phase 6

Key Design Principles:
- Fail-fast error handling (no silent failures)
- 1:1 transformation guarantee (each version entry → exactly one cpeMatch object)
- Property ordering via OrderedDict (Section 2.1 requirement)
- Utility reuse (VERSION_PLACEHOLDER_VALUES, formatFor23CPE, etc.)
- Evidence-based error messages (no silent fallbacks)

Created: January 21, 2026
Status: Phases 1-5 Complete (Patterns 3.1-3.4 implemented)
"""

from collections import OrderedDict
from typing import Dict, List, Any, Optional, Tuple
import re

# Import existing utilities from other modules
from .platform_entry_registry import (
    VERSION_PLACEHOLDER_VALUES,
    GENERAL_PLACEHOLDER_VALUES,
    determine_vulnerability_from_status,
    analyze_update_patterns,
    transform_version_with_update_pattern
)
from .processData import formatFor23CPE
from ..logging.workflow_logger import get_logger

# Initialize logger
logger = get_logger()

# ===== UTILITY FUNCTIONS =====

def validate_cpe_23_format(cpe_string: str) -> Tuple[bool, Optional[str]]:
    """
    Validate that a CPE 2.3 string conforms to the specification.
    
    CPE 2.3 Specification Requirements:
    - Format: cpe:2.3:part:vendor:product:version:update:edition:language:sw_edition:target_sw:target_hw:other
    - Exactly 13 components (including scheme "cpe" and version "2.3")
    - Components separated by colons ':'
    - Part must be 'a' (application), 'o' (operating system), or 'h' (hardware)
    
    Args:
        cpe_string: CPE string to validate
        
    Returns:
        Tuple of (is_valid: bool, error_message: Optional[str])
        
    Examples:
        >>> validate_cpe_23_format("cpe:2.3:a:gitlab:gitlab:*:*:*:*:*:*:*:*")
        (True, None)
        
        >>> validate_cpe_23_format("cpe:2.3:a:gitlab:gitlab:18.2.2:*:*:*:*:*:*:*")
        (True, None)
        
        >>> validate_cpe_23_format("cpe:2.3:a:gitlab:gitlab:*:*:*:*:*:*:*:*:*:*:*:*:*:*:*:*")
        (False, "CPE has 19 components, expected exactly 13")
    """
    if not cpe_string:
        return False, "CPE string is empty or None"
    
    if not cpe_string.startswith("cpe:2.3:"):
        return False, f"CPE must start with 'cpe:2.3:', got: {cpe_string[:20]}"
    
    # Split and count components
    components = cpe_string.split(':')
    component_count = len(components)
    
    if component_count != 13:
        return False, f"CPE has {component_count} components, expected exactly 13. CPE: {cpe_string}"
    
    # Validate part (component index 2, after cpe:2.3:)
    part = components[2]
    if part not in ['a', 'o', 'h', '*']:
        return False, f"CPE part must be 'a', 'o', 'h', or '*', got: '{part}'"
    
    return True, None


def normalize_cpe_base_string(cpe_base_string: str) -> str:
    """
    Ensure CPE base string is a complete 13-component CPE 2.3 string.
    
    IMPORTANT: cpe_base_string from confirmed mappings is ALREADY a complete
    CPE 2.3 string with 13 components (e.g., "cpe:2.3:a:gitlab:gitlab:*:*:*:*:*:*:*:*").
    This function validates and returns it as-is, or raises an error if invalid.
    
    Args:
        cpe_base_string: Complete CPE 2.3 base string
        
    Returns:
        Validated CPE base string (unmodified if valid)
        
    Raises:
        ValueError: If CPE base string is not a valid 13-component CPE 2.3 string
    """
    is_valid, error_msg = validate_cpe_23_format(cpe_base_string)
    if not is_valid:
        raise ValueError(f"Invalid CPE base string: {error_msg}")
    
    return cpe_base_string


def create_ordered_cpe_match(
    versions_entry_index: Optional[int],
    applied_pattern: Optional[str],
    vulnerable: Optional[bool] = None,
    criteria: Optional[str] = None,
    version_start_including: Optional[str] = None,
    version_start_excluding: Optional[str] = None,
    version_end_including: Optional[str] = None,
    version_end_excluding: Optional[str] = None,
    concerns: Optional[List[str]] = None,
    **additional_fields
) -> OrderedDict:
    """
    Create cpeMatch object with guaranteed property order per Section 2.1 requirements.
    
    Property Order (CRITICAL):
    1. versionsEntryIndex - Maps to source versions[] array index (0-based, null if no versions array)
    2. appliedPattern - Pattern reference for traceability (optional, omitted for metadata-only)
    3. vulnerable - Boolean indicating vulnerability status
    4. criteria - Full CPE 2.3 formatted string (optional, omitted for metadata-only)
    5. versionStartIncluding - Lower bound version, inclusive (optional)
    6. versionStartExcluding - Lower bound version, exclusive (optional)
    7. versionEndIncluding - Upper bound version, inclusive (optional)
    8. versionEndExcluding - Upper bound version, exclusive (optional)
    9. concerns - Array of concern identifiers (optional)
    10. Additional optional fields (e.g., updatePattern)
    
    Args:
        versions_entry_index: Index in versions[] array (null if no versions array)
        applied_pattern: Pattern identifier for traceability (e.g., "exact.single", "range.lessThan")
        vulnerable: True if affected/vulnerable, False if explicitly unaffected, None for metadata-only entries with concerns
        criteria: Full CPE 2.3 string (optional, omitted for metadata-only)
        version_start_including: Lower bound version, inclusive (optional)
        version_start_excluding: Lower bound version, exclusive (optional)
        version_end_including: Upper bound version, inclusive (optional)
        version_end_excluding: Upper bound version, exclusive (optional)
        concerns: List of concern identifiers (optional)
        **additional_fields: Any additional optional fields to include
    
    Returns:
        OrderedDict with properties in required order
    
    Examples:
        Standard cpeMatch:
        >>> create_ordered_cpe_match(
        ...     versions_entry_index=0,
        ...     applied_pattern="range.lessThan",
        ...     vulnerable=True,
        ...     criteria="cpe:2.3:a:vendor:product:*:*:*:*:*:*:*:*",
        ...     version_start_including="2.0",
        ...     version_end_excluding="2.5"
        ... )
        OrderedDict([('versionsEntryIndex', 0), ('appliedPattern', 'range.lessThan'), ...])
        
        Metadata-only cpeMatch:
        >>> create_ordered_cpe_match(
        ...     versions_entry_index=1,
        ...     applied_pattern=None,
        ...     vulnerable=False,
        ...     concerns=["statusUnaffected"]
        ... )
        OrderedDict([('versionsEntryIndex', 1), ('vulnerable', False), ('concerns', ['statusUnaffected'])])
    """
    cpe_match = OrderedDict()
    
    # Property 1: versionsEntryIndex (always present)
    cpe_match['versionsEntryIndex'] = versions_entry_index
    
    # Property 2: appliedPattern (optional, omit if None)
    if applied_pattern is not None:
        cpe_match['appliedPattern'] = applied_pattern
    
    # Property 3: vulnerable (optional - omit for metadata-only entries with concerns)
    # Metadata-only entries should NOT have vulnerable field as they can't make vulnerability determination
    if vulnerable is not None:
        cpe_match['vulnerable'] = vulnerable
    
    # Property 4: criteria (optional, omit if None)
    # CRITICAL: Validate CPE 2.3 format before adding to output
    if criteria is not None:
        is_valid, error_msg = validate_cpe_23_format(criteria)
        if not is_valid:
            raise ValueError(
                f"Invalid CPE 2.3 criteria generated: {error_msg}. "
                f"This is a code bug - all CPE criteria must be validated before output."
            )
        cpe_match['criteria'] = criteria
    
    # Properties 5-8: version range fields (only if not None)
    if version_start_including is not None:
        cpe_match['versionStartIncluding'] = version_start_including
    if version_start_excluding is not None:
        cpe_match['versionStartExcluding'] = version_start_excluding
    if version_end_including is not None:
        cpe_match['versionEndIncluding'] = version_end_including
    if version_end_excluding is not None:
        cpe_match['versionEndExcluding'] = version_end_excluding
    
    # Property 9: concerns (optional, omit if None or empty)
    if concerns is not None and len(concerns) > 0:
        cpe_match['concerns'] = concerns
    
    # Property 10+: Additional optional fields
    for key, value in additional_fields.items():
        if value is not None:
            cpe_match[key] = value
    
    return cpe_match


def is_placeholder_value(value: Any, placeholder_list: List[str] = None) -> bool:
    """
    Check if a value is a placeholder (case-insensitive).
    
    Args:
        value: Value to check (string, None, 0, or other types)
        placeholder_list: Optional custom placeholder list (defaults to GENERAL_PLACEHOLDER_VALUES)
    
    Returns:
        True if value is None, empty string, 0, or matches placeholder patterns
    
    Examples:
        >>> is_placeholder_value("unspecified")
        True
        >>> is_placeholder_value("1.2.3")
        False
        >>> is_placeholder_value(None)
        True
        >>> is_placeholder_value(0)
        True
    """
    # Use default placeholder list if not provided
    if placeholder_list is None:
        placeholder_list = GENERAL_PLACEHOLDER_VALUES
    
    # Check for None, empty string, or 0
    if value is None or value == "" or value == 0:
        return True
    
    # Check if value matches placeholder patterns (case-insensitive)
    if isinstance(value, str):
        value_lower = value.strip().lower()
        return value_lower in [p.lower() for p in placeholder_list]
    
    return False


def is_version_placeholder(value: Any) -> bool:
    """
    Check if a value is a version-specific placeholder.
    
    Args:
        value: Value to check
    
    Returns:
        True if value is a version placeholder (including wildcard "*")
    
    Examples:
        >>> is_version_placeholder("unspecified")
        True
        >>> is_version_placeholder("*")
        True
        >>> is_version_placeholder("1.2.3")
        False
    """
    # Check wildcard first
    if value == "*":
        return True
    
    # Check against VERSION_PLACEHOLDER_VALUES
    return is_placeholder_value(value, VERSION_PLACEHOLDER_VALUES)


def has_wildcard_expansion_pattern(version_str: str) -> bool:
    """
    Check if a version string contains wildcard patterns that would require expansion.
    
    Detects patterns like:
    - "5.4.*" (specific wildcard requiring range expansion)
    - "2.1.0.*" (patch-level wildcard)
    - "5.*" (major-level wildcard)
    
    Note: Does NOT flag bare "*" (global wildcard) as that's handled separately
    as a version placeholder pattern.
    
    Args:
        version_str: Version string to check
    
    Returns:
        True if string contains wildcard expansion pattern (e.g., "5.4.*")
    
    Examples:
        >>> has_wildcard_expansion_pattern("5.4.*")
        True
        >>> has_wildcard_expansion_pattern("2.1.0.*")
        True
        >>> has_wildcard_expansion_pattern("*")
        False
        >>> has_wildcard_expansion_pattern("1.2.3")
        False
    """
    if not isinstance(version_str, str) or not version_str:
        return False
    
    # Bare "*" is a placeholder, not a wildcard expansion pattern
    if version_str == "*":
        return False
    
    # Check for patterns like "5.4.*", "2.1.0.*", "5.*"
    # Must have at least one character before the wildcard
    return "*" in version_str and len(version_str.replace("*", "").replace(".", "")) > 0


def _determine_cpe_confirmation_concern(cpe_suggestion_context: Optional[Dict[str, Any]]) -> str:
    """
    Determine the appropriate concern type for unconfirmed CPE base strings.
    
    Args:
        cpe_suggestion_context: Optional dict with 'top10SuggestedCPEBaseStrings' array
    
    Returns:
        Concern identifier: "cpeUnconfirmedWithSuggestions" or "cpeUnconfirmedNoSuggestions"
    """
    if not cpe_suggestion_context:
        return "cpeUnconfirmedNoSuggestions"
    
    suggested_cpes = cpe_suggestion_context.get('top10SuggestedCPEBaseStrings', [])
    
    if suggested_cpes and len(suggested_cpes) > 0:
        return "cpeUnconfirmedWithSuggestions"
    else:
        return "cpeUnconfirmedNoSuggestions"


def has_real_version_data(versions: List[Dict[str, Any]]) -> bool:
    """
    Check if versions array contains any real (non-placeholder) version data.
    
    Args:
        versions: List of version entry dictionaries
    
    Returns:
        True if any version entry has real version data
    
    Logic:
        - If version field is NOT a placeholder → has real data
        - If changes[] array exists with non-placeholder changes[].at values → has real data
        - If range operators (lessThan, lessThanOrEqual) exist with non-placeholder values → has real data
    """
    if not versions or len(versions) == 0:
        return False
    
    for version_entry in versions:
        # Check version field
        version_value = version_entry.get('version')
        if version_value is not None and not is_version_placeholder(version_value):
            return True
        
        # Check changes array
        changes = version_entry.get('changes', [])
        if changes:
            for change in changes:
                change_at = change.get('at')
                if change_at is not None and not is_version_placeholder(change_at):
                    return True
        
        # Check range operators
        less_than = version_entry.get('lessThan')
        if less_than is not None and not is_version_placeholder(less_than):
            return True
        
        less_than_or_equal = version_entry.get('lessThanOrEqual')
        if less_than_or_equal is not None and not is_version_placeholder(less_than_or_equal):
            return True
    
    return False


# ===== PATTERN CLASSIFICATION FUNCTIONS =====

def classify_pattern(
    affected_entry: Dict[str, Any],
    versions: Optional[List[Dict[str, Any]]]
) -> str:
    """
    Classify affected entry into one of the main pattern categories.
    
    Args:
        affected_entry: CVE 5.0 affected[] array entry
        versions: Versions array (may be None or empty)
    
    Returns:
        Pattern identifier: "3.1", "3.2", "3.3", "3.4", or "3.5"
    
    Pattern Categories:
        3.1: No version data (wildcard version)
        3.2: No affected platforms (metadata-only)
        3.3: Exact versions (1:1 transformation)
        3.4: Single range per entry (1:1 transformation)
        3.5: Multiple ranges from one entry (1:M transformation)
    """
    default_status = affected_entry.get('defaultStatus', 'unknown')
    
    # Pattern 3.2: No affected platforms
    # Must check BEFORE Pattern 3.4 since unaffected versions with changes could be mistaken
    # Only classify as 3.2 if there are NO changes arrays (which would make it Pattern 3.4)
    if default_status == 'unaffected':
        # Check if ALL versions are unaffected AND none have changes/ranges
        if not versions or len(versions) == 0:
            return "3.2"
        
        # Check for any range operators or changes arrays
        has_ranges_or_changes = any(
            'lessThan' in v or 'lessThanOrEqual' in v or len(v.get('changes', [])) > 0
            for v in versions
        )
        
        if not has_ranges_or_changes:
            all_unaffected = all(
                v.get('status', default_status) == 'unaffected'
                for v in versions
            )
            if all_unaffected:
                return "3.2"
    
    # Also check if defaultStatus='affected' but ALL versions explicitly unaffected
    # BUT only if they don't have changes arrays or range operators
    if versions and len(versions) > 0:
        # Check for any range operators or changes arrays
        has_ranges_or_changes = any(
            'lessThan' in v or 'lessThanOrEqual' in v or len(v.get('changes', [])) > 0
            for v in versions
        )
        
        if not has_ranges_or_changes:
            all_unaffected = all(
                v.get('status', default_status) == 'unaffected'
                for v in versions
            )
            if all_unaffected:
                return "3.2"
    
    # Pattern 3.1: No version data
    if not versions or len(versions) == 0:
        return "3.1"
    
    if not has_real_version_data(versions):
        return "3.1"
    
    # Check for range operators or changes arrays (Pattern 3.4 or 3.5)
    has_ranges = False
    has_multiple_ranges = False
    
    for version_entry in versions:
        # Skip git versionType - these are metadata-only
        version_type = version_entry.get('versionType')
        if version_type and version_type.lower() == 'git':
            continue
            
        # Check for range operators
        has_less_than = 'lessThan' in version_entry or 'lessThanOrEqual' in version_entry
        
        # Check for changes array - but count VALID changes only (non-placeholder values)
        changes = version_entry.get('changes', [])
        valid_changes = [
            c for c in changes 
            if c.get('at') and not is_version_placeholder(c.get('at'))
        ]
        has_changes = len(valid_changes) > 0
        
        if has_less_than or has_changes:
            has_ranges = True
            
            # Pattern 3.5: Multiple status transitions or lessThan + changes create multiple ranges
            if len(valid_changes) > 1 or (has_less_than and len(valid_changes) >= 1):
                has_multiple_ranges = True
    
    if has_multiple_ranges:
        return "3.5"
    elif has_ranges:
        return "3.4"
    else:
        return "3.3"


# ===== PATTERN 3.1 HANDLER: NO VERSION DATA =====

def handle_pattern_3_1(
    affected_entry: Dict[str, Any],
    cpe_base_string: str,
    versions: Optional[List[Dict[str, Any]]],
    has_confirmed_mapping: bool = False,
    cpe_suggestion_context: Optional[Dict[str, Any]] = None
) -> List[OrderedDict]:
    """
    Handle Pattern 3.1: No version data (single cpeMatch with wildcard version).
    
    Applicable Patterns:
        - Pattern A: No versions[] array present
        - Pattern A-Variant: Explicit wildcard version "*"
        - Pattern B: Empty versions array
        - Pattern C: Only version placeholder values
        - Pattern C-Variant: Placeholder version AND placeholder changes array
        - Pattern D: defaultStatus="unknown" with no/empty versions
    
    Args:
        affected_entry: CVE 5.0 affected[] array entry
        cpe_base_string: CPE 2.3 base string (vendor:product portion)
        versions: Versions array (may be None, empty, or contain placeholders only)
    
    Returns:
        List containing single cpeMatch object (or metadata-only for Pattern D)
    
    Examples:
        Pattern A (no versions array):
        >>> handle_pattern_3_1(
        ...     {"vendor": "acme", "product": "widget", "defaultStatus": "affected"},
        ...     "cpe:2.3:a:acme:widget",
        ...     None
        ... )
        [OrderedDict([('versionsEntryIndex', None), ('appliedPattern', 'noVersion.allAffected'), ...])]
        
        Pattern D (defaultStatus unknown):
        >>> handle_pattern_3_1(
        ...     {"vendor": "acme", "product": "widget", "defaultStatus": "unknown"},
        ...     "cpe:2.3:a:acme:widget",
        ...     None
        ... )
        [OrderedDict([('versionsEntryIndex', None), ('vulnerable', False), ...])]
    """
    default_status = affected_entry.get('defaultStatus', 'unknown')
    results = []
    
    # Pattern D: defaultStatus="unknown" → metadata-only cpeMatch
    if default_status == 'unknown':
        cpe_match = create_ordered_cpe_match(
            versions_entry_index=None,
            applied_pattern=None,
            vulnerable=False,
            concerns=["defaultStatusUnknown"]
        )
        results.append(cpe_match)
        logger.debug(f"Pattern 3.1-D: defaultStatus=unknown → metadata-only cpeMatch")
        return results
    
    # Determine pattern variant and versionsEntryIndex
    versions_entry_index = None
    applied_pattern = "noVersion.allAffected"
    
    if versions and len(versions) > 0:
        # Pattern A-Variant, C, or C-Variant
        first_entry = versions[0]
        version_value = first_entry.get('version')
        
        if version_value == "*":
            applied_pattern = "noVersion.explicitWildcard"
            versions_entry_index = 0
            # Use version.status if present, otherwise defaultStatus
            status = first_entry.get('status', default_status)
        else:
            # Pattern C or C-Variant (placeholder values)
            applied_pattern = "noVersion.placeholderValue"
            versions_entry_index = 0
            # Use version.status if present, otherwise defaultStatus
            status = first_entry.get('status', default_status)
    else:
        # Pattern A or B (no versions or empty versions)
        status = default_status
    
    # Determine vulnerability from status
    is_vulnerable = determine_vulnerability_from_status(status)
    
    # Check if we have confirmed CPE mapping
    if not has_confirmed_mapping:
        # No confirmed mapping - generate metadata-only with concern
        concern_type = _determine_cpe_confirmation_concern(cpe_suggestion_context)
        cpe_match = create_ordered_cpe_match(
            versions_entry_index=versions_entry_index,
            applied_pattern=applied_pattern,
            vulnerable=None,
            concerns=[concern_type]
        )
        results.append(cpe_match)
        logger.debug(
            f"Pattern 3.1: No confirmed CPE mapping → metadata-only with concern={concern_type}"
        )
        return results
    
    # Normalize and validate CPE base string (already complete 13-component CPE)
    full_criteria = normalize_cpe_base_string(cpe_base_string)
    
    # Create cpeMatch object
    cpe_match = create_ordered_cpe_match(
        versions_entry_index=versions_entry_index,
        applied_pattern=applied_pattern,
        vulnerable=is_vulnerable,
        criteria=full_criteria
    )
    
    results.append(cpe_match)
    
    logger.debug(
        f"Pattern 3.1: Generated wildcard cpeMatch "
        f"(pattern={applied_pattern}, vulnerable={is_vulnerable}, index={versions_entry_index})"
    )
    
    return results


# ===== PATTERN 3.2 HANDLER: NO AFFECTED PLATFORMS (METADATA-ONLY) =====

def handle_pattern_3_2(
    affected_entry: Dict[str, Any],
    versions: Optional[List[Dict[str, Any]]]
) -> List[OrderedDict]:
    """
    Handle Pattern 3.2: No affected platforms (metadata-only cpeMatch).
    
    Applicable Patterns:
        - Pattern A: defaultStatus='affected' but ALL versions='unaffected'
        - Pattern B: defaultStatus='unaffected' (nothing to output)
        - Pattern C: Placeholder versions with status='unaffected'
        - Pattern D: Any defaultStatus with ALL versions='unaffected'
        - Pattern E: Changes at same version as base (zero-width range)
    
    Args:
        affected_entry: CVE 5.0 affected[] array entry
        versions: Versions array (may be None, empty, or all unaffected)
    
    Returns:
        List containing metadata-only cpeMatch object(s)
    
    Logic:
        All patterns output cpeMatch with vulnerable=false and concerns=["noAffectedPlatforms"]
        1:1 transformation: Each unaffected version produces one metadata-only cpeMatch
    """
    results = []
    
    # If no versions array, create single metadata-only cpeMatch
    if not versions or len(versions) == 0:
        cpe_match = create_ordered_cpe_match(
            versions_entry_index=None,
            applied_pattern=None,
            vulnerable=False,
            concerns=["noAffectedPlatforms"]
        )
        results.append(cpe_match)
        logger.debug("Pattern 3.2: defaultStatus=unaffected, no versions → metadata-only")
        return results
    
    # Process each version entry (1:1 transformation)
    for index, version_entry in enumerate(versions):
        status = version_entry.get('status', affected_entry.get('defaultStatus', 'unknown'))
        
        # Check for zero-width range (changes at same version as base)
        changes = version_entry.get('changes', [])
        version_value = version_entry.get('version')
        
        is_zero_width = False
        if changes and version_value:
            for change in changes:
                if change.get('at') == version_value:
                    # Change occurs at same version → zero-width range
                    is_zero_width = True
                    break
        
        if is_zero_width or status == 'unaffected':
            # Create metadata-only cpeMatch
            # Use statusUnaffected for individual version entries
            cpe_match = create_ordered_cpe_match(
                versions_entry_index=index,
                applied_pattern=None,
                vulnerable=False,
                concerns=["statusUnaffected"]
            )
            results.append(cpe_match)
            logger.debug(f"Pattern 3.2: Version index {index} unaffected → metadata-only")
    
    return results


# ===== PATTERN 3.3 HANDLER: EXACT VERSIONS (1:1 TRANSFORMATION) =====

def handle_pattern_3_3(
    affected_entry: Dict[str, Any],
    cpe_base_string: str,
    versions: List[Dict[str, Any]],
    has_confirmed_mapping: bool = False,
    cpe_suggestion_context: Optional[Dict[str, Any]] = None
) -> List[OrderedDict]:
    """
    Handle Pattern 3.3: Exact versions (1:1 transformation).
    
    Applicable Patterns:
        - Pattern A: Single exact version
        - Pattern B: Multiple discrete versions
        - Pattern C: Mixed affected/unaffected/unknown versions
        - Pattern D: defaultStatus conflict (version.status takes precedence)
    
    Args:
        affected_entry: CVE 5.0 affected[] array entry
        cpe_base_string: CPE 2.3 base string
        versions: Versions array with exact version values
    
    Returns:
        List of cpeMatch objects (one per version entry - 1:1 transformation)
    
    Logic:
        - Each version entry produces exactly one cpeMatch object
        - versionType='git' → metadata-only with concerns=["versionTypeGit"]
        - Placeholder versions → metadata-only with concerns=["versionPlaceholder"]
        - status='affected' → full cpeMatch with criteria
        - status='unaffected' → metadata-only with concerns=["statusUnaffected"]
        - status='unknown' → metadata-only with concerns=["statusUnknown"]
        - version.status overrides defaultStatus
    """
    default_status = affected_entry.get('defaultStatus', 'unknown')
    results = []
    
    # PRE-SCAN: Check if ANY version in this entry's versions array has wildcard expansion pattern
    # If detected, this concern applies to ALL versions in this affected entry
    entry_has_wildcard_expansion = False
    for version_entry in versions:
        version_value = version_entry.get('version')
        if isinstance(version_value, str) and has_wildcard_expansion_pattern(version_value):
            entry_has_wildcard_expansion = True
            logger.debug(
                f"Pattern 3.3: Wildcard expansion detected in entry - will apply to all versions"
            )
            break
    
    # Process each version entry independently (1:1 transformation)
    for index, version_entry in enumerate(versions):
        version_value = version_entry.get('version')
        version_type = version_entry.get('versionType')
        
        # Check for versionType='git' (Section 6.1 requirement)
        # Git commit hashes cannot be processed - generate metadata-only cpeMatch
        if version_type == 'git':
            cpe_match = create_ordered_cpe_match(
                versions_entry_index=index,
                applied_pattern=None,
                vulnerable=False,
                concerns=["versionTypeGit"]
            )
            results.append(cpe_match)
            logger.debug(
                f"Pattern 3.3: versionType='git' at index {index} → "
                f"metadata-only (git commits require graph ordering)"
            )
            continue
        
        # Check for placeholder version values
        # Placeholder versions (n/a, unknown, etc.) cannot generate valid CPE strings
        if is_version_placeholder(version_value):
            cpe_match = create_ordered_cpe_match(
                versions_entry_index=index,
                applied_pattern="exact.placeholderValue",
                vulnerable=False,
                concerns=["versionPlaceholder"]
            )
            results.append(cpe_match)
            logger.debug(
                f"Pattern 3.3: Version '{version_value}' at index {index} → "
                f"metadata-only (placeholder version value)"
            )
            continue
        
        # Determine status (version.status overrides defaultStatus)
        status = version_entry.get('status', default_status)
        
        # Initialize concerns with entry-level wildcard detection
        concerns = []
        if entry_has_wildcard_expansion:
            concerns.append("inferredAffectedFromWildcardExpansion")
        
        # Handle different status values
        if status == 'affected':
            # Check if we have confirmed CPE mapping
            if not has_confirmed_mapping:
                # No confirmed mapping - generate metadata-only with concern
                concern_type = _determine_cpe_confirmation_concern(cpe_suggestion_context)
                concerns.append(concern_type)
                
                # If wildcard expansion detected, use inference pattern; otherwise exact pattern
                pattern_value = "inference.affectedFromWildcardExpansion" if "inferredAffectedFromWildcardExpansion" in concerns else "exact.single"
                
                cpe_match = create_ordered_cpe_match(
                    versions_entry_index=index,
                    applied_pattern=pattern_value,
                    vulnerable=None,  # Metadata-only: no vulnerable field when we can't determine proper CPE
                    concerns=concerns if concerns else None
                )
                logger.debug(
                    f"Pattern 3.3: Version '{version_value}' at index {index} → "
                    f"metadata-only (no confirmed CPE mapping, concern={concern_type})"
                )
            else:
                # Full cpeMatch with criteria (only if confirmed)
                is_vulnerable = True
                
                # Apply update pattern extraction (Section 4.1 requirement)
                # Example: "10.0 SP 1" → base="10.0", update="sp1"
                base_version, update_component, transformed_version = transform_version_with_update_pattern(version_value)
                
                if base_version and update_component:
                    # Update pattern detected - split version into base + update component
                    # cpe_base_string format: cpe:2.3:a:vendor:product:*:*:*:*:*:*:*:*
                    # Replace component 5 (version) with base_version, component 6 (update) with update_component
                    parts = cpe_base_string.split(':')
                    parts[5] = base_version  # version component
                    parts[6] = update_component  # update component
                    full_criteria = ':'.join(parts)
                    logger.debug(
                        f"Pattern 3.3: Update pattern detected in '{version_value}' → "
                        f"base='{base_version}', update='{update_component}'"
                    )
                else:
                    # No update pattern - use version as-is with wildcard update field
                    # Replace component 5 (version) with version_value
                    parts = cpe_base_string.split(':')
                    parts[5] = version_value  # version component
                    full_criteria = ':'.join(parts)
                
                # Determine applied pattern based on wildcard detection
                pattern_value = "inference.affectedFromWildcardExpansion" if "inferredAffectedFromWildcardExpansion" in concerns else "exact.single"
                
                cpe_match = create_ordered_cpe_match(
                    versions_entry_index=index,
                    applied_pattern=pattern_value,
                    vulnerable=is_vulnerable,
                    criteria=full_criteria,
                    concerns=concerns if concerns else None
                )
                
                logger.debug(
                    f"Pattern 3.3: Exact version '{version_value}' at index {index} → "
                    f"vulnerable cpeMatch with criteria '{full_criteria}'"
                )
        
        elif status == 'unaffected':
            # Metadata-only cpeMatch
            unaffected_concerns = concerns + ["statusUnaffected"] if concerns else ["statusUnaffected"]
            cpe_match = create_ordered_cpe_match(
                versions_entry_index=index,
                applied_pattern=None,
                vulnerable=False,
                concerns=unaffected_concerns
            )
            
            logger.debug(
                f"Pattern 3.3: Exact version '{version_value}' at index {index} → "
                f"metadata-only (unaffected)"
            )
        
        else:  # status == 'unknown'
            # Metadata-only cpeMatch
            unknown_concerns = concerns + ["statusUnknown"] if concerns else ["statusUnknown"]
            cpe_match = create_ordered_cpe_match(
                versions_entry_index=index,
                applied_pattern=None,
                vulnerable=False,
                concerns=unknown_concerns
            )
            
            logger.debug(
                f"Pattern 3.3: Exact version '{version_value}' at index {index} → "
                f"metadata-only (unknown)"
            )
        
        results.append(cpe_match)
    
    return results


# ===== PATTERN 3.4 HANDLER: SINGLE RANGE PER ENTRY (1:1 TRANSFORMATION) =====

def handle_pattern_3_4(
    affected_entry: Dict[str, Any],
    cpe_base_string: str,
    versions: List[Dict[str, Any]],
    has_confirmed_mapping: bool = False,
    cpe_suggestion_context: Optional[Dict[str, Any]] = None
) -> List[OrderedDict]:
    """
    Handle Pattern 3.4: Single range per entry (1:1 transformation).
    
    Applicable Patterns:
        - Pattern A: Explicit range with lessThan
        - Pattern B: Explicit range with lessThanOrEqual
        - Pattern C: Wildcard in lessThanOrEqual (open-ended)
        - Pattern D: Single status change (changes array)
        - Pattern D-Variant: Placeholder version with real changes data
        - Pattern E: Inverse single change (unaffected→affected)
        - Pattern F: Open-ended beginning (no version field)
        - Pattern G: Placeholder in upper bound
        - Pattern H: version="0" special case
        - Pattern I: defaultStatus override
    
    Args:
        affected_entry: CVE 5.0 affected[] array entry
        cpe_base_string: CPE 2.3 base string
        versions: Versions array with range operators or changes
    
    Returns:
        List of cpeMatch objects (one per version entry - 1:1 transformation)
    
    Logic:
        - Each version entry produces exactly one cpeMatch object
        - Range fields: versionStartIncluding/Excluding, versionEndIncluding/Excluding
        - Wildcard or placeholder upper bounds → omit versionEnd (open-ended)
        - status='affected' or changes resulting in affected → full cpeMatch
        - status='unaffected'/'unknown' → metadata-only cpeMatch
    """
    default_status = affected_entry.get('defaultStatus', 'unknown')
    results = []
    
    # PRE-SCAN: Check if ANY version in this entry's versions array has wildcard expansion pattern
    # If detected, this concern applies to ALL versions in this affected entry
    # Check in: version, lessThan, lessThanOrEqual fields
    entry_has_wildcard_expansion = False
    for version_entry in versions:
        version_value = version_entry.get('version')
        less_than = version_entry.get('lessThan')
        less_than_or_equal = version_entry.get('lessThanOrEqual')
        
        if (version_value and isinstance(version_value, str) and has_wildcard_expansion_pattern(version_value)) or \
           (less_than and isinstance(less_than, str) and has_wildcard_expansion_pattern(less_than)) or \
           (less_than_or_equal and isinstance(less_than_or_equal, str) and has_wildcard_expansion_pattern(less_than_or_equal)):
            entry_has_wildcard_expansion = True
            logger.debug(
                f"Pattern 3.4: Wildcard expansion detected in entry - will apply to all versions"
            )
            break
    
    # Process each version entry independently (1:1 transformation)
    for index, version_entry in enumerate(versions):
        version_value = version_entry.get('version')
        version_type = version_entry.get('versionType')
        
        # Check for versionType='git' (Section 6.1 requirement)
        # Git commit hashes cannot be processed - generate metadata-only cpeMatch
        if version_type == 'git':
            cpe_match = create_ordered_cpe_match(
                versions_entry_index=index,
                applied_pattern=None,
                vulnerable=False,
                concerns=["versionTypeGit"]
            )
            results.append(cpe_match)
            logger.debug(
                f"Pattern 3.4: versionType='git' at index {index} → "
                f"metadata-only (git commits require graph ordering)"
            )
            continue
        
        # Determine status (version.status overrides defaultStatus)
        status = version_entry.get('status', default_status)
        
        # Get changes array early to check for inverse changes (unaffected→affected)
        changes = version_entry.get('changes', [])
        less_than = version_entry.get('lessThan')
        less_than_or_equal = version_entry.get('lessThanOrEqual')
        
        # Initialize wildcard concerns from entry-level detection
        early_wildcard_concerns = []
        if entry_has_wildcard_expansion:
            early_wildcard_concerns.append("inferredAffectedFromWildcardExpansion")
        
        # Check for inverse change (Pattern E: unaffected→affected)
        # This must be checked BEFORE the unaffected status check
        is_inverse_change = False
        if status == 'unaffected' and changes and len(changes) > 0:
            first_change = changes[0]
            if first_change.get('status') == 'affected':
                is_inverse_change = True
        
        # Handle unaffected/unknown status → metadata-only (unless inverse change)
        if status == 'unaffected' and not is_inverse_change:
            # Include wildcard concerns if detected
            unaffected_concerns = ["statusUnaffected"] + early_wildcard_concerns
            cpe_match = create_ordered_cpe_match(
                versions_entry_index=index,
                applied_pattern=None,
                vulnerable=False,
                concerns=unaffected_concerns
            )
            results.append(cpe_match)
            concern_msg = f" with {early_wildcard_concerns}" if early_wildcard_concerns else ""
            logger.debug(f"Pattern 3.4: Version index {index} unaffected → metadata-only{concern_msg}")
            continue
        
        if status == 'unknown':
            # Include wildcard concerns if detected
            unknown_concerns = ["statusUnknown"] + early_wildcard_concerns
            cpe_match = create_ordered_cpe_match(
                versions_entry_index=index,
                applied_pattern=None,
                vulnerable=False,
                concerns=unknown_concerns
            )
            results.append(cpe_match)
            concern_msg = f" with {early_wildcard_concerns}" if early_wildcard_concerns else ""
            logger.debug(f"Pattern 3.4: Version index {index} unknown → metadata-only{concern_msg}")
            continue
        
        # Status is 'affected' OR inverse change → detect range pattern
        # Pattern detection happens BEFORE checking confirmed mapping (for traceability)
        less_than = version_entry.get('lessThan')
        less_than_or_equal = version_entry.get('lessThanOrEqual')
        
        # Initialize range boundaries
        version_start_including = None
        version_start_excluding = None
        version_end_including = None
        version_end_excluding = None
        applied_pattern = None
        
        # Initialize concerns with early wildcard detection results
        concerns = early_wildcard_concerns.copy()
        
        # Detect update patterns in range boundaries (Section 4.1 + Section 6.2 requirement)
        # Update patterns are DETECTED but NOT APPLIED for range boundaries
        has_update_pattern_in_boundaries = False
        
        # Check version field for update patterns (wildcards already detected earlier)
        if version_value and isinstance(version_value, str):
            base_v, update_v, _ = transform_version_with_update_pattern(version_value)
            if base_v and update_v:
                has_update_pattern_in_boundaries = True
                logger.debug(
                    f"Pattern 3.4: Update pattern detected in version boundary '{version_value}' → "
                    f"base='{base_v}', update='{update_v}' (NOT APPLIED per Section 6.2)"
                )
        
        # Check lessThan field for update patterns (wildcards already detected earlier)
        if less_than and isinstance(less_than, str):
            base_lt, update_lt, _ = transform_version_with_update_pattern(less_than)
            if base_lt and update_lt:
                has_update_pattern_in_boundaries = True
                logger.debug(
                    f"Pattern 3.4: Update pattern detected in lessThan boundary '{less_than}' → "
                    f"base='{base_lt}', update='{update_lt}' (NOT APPLIED per Section 6.2)"
                )
        
        # Check lessThanOrEqual field for update patterns (wildcards already detected earlier)
        if less_than_or_equal and isinstance(less_than_or_equal, str):
            base_lte, update_lte, _ = transform_version_with_update_pattern(less_than_or_equal)
            if base_lte and update_lte:
                has_update_pattern_in_boundaries = True
                logger.debug(
                    f"Pattern 3.4: Update pattern detected in lessThanOrEqual boundary '{less_than_or_equal}' → "
                    f"base='{base_lte}', update='{update_lte}' (NOT APPLIED per Section 6.2)"
                )
        
        # Check changes[].at field for update patterns
        if changes and len(changes) > 0:
            for change in changes:
                change_at = change.get('at')
                if change_at and isinstance(change_at, str):
                    base_ch, update_ch, _ = transform_version_with_update_pattern(change_at)
                    if base_ch and update_ch:
                        has_update_pattern_in_boundaries = True
                        logger.debug(
                            f"Pattern 3.4: Update pattern detected in changes[].at '{change_at}' → "
                            f"base='{base_ch}', update='{update_ch}' (NOT APPLIED per Section 6.2)"
                        )
        
        # Add concern if update patterns were detected in range boundaries
        if has_update_pattern_in_boundaries:
            concerns.append("updatePatternsInRange")
        
        # Determine range pattern
        if less_than:
            # Pattern A or H: Explicit range with lessThan
            if version_value and not is_version_placeholder(version_value):
                version_start_including = version_value
                applied_pattern = "range.lessThan"
                if version_value == "0":
                    applied_pattern = "range.zeroStart"
            else:
                # Pattern F: Open-ended beginning (no version or placeholder)
                applied_pattern = "range.openStart"
            
            # Check upper bound
            if not is_version_placeholder(less_than):
                version_end_excluding = less_than
            else:
                # Pattern G: Placeholder in upper bound → open-ended
                applied_pattern = "range.placeholderUpperBound"
        
        elif less_than_or_equal:
            # Pattern B: Explicit range with lessThanOrEqual
            if version_value and not is_version_placeholder(version_value):
                version_start_including = version_value
            
            # Check upper bound
            if less_than_or_equal == "*" or is_version_placeholder(less_than_or_equal):
                # Pattern C: Wildcard/placeholder → open-ended
                applied_pattern = "range.openEnd"
            else:
                version_end_including = less_than_or_equal
                applied_pattern = "range.lessThanOrEqual"
        
        elif changes and len(changes) > 0:
            # Pattern D, D-Variant, or E: Changes array
            first_change = changes[0]
            change_at = first_change.get('at')
            change_status = first_change.get('status')
            
            if status == 'affected' and change_status == 'unaffected':
                # Pattern D: affected → unaffected (fix)
                if version_value and not is_version_placeholder(version_value):
                    version_start_including = version_value
                    applied_pattern = "range.changesFixed"
                else:
                    # Pattern D-Variant: Placeholder version with real changes
                    applied_pattern = "range.placeholderChanges"
                
                # Set upper bound from changes[].at
                if change_at and not is_version_placeholder(change_at):
                    version_end_excluding = change_at
            
            elif status == 'unaffected' and change_status == 'affected':
                # Pattern E: unaffected → affected (introduced)
                if change_at and not is_version_placeholder(change_at):
                    version_start_including = change_at
                    applied_pattern = "range.changesIntroduced"
                    # Open-ended end (no version_end)
        
        # Handle exact versions within Pattern 3.4 context
        # This occurs when an affected entry contains both ranges and exact versions
        # Example: versions: [{"version": "4.15", "status": "affected"}, {"version": "0", "lessThan": "4.19", ...}]
        if applied_pattern is None and version_value and not is_version_placeholder(version_value):
            # This is an exact version (no range operators, no changes)
            # Delegate to Pattern 3.3 logic for this specific entry
            exact_result = handle_pattern_3_3(
                affected_entry, 
                cpe_base_string, 
                [version_entry],  # Pass single entry as list
                has_confirmed_mapping,
                cpe_suggestion_context=cpe_suggestion_context
            )
            # Extract the single result and adjust index
            if exact_result and len(exact_result) > 0:
                exact_match = exact_result[0]
                # Update versionsEntryIndex to reflect correct position in original array
                exact_match['versionsEntryIndex'] = index
                results.append(exact_match)
                logger.debug(
                    f"Pattern 3.4: Exact version '{version_value}' at index {index} → "
                    f"delegated to Pattern 3.3 handler (mixed entry context)"
                )
                continue
        
        # Check if pattern detection succeeded
        if applied_pattern is None:
            # Pattern detection failed - unsupported or malformed version data
            # Generate metadata-only cpeMatch regardless of CPE mapping status
            concerns.append("patternUnsupported")
            logger.warning(
                f"Pattern 3.4: Version index {index} - no recognized pattern matched "
                f"(has_lessThan={bool(less_than)}, has_lessThanOrEqual={bool(less_than_or_equal)}, "
                f"has_changes={bool(changes)}, status={status}) | Generating metadata-only cpeMatch"
            )
            
            # Add CPE confirmation concern if no confirmed mapping
            if not has_confirmed_mapping:
                concern_type = _determine_cpe_confirmation_concern(cpe_suggestion_context)
                if concern_type not in concerns:
                    concerns.append(concern_type)
            
            cpe_match = create_ordered_cpe_match(
                versions_entry_index=index,
                applied_pattern=None,
                vulnerable=False,
                concerns=concerns
            )
            results.append(cpe_match)
            logger.debug(
                f"Pattern 3.4: Range at index {index} → "
                f"cpeMatch (pattern=None, start=None, end=None, concerns={concerns})"
            )
            continue
        
        # Override applied_pattern if wildcard expansion detected (known future pattern)
        if "inferredAffectedFromWildcardExpansion" in concerns:
            applied_pattern = "inference.affectedFromWildcardExpansion"
        
        # Check if we have confirmed CPE mapping
        if not has_confirmed_mapping:
            # No confirmed mapping - generate metadata-only with concern
            # Still include range fields for traceability
            concern_type = _determine_cpe_confirmation_concern(cpe_suggestion_context)
            if concern_type not in concerns:
                concerns.append(concern_type)
            
            cpe_match = create_ordered_cpe_match(
                versions_entry_index=index,
                applied_pattern=applied_pattern,  # Preserve detected pattern for traceability
                vulnerable=None,
                version_start_including=version_start_including,
                version_start_excluding=version_start_excluding,
                version_end_including=version_end_including,
                version_end_excluding=version_end_excluding,
                concerns=concerns if concerns else None
            )
            results.append(cpe_match)
            logger.debug(
                f"Pattern 3.4: Version index {index} (pattern={applied_pattern}) → "
                f"metadata-only (no confirmed CPE mapping, range fields preserved, concerns={concerns})"
            )
            continue
        
        # Has confirmed mapping - build full cpeMatch with criteria
        # Normalize and validate CPE base string (already complete 13-component CPE)
        full_criteria = normalize_cpe_base_string(cpe_base_string)
        
        # Create cpeMatch object with range fields
        # Include concerns array if update patterns were detected
        cpe_match = create_ordered_cpe_match(
            versions_entry_index=index,
            applied_pattern=applied_pattern,
            vulnerable=True,
            criteria=full_criteria,
            version_start_including=version_start_including,
            version_start_excluding=version_start_excluding,
            version_end_including=version_end_including,
            version_end_excluding=version_end_excluding,
            concerns=concerns if concerns else None
        )
        
        results.append(cpe_match)
        
        concern_msg = f", concerns={concerns}" if concerns else ""
        logger.debug(
            f"Pattern 3.4: Range at index {index} → "
            f"cpeMatch (pattern={applied_pattern}, start={version_start_including}, "
            f"end={version_end_excluding or version_end_including}{concern_msg})"
        )
    
    return results


# ===== PATTERN 3.5 HANDLER: MULTIPLE RANGES FROM ONE ENTRY (1:M TRANSFORMATION) =====

def handle_pattern_3_5(
    affected_entry: Dict[str, Any],
    cpe_base_string: str,
    versions: List[Dict[str, Any]],
    has_confirmed_mapping: bool = False,
    cpe_suggestion_context: Optional[Dict[str, Any]] = None
) -> List[OrderedDict]:
    """
    Handle Pattern 3.5: Multiple ranges from one entry (1:M transformation).
    
    Single version entry with multiple status transitions producing multiple ranges.
    
    Applicable Patterns:
        - Pattern A: Multiple status flip-flops (affected → unaffected → affected → unaffected)
        - Pattern B: Changes combined with range bounds (lessThan + changes array)
    
    Args:
        affected_entry: CVE 5.0 affected[] array entry
        cpe_base_string: CPE 2.3 base string (vendor:product portion)
        versions: Versions array (guaranteed to have data requiring Pattern 3.5)
        has_confirmed_mapping: Whether cpe_base_string is from confirmed CPE mapping
        cpe_suggestion_context: Optional dict with 'top10SuggestedCPEBaseStrings' array
    
    Returns:
        List of cpeMatch objects (multiple per version entry for affected ranges)
    
    Logic:
        - Process changes array chronologically
        - Track status state across transitions (affected ↔ unaffected)
        - Create separate cpeMatch for each affected segment
        - lessThan/lessThanOrEqual defines outer boundary (if present)
        - changes[].at values define inner boundaries
    """
    results = []
    default_status = affected_entry.get('defaultStatus', 'unknown')
    
    for index, version_entry in enumerate(versions):
        version = version_entry.get('version')
        status = version_entry.get('status', default_status)
        changes = version_entry.get('changes', [])
        less_than = version_entry.get('lessThan')
        less_than_or_equal = version_entry.get('lessThanOrEqual')
        version_type = version_entry.get('versionType')
        
        # Skip if versionType is 'git' - generate metadata-only cpeMatch
        if version_type and version_type.lower() == 'git':
            if has_confirmed_mapping:
                cpe_match = create_ordered_cpe_match(
                    versions_entry_index=index,
                    applied_pattern="multiRange.versionTypeGit",
                    vulnerable=True,
                    criteria=normalize_cpe_base_string(cpe_base_string),
                    concerns=["versionTypeGit"]
                )
                results.append(cpe_match)
                logger.debug(f"Pattern 3.5: Git version at index {index} → metadata-only cpeMatch")
            continue
        
        # Validate that this entry actually has multiple valid transitions
        # (Classifier should have caught this, but double-check for data integrity)
        valid_changes = [c for c in changes if c.get('at') and not is_version_placeholder(c.get('at'))]
        
        if len(valid_changes) <= 1 and not (valid_changes and (less_than or less_than_or_equal)):
            # Classification mismatch - this should be Pattern 3.3 or 3.4, not 3.5
            # This indicates either:
            # 1. Data changed between classification and handling (very rare)
            # 2. Bug in classifier (should be fixed if this occurs frequently)
            logger.warning(
                f"Pattern 3.5: Entry at index {index} doesn't have multiple valid ranges "
                f"(only {len(valid_changes)} valid changes) | "
                f"Classification mismatch - generating metadata-only cpeMatch"
            )
            
            concern_type = _determine_cpe_confirmation_concern(cpe_suggestion_context) if not has_confirmed_mapping else None
            concerns = ["patternUnsupported"]
            if concern_type:
                concerns.append(concern_type)
            
            cpe_match = create_ordered_cpe_match(
                versions_entry_index=index,
                applied_pattern=None,
                vulnerable=False,
                concerns=concerns
            )
            results.append(cpe_match)
            continue
        
        # Build transition timeline
        # Timeline format: [(version_value, status_value, source_description)]
        timeline = []
        
        # Add initial version/status as starting point
        if version and not is_version_placeholder(version):
            timeline.append((version, status, "version"))
        
        # Add all changes chronologically (assume changes array is already sorted)
        for change in changes:
            change_at = change.get('at')
            change_status = change.get('status', default_status)
            if change_at and not is_version_placeholder(change_at):
                timeline.append((change_at, change_status, "change"))
        
        # Add upper bound if present (becomes the end of final range)
        if less_than and not is_version_placeholder(less_than):
            # lessThan doesn't create a new status, it's just a boundary
            # The status at this boundary is the opposite of what we want (it's where we stop)
            timeline.append((less_than, None, "lessThan"))
        elif less_than_or_equal and not is_version_placeholder(less_than_or_equal):
            timeline.append((less_than_or_equal, None, "lessThanOrEqual"))
        
        # Track current status and build affected ranges
        affected_ranges = []  # List of (start_version, end_version, start_inclusive, end_inclusive) tuples
        
        # Process timeline to extract affected ranges
        current_status = None
        range_start = None
        range_start_inclusive = True
        
        for i, (ver, stat, source) in enumerate(timeline):
            if source == "version":
                # Starting point
                current_status = stat
                if stat == "affected":
                    range_start = ver
                    range_start_inclusive = True
            
            elif source == "change":
                # Status transition
                if current_status == "affected" and stat != "affected":
                    # End of affected range (transition to unaffected)
                    if range_start is not None:
                        affected_ranges.append((range_start, ver, range_start_inclusive, False))
                        range_start = None
                
                elif current_status != "affected" and stat == "affected":
                    # Start of affected range (transition to affected)
                    range_start = ver
                    range_start_inclusive = True
                
                current_status = stat
            
            elif source in ["lessThan", "lessThanOrEqual"]:
                # Upper boundary
                if current_status == "affected" and range_start is not None:
                    # Close the final affected range
                    end_inclusive = (source == "lessThanOrEqual")
                    affected_ranges.append((range_start, ver, range_start_inclusive, end_inclusive))
                    range_start = None
        
        # Handle open-ended affected range (no upper bound)
        if current_status == "affected" and range_start is not None:
            affected_ranges.append((range_start, None, range_start_inclusive, False))
        
        # Generate cpeMatch for each affected range
        for range_start_ver, range_end_ver, start_inclusive, end_inclusive in affected_ranges:
            # Determine which pattern to use
            if less_than or less_than_or_equal:
                applied_pattern = "multiRange.rangeStatusTransitions"
            else:
                applied_pattern = "multiRange.exactStatusTransitions"
            
            # Build version start/end fields
            version_start_including = range_start_ver if start_inclusive else None
            version_start_excluding = range_start_ver if not start_inclusive else None
            version_end_including = range_end_ver if end_inclusive else None
            version_end_excluding = range_end_ver if not end_inclusive and range_end_ver is not None else None
            
            # Check for concerns (no update pattern checking in ranges for Pattern 3.5)
            concerns = None
            
            # Create cpeMatch object
            if not has_confirmed_mapping:
                # Metadata-only when no confirmed CPE mapping
                # Still include range fields for traceability (like Pattern 3.4)
                concern_type = _determine_cpe_confirmation_concern(cpe_suggestion_context)
                cpe_match = create_ordered_cpe_match(
                    versions_entry_index=index,
                    applied_pattern=applied_pattern,
                    vulnerable=None,
                    version_start_including=version_start_including,
                    version_start_excluding=version_start_excluding,
                    version_end_including=version_end_including,
                    version_end_excluding=version_end_excluding,
                    concerns=[concern_type]
                )
                results.append(cpe_match)
                logger.debug(
                    f"Pattern 3.5: Multi-range at index {index} → metadata-only "
                    f"(no CPE mapping, {concern_type}, range fields preserved)"
                )
                continue
            
            # Has confirmed mapping - build full cpeMatch
            # Normalize and validate CPE base string (already complete 13-component CPE)
            full_criteria = normalize_cpe_base_string(cpe_base_string)
            
            cpe_match = create_ordered_cpe_match(
                versions_entry_index=index,
                applied_pattern=applied_pattern,
                vulnerable=True,
                criteria=full_criteria,
                version_start_including=version_start_including,
                version_start_excluding=version_start_excluding,
                version_end_including=version_end_including,
                version_end_excluding=version_end_excluding,
                concerns=concerns if concerns else None
            )
            
            results.append(cpe_match)
            
            logger.debug(
                f"Pattern 3.5: Multi-range at index {index} → "
                f"cpeMatch (start={range_start_ver}, end={range_end_ver})"
            )
    
    return results


# ===== SECTION 4.2: UPDATE FIELD SPECIFICITY POSTPROCESSING =====

def apply_update_field_specificity(cpe_matches: List[OrderedDict]) -> List[OrderedDict]:
    """
    Apply Section 4.2 postprocessing: Convert wildcard update (*) to no-update (-) 
    when specific update values exist for the same base CPE components.
    
    Problem: Version extraction may generate both:
        - Generic: cpe:...:1.0:*:... (any update)
        - Specific: cpe:...:1.0:patch1:... (specific update)
    
    Resolution: Convert wildcard update (*) to no-update (-) when specific updates 
    exist for same base, ensuring each match has distinct scope and preventing overlap.
    
    Args:
        cpe_matches: List of cpeMatch objects from pattern generation
    
    Returns:
        List of cpeMatch objects with update field specificity enforced
    
    Logic:
        1. Group cpeMatch objects by base components (excluding update field at position 6)
        2. Identify groups with both wildcard (*) and specific update values
        3. Convert wildcard to no-update (-) to eliminate overlap
        4. Preserve all specific update values unchanged
    
    Note: This is applied AFTER all pattern processing is complete, before final output.
    
    Examples:
        Before: cpe:...:1.0:*:... + cpe:...:1.0:patch1:...
        After:  cpe:...:1.0:-:... + cpe:...:1.0:patch1:...
    """
    if not cpe_matches:
        return cpe_matches
    
    # Only process cpeMatch objects that have criteria (full CPE strings)
    # Metadata-only objects don't have CPE criteria to process
    matches_with_criteria = [m for m in cpe_matches if m.get('criteria')]
    if not matches_with_criteria:
        return cpe_matches
    
    # Group by base CPE components (parts 0-5 and 7-10, excluding update field at position 6)
    # Base format: cpe:2.3:part:vendor:product:version:UPDATE:sw_edition:target_sw:target_hw:other:language
    #              0   1   2    3      4       5       6      7          8         9          10    11
    
    groups = {}  # Dict[base_key, List[cpe_match_object]]
    
    for match in matches_with_criteria:
        criteria = match.get('criteria', '')
        if not criteria:
            continue
        
        # Split CPE string to extract components
        parts = criteria.split(':')
        if len(parts) < 12:
            # Invalid CPE format - skip
            continue
        
        # Create base key excluding update field (position 6)
        # Join parts 0-5 and 7-11
        base_parts = parts[0:6] + parts[7:12]
        base_key = ':'.join(base_parts)
        
        if base_key not in groups:
            groups[base_key] = []
        groups[base_key].append(match)
    
    # Process each group to enforce update field specificity
    modified_count = 0
    
    for base_key, group_matches in groups.items():
        if len(group_matches) < 2:
            # Single match in group - no overlap possible
            continue
        
        # Extract update values from group
        has_wildcard = False
        has_specific = False
        wildcard_match = None
        
        for match in group_matches:
            criteria = match.get('criteria', '')
            parts = criteria.split(':')
            update_value = parts[6] if len(parts) > 6 else '*'
            
            if update_value == '*':
                has_wildcard = True
                wildcard_match = match
            elif update_value != '-':
                # Any value other than * or - is a specific update
                has_specific = True
        
        # If group has both wildcard and specific update values, convert wildcard to no-update
        if has_wildcard and has_specific and wildcard_match:
            criteria = wildcard_match.get('criteria', '')
            parts = criteria.split(':')
            
            # Replace update field (position 6) from * to -
            parts[6] = '-'
            new_criteria = ':'.join(parts)
            
            # Update the criteria in the match object
            wildcard_match['criteria'] = new_criteria
            modified_count += 1
            
            logger.debug(
                f"Section 4.2: Converted update field * → - to prevent overlap "
                f"(base: {base_key.split(':')[3]}:{base_key.split(':')[4]}:{base_key.split(':')[5]})"
            )
    
    if modified_count > 0:
            logger.info(
                f"Section 4.2 CPE Update Field Specificity: Converted {modified_count} wildcard update "
                f"fields (*) to no-update (-) to prevent overlap with specific update values",
                group="cpe_as_generation"
            )
    return cpe_matches


# ===== MAIN GENERATION FUNCTION =====

def generate_cpe_as(
    affected_entry: Dict[str, Any],
    cpe_base_string: str,
    has_confirmed_mapping: bool = False,
    cpe_suggestion_context: Optional[Dict[str, Any]] = None
) -> List[OrderedDict]:
    """
    Generate CPE Applicability Statement from CVE 5.0 affected[] entry.
    
    This is the main entry point for CPE-AS generation. It classifies the input
    pattern and delegates to the appropriate handler function.
    
    Args:
        affected_entry: CVE 5.0 affected[] array entry
        cpe_base_string: CPE 2.3 base string (e.g., "cpe:2.3:a:vendor:product")
        has_confirmed_mapping: Whether this CPE base string is from a confirmed mapping
        cpe_suggestion_context: Optional dict with 'top10SuggestedCPEBaseStrings' array
    
    Returns:
        List of cpeMatch objects (OrderedDict instances)
        - If has_confirmed_mapping=True: Full cpeMatch with criteria
        - If has_confirmed_mapping=False: Metadata-only with concerns
    
    Raises:
        ValueError: If required fields are missing or invalid
        NotImplementedError: If pattern is not yet supported
    
    Examples:
        >>> generate_cpe_as(
        ...     {"vendor": "acme", "product": "widget", "defaultStatus": "affected"},
        ...     "cpe:2.3:a:acme:widget",
        ...     has_confirmed_mapping=True
        ... )
        [OrderedDict([('versionsEntryIndex', None), ...])]
    """
    # Validate inputs
    if not affected_entry:
        raise ValueError("affected_entry cannot be None or empty")
    
    if not cpe_base_string:
        raise ValueError("cpe_base_string cannot be None or empty")
    
    # Extract versions array
    versions = affected_entry.get('versions')
    
    # Classify pattern
    pattern_category = classify_pattern(affected_entry, versions)
    
    logger.debug(
        f"CPE-AS Generation: pattern={pattern_category}, "
        f"vendor={affected_entry.get('vendor')}, "
        f"product={affected_entry.get('product')}"
    )
    
    # Delegate to pattern-specific handler
    if pattern_category == "3.1":
        results = handle_pattern_3_1(
            affected_entry, cpe_base_string, versions,
            has_confirmed_mapping, cpe_suggestion_context
        )
    elif pattern_category == "3.2":
        # Pattern 3.2: No affected platforms (metadata-only)
        results = handle_pattern_3_2(affected_entry, versions)
    elif pattern_category == "3.3":
        # Pattern 3.3: Exact versions (1:1 transformation)
        results = handle_pattern_3_3(
            affected_entry, cpe_base_string, versions,
            has_confirmed_mapping, cpe_suggestion_context
        )
    elif pattern_category == "3.4":
        # Pattern 3.4: Single range per entry (1:1 transformation)
        results = handle_pattern_3_4(
            affected_entry, cpe_base_string, versions,
            has_confirmed_mapping, cpe_suggestion_context
        )
    elif pattern_category == "3.5":
        # Pattern 3.5: Multiple ranges from one entry (1:M transformation)
        results = handle_pattern_3_5(
            affected_entry, cpe_base_string, versions,
            has_confirmed_mapping, cpe_suggestion_context
        )
    else:
        raise ValueError(f"Unknown pattern category: {pattern_category}")
    
    # Apply Section 4.2 postprocessing: Update field specificity enforcement
    # This must run AFTER all pattern handlers to process complete result set
    results = apply_update_field_specificity(results)
    
    return results
