<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hashmire/Analysis_Tools v0.2.0 - Source Mapping Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2E7D32 0%, #388E3C 25%, #43A047 50%, #4CAF50 75%, #66BB6A 100%);
            min-height: 100vh;
            padding: 20px;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 30%, rgba(67, 160, 71, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 80% 70%, rgba(56, 142, 60, 0.2) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            box-shadow: 
                0 25px 50px rgba(46, 125, 50, 0.4),
                0 15px 35px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2E7D32 0%, #388E3C 20%, #43A047 40%, #4CAF50 60%, #43A047 80%, #388E3C 100%);
            color: white;
            padding: 40px 50px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            transform: translateX(-100%);
            animation: shimmer 1s infinite;
        }
        
        @keyframes shimmer {
            to { transform: translateX(100%); }
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .file-selector {
            background: linear-gradient(135deg, #2E4C3E 0%, #3C5A4B 50%, #4A6B58 100%);
            color: #F3F4F6;
            padding: 18px 28px;
            text-align: left;
            position: relative;
            border: 1px solid rgba(76, 175, 80, 0.2);
            border-radius: 10px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.12), 0 1px 6px rgba(76, 175, 80, 0.08);
            backdrop-filter: blur(6px);
            transition: padding 0.3s ease;
        }

        .file-selector.expanded {
            padding: 22px 28px; /* More padding when documentation is expanded */
        }
        
        .file-selector::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.1) 0%, rgba(102, 187, 106, 0.05) 100%);
        }
        
        .file-selector::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 20%;
            right: 20%;
            height: 1px;
            background: linear-gradient(90deg, transparent, #4CAF50, #66BB6A, #4CAF50, transparent);
        }

        .file-input-container {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 20px;
            max-width: 1000px;
            margin: 0 auto;
            justify-content: space-between;
            position: relative;
        }

        .file-input-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            bottom: 0;
            width: 1px;
            background: linear-gradient(to bottom, transparent 0%, rgba(76, 175, 80, 0.3) 20%, rgba(76, 175, 80, 0.5) 50%, rgba(76, 175, 80, 0.3) 80%, transparent 100%);
            transform: translateX(-50%);
        }

        .file-input-main {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 0 0 48%;
            max-width: 48%;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.15) 0%, rgba(102, 187, 106, 0.12) 100%);
            border: 1px solid rgba(76, 175, 80, 0.3);
            border-radius: 7px;
            padding: 10px 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 220px;
            justify-content: center;
            color: #F3F4F6;
            font-family: inherit;
            font-size: 0.9em;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.1);
        }
        
        .file-input-wrapper::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.1) 0%, rgba(102, 187, 106, 0.05) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 6px;
        }

        .file-input-wrapper:hover {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.18) 0%, rgba(102, 187, 106, 0.12) 100%);
            border-color: rgba(76, 175, 80, 0.35);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.15);
        }
        
        .file-input-wrapper:hover::before {
            opacity: 1;
        }

        .file-input-wrapper:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(46, 125, 50, 0.4);
        }

        .file-input {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .file-icon {
            font-size: 1.1em;
            z-index: 1;
        }

        .file-input-text {
            font-size: 0.9em;
            font-weight: 600;
            z-index: 1;
        }

        .status-bar {
            color: rgba(255, 255, 255, 0.95);
            display: none;
            margin-top: 6px;
            width: 100%;
            border-top: 1px solid rgba(76, 175, 80, 0.2);
            padding-top: 8px;
        }

        /* ========== UTILITY CLASSES ========== */
        .white-card {
            background: white;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            padding: 16px;
        }
        
        .white-card-compact {
            background: white;
            border: 1px solid #E0E0E0;
            border-radius: 4px;
            padding: 0px;
        }
        
        /* ========== SMOOTH TRANSITIONS ========== */
        /* max-height transition for smooth collapse animations */
        /* opacity transition for fade effects */
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out;
            max-height: 1000px;
            opacity: 1;
        }
        
        .collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        /* CPE content uses dynamic height calculation instead of fixed max-height */
        .cpe-collapsible-content {
            overflow: hidden;
            transition: height 0.3s ease-in-out, opacity 0.3s ease-in-out;
            opacity: 1;
        }
        
        .cpe-collapsible-content.collapsed {
            height: 0 !important;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        .collapsible-toggle {
            transition: transform 0.2s ease-in-out;
        }
        
        .collapsible-toggle.rotated {
            transform: rotate(90deg);
        }
        
        .white-card-300 {
            background: white;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            padding: 16px;
            min-height: 150px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .green-border-left {
            border-left: 4px solid #4CAF50;
        }
        
        .green-border-left-light {
            border-left: 4px solid #66BB6A;
        }
        
        .green-border-left-dark {
            border-left: 4px solid #2E7D32;
        }
        
        .gradient-green {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
        }
        
        .gradient-green-dark {
            background: linear-gradient(135deg, #2E7D32, #4CAF50);
        }
        
        /* ========== SPECIFIC COMPONENTS ========== */

        .alias-div {
            padding: 8px 12px;
            background: white;
        }
        
        .alias-div-border {
            border-bottom: 1px solid #E0E0E0;
        }
        
        .aliases-section-container {
            border: 1px solid #4CAF50;
            border-top: none;
            border-radius: 0 0 6px 6px;
            margin-bottom: 15px;
            max-height: 600px; /* Set reasonable max height */
            overflow-y: auto; /* Add scrollbars when content exceeds height */
        }
        
        .aliases-section-header {
            color: white;
            padding: 12px 16px;
            font-size: 1.0em;
            margin: 15px 0 0 0;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        
        .aliases-section-header:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .chart-container-400 {
            margin-top: 20px;
            height: 280px;
        }

        .chart-placeholder {
            height: 280px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .status-filename {
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 6px;
            color: rgba(255, 255, 255, 0.95);
            text-align: left;
        }

        .status-details {
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.85);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Integrated Documentation Styles within File Selector */
        .doc-toggle {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
            flex: 0 0 48%;
            max-width: 48%;
            padding: 12px 16px;
            background: rgba(76, 175, 80, 0.06);
            border: 1px solid rgba(76, 175, 80, 0.2);
            border-radius: 6px;
            backdrop-filter: blur(2px);
            min-height: 120px;
            box-shadow: 0 1px 4px rgba(76, 175, 80, 0.1);
        }

        .doc-toggle:hover {
            background: rgba(76, 175, 80, 0.1);
            border-color: rgba(76, 175, 80, 0.25);
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.15);
        }

        .doc-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            transition: gap 0.3s ease;
            width: 100%;
        }

        .doc-header-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .doc-icon {
            font-size: 1.5em;
            color: #81C784;
            transition: font-size 0.3s ease;
        }

        .file-selector:not(.expanded) .doc-icon {
            font-size: 1.2em;
        }

        .doc-title {
            font-size: 1.4em;
            font-weight: 600;
            color: #F9FAFB;
            margin: 0;
            transition: font-size 0.3s ease;
        }

        .file-selector:not(.expanded) .doc-title {
            font-size: 1.2em;
        }

        .doc-subtitle {
            font-size: 0.9em;
            color: #E5E7EB;
            margin: 0;
            transition: font-size 0.3s ease;
        }

        .file-selector:not(.expanded) .doc-subtitle {
            font-size: 0.8em;
        }

        .doc-chevron {
            font-size: 1.2em;
            color: #81C784;
            transition: transform 0.3s ease;
        }

        .documentation-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease, opacity 0.3s ease;
            opacity: 0;
            margin-top: 15px;
            position: relative;
            z-index: 100;
            pointer-events: auto;
        }

        .documentation-content.expanded {
            max-height: 1000px;
            opacity: 1;
            pointer-events: auto;
        }

        .documentation-content * {
            pointer-events: auto;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        .documentation-content a {
            pointer-events: auto;
            cursor: pointer;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        /* Analysis Toggle Styles */
        .analysis-toggle {
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 8px;
            overflow: hidden;
        }

        .analysis-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.15);
        }

        .analysis-header-content {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .analysis-icon {
            font-size: 1.5em;
            display: flex;
            align-items: center;
        }

        .analysis-title {
            font-size: 1.3em;
            font-weight: bold;
        }

        .analysis-subtitle {
            font-size: 0.9em;
            opacity: 0.9;
            margin-left: 10px;
        }

        .analysis-chevron {
            font-size: 1.2em;
            color: #E8F5E8;
            transition: transform 0.3s ease;
        }

        .analysis-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease, opacity 0.3s ease;
            opacity: 0;
        }

        .analysis-content.expanded {
            max-height: 1000px;
            opacity: 1;
        }

        .concern-badge {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid #4CAF50;
            color: #2E7D32;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75em;
            margin-left: 8px;
            cursor: help;
        }

        .concern-tooltip {
            position: relative;
            display: inline-block;
        }

        .concern-tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: #555;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8em;
            line-height: 1.3;
        }

        .concern-tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #555 transparent transparent transparent;
        }

        .concern-tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .section-header {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
            padding: 20px 30px;
            font-size: 1.3em;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .doc-intro {
            background: rgba(232, 245, 233, 0.6);
            padding: 16px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 1px 4px rgba(76, 175, 80, 0.08);
        }

        .doc-intro p {
            margin: 0 0 12px 0;
            line-height: 1.5;
            color: #1E293B;
            font-size: 0.9em;
        }

        .doc-intro p:last-child {
            margin-bottom: 0;
        }

        .doc-sections {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px;
        }

        .doc-section {
            background: rgba(237, 247, 237, 0.5);
            padding: 16px 20px;
            border-radius: 8px;
            border: 1px solid rgba(76, 175, 80, 0.1);
            box-shadow: 0 1px 3px rgba(76, 175, 80, 0.05);
        }

        .doc-section-full-width {
            grid-column: 1 / -1;
        }

        .doc-section h4 {
            color: #1E293B;
            margin: 0 0 12px 0;
            font-size: 1em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .doc-section ul {
            margin: 0;
            padding: 0 0 0 18px;
            list-style-type: disc;
            color: #334155;
        }

        .doc-section li {
            margin: 6px 0;
            line-height: 1.4;
            color: #374151;
            font-size: 0.85em;
        }

        .doc-section li:last-child {
            margin-bottom: 0;
        }

        .doc-section li strong {
            color: #1E293B;
            font-weight: 600;
        }

        .doc-highlight {
            background: linear-gradient(90deg, rgba(76, 175, 80, 0.08) 0%, rgba(76, 175, 80, 0.04) 100%);
            padding: 12px 16px;
            border-radius: 6px;
            border-left: 2px solid #4CAF50;
            margin-top: 12px;
            font-size: 0.85em;
            color: #1E293B;
        }

        .filter-container {
            background: rgba(248, 250, 252, 0.8);
            padding: 12px 16px;
            border-radius: 4px;
            border: 1px solid #ddd;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .alias-selection-checkbox {
            margin-right: 8px;
            transform: scale(1.2);
        }

        .selection-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            border: 2px solid #4CAF50;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 400px;
            z-index: 1000;
            display: none;
        }

        .selection-panel h4 {
            margin: 0 0 12px 0;
            color: #1E293B;
            font-size: 1em;
        }

        .selection-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 12px;
            border: 1px solid #eee;
            border-radius: 4px;
        }

        .selection-item {
            padding: 6px 8px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 0.85em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .selection-item:last-child {
            border-bottom: none;
        }

        .consolidate-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            font-weight: 500;
        }

        .consolidate-btn:hover {
            background: #45a049;
        }

        .consolidate-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .output-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .output-modal-content {
            max-width: 80%;
            max-height: 80%;
            min-height: 400px;
            overflow-y: auto;
            position: relative;
            padding: 20px;
            border-radius: 8px;
        }

        .modal-header {
            cursor: move;
            user-select: none;
            margin: -20px -20px 16px -20px;
            padding: 16px 20px;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .output-modal h3 {
            margin: 0;
            color: #1E293B;
        }

        .output-modal pre {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            font-family: monospace;
            font-size: 0.85em;
        }

        .modal-actions {
            margin-top: 16px;
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        .modal-btn-primary {
            background: #4CAF50;
            color: white;
        }

        .modal-btn-secondary {
            background: #666;
            color: white;
        }

        @media (max-width: 768px) {
            .file-input-container {
                flex-direction: column;
                align-items: stretch;
                gap: 16px;
            }
            
            .file-input-container::after {
                display: none;
            }
            
            .file-input-main {
                flex: none;
                max-width: none;
            }
            
            .doc-toggle {
                flex: none;
                max-width: none;
            }
            
            .doc-sections {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .file-selector {
                padding: 16px 20px;
            }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            padding: 15px;
            background: #F8F9FA;
        }

        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
            border-left: 3px solid #4CAF50;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #2E7D32;
            margin-bottom: 3px;
        }

        .stat-label {
            font-size: 0.8em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 40px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .section-content {
            padding: 30px;
        }

        .alias-group {
            margin-bottom: 30px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            overflow: visible; /* Changed from hidden to allow scrollbars in content */
        }

        .alias-group-header {
            background: #F5F5F5;
            padding: 20px;
            border-bottom: 1px solid #E0E0E0;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .alias-group-header:hover {
            background: #EEEEEE;
        }

        .alias-group-header.expanded {
            background: #E8F5E8;
        }

        .product-info {
            font-weight: bold;
            color: #2E7D32;
        }

        .alias-count {
            background: #4CAF50;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .alias-details {
            display: none;
            padding: 20px;
            background: #FAFAFA;
        }

        .alias-details.expanded {
            display: block;
        }

        .alias-item {
            background: white;
            border: 1px solid #E0E0E0;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .platform-info {
            font-weight: bold;
            color: #2E7D32;
            margin-bottom: 8px;
        }

        .cve-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .cve-tag {
            background: #E8F5E8;
            color: #2E7D32;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-family: monospace;
        }

        .cve-link {
            background: #E8F5E8;
            color: #2E7D32;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-family: monospace;
            text-decoration: none;
            margin: 2px;
            display: inline-block;
            transition: all 0.2s ease;
        }

        .cve-link:hover {
            background: #2E7D32;
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(46, 125, 50, 0.3);
        }

        .cve-link:visited {
            color: #1B5E20;
        }

        .cve-link:visited:hover {
            color: white;
        }

        .chart-container {
            height: 280px;
            margin: 20px 0;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #666;
            font-style: italic;
        }

        .error {
            background: #FFEBEE;
            color: #C62828;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #F44336;
        }

        .top-products {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .top-product-card {
            background: white;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid #4CAF50;
        }

        .top-product-name {
            font-weight: bold;
            color: #2E7D32;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .top-product-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .expand-icon {
            transition: transform 0.3s ease;
        }

        .expand-icon.rotated {
            transform: rotate(180deg);
        }

        .no-data {
            text-align: center;
            padding: 50px;
            color: #666;
            font-style: italic;
        }

        /* === REUSABLE UTILITY CLASSES === */
        
        /* Layout Utilities */
        .flex-between { display: flex; justify-content: space-between; align-items: center; }
        .flex-start { display: flex; align-items: flex-start; gap: 8px; }
        .flex-center { display: flex; align-items: center; gap: 8px; }
        .flex-column { display: flex; flex-direction: column; }
        .flex-1 { flex: 1; }
        .flex-shrink-0 { flex-shrink: 0; }
        .gap-8 { gap: 8px; }
        .gap-10 { gap: 10px; }

        /* Spacing Utilities */
        .m-0 { margin: 0; }
        .mb-6 { margin-bottom: 6px; }
        .mb-10 { margin-bottom: 10px; }
        .mt-4 { margin-top: 4px; }
        .mt-2 { margin-top: 2px; }
        .p-20 { padding: 20px; }
        .pt-2 { padding-top: 2px; }
        .pb-8 { padding-bottom: 8px; }

        /* Display Utilities */
        .d-none { display: none; }
        .d-block { display: block; }
        .d-flex { display: flex; }

        /* Text Utilities */
        .text-sm { font-size: 0.85em; }
        .text-xs { font-size: 0.75em; }
        .text-lg { font-size: 0.95em; }
        .font-600 { font-weight: 600; }
        .font-500 { font-weight: 500; }
        .line-height-13 { line-height: 1.3; }
        .color-333 { color: #333; }
        .color-666 { color: #666; }

        /* Border Utilities */
        .border-bottom { border-bottom: 1px solid #E0E0E0; }
        .border-none { border: none; }

        /* Common Component Styles */
        .alias-header {
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #E0E0E0;
        }

        .alias-title {
            color: #333;
            font-size: 0.95em;
            font-weight: 600;
        }

        .alias-properties {
            font-size: 0.85em;
            line-height: 1.3;
        }

        .alias-container-info {
            font-size: 0.8em;
            color: #666;
            margin-top: 4px;
        }

        .cve-count {
            color: #666;
            font-size: 0.85em;
            font-weight: 600;
        }

        .expand-caret {
            font-size: 1.2em;
            color: #666;
            cursor: pointer;
        }

        /* Form Controls */
        .form-input {
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .btn-primary {
            padding: 6px 12px;
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
        }

        .btn-secondary {
            padding: 6px 12px;
            background: #666;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
        }

        /* Code Blocks */
        .code-block {
            background: #F5F5F5;
            padding: 8px 12px;
            border-radius: 4px;
            display: block;
            font-family: monospace;
            font-size: 0.9em;
            border: 1px solid #D0D0D0;
        }

        .code-block-alt {
            background: #F8F9FA;
            padding: 8px 12px;
            border-radius: 4px;
            display: block;
            font-family: monospace;
            font-size: 0.85em;
            border: 1px solid #E0E0E0;
            white-space: pre-wrap;
        }

        .code-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .code-preview {
            font-size: 0.75em;
            font-family: monospace;
            color: #666;
            margin-top: 1px;
            height: 14px;
            overflow: hidden;
            word-break: break-all;
            line-height: 1.1;
        }

        .code-output {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            font-family: monospace;
            font-size: 0.85em;
            max-height: 400px;
            overflow-y: auto;
        }

        /* Status Messages */
        .status-success { 
            color: #4CAF50; 
            line-height: 1.2;
        }
        .status-error { 
            color: #dc3545; 
            line-height: 1.2;
        }
        .status-list { 
            margin: 4px 0 0 16px; 
            padding: 0; 
        }

        /* CVE Year Groups */
        .cve-year-group {
            margin-bottom: 3px;
            border: 1px solid #E0E0E0;
            border-radius: 3px;
            overflow: hidden;
        }

        .cve-year-header {
            padding: 4px 8px;
            cursor: pointer;
            font-size: 0.8em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: opacity 0.2s ease;
        }

        .cve-year-toggle {
            transition: transform 0.3s ease;
            font-size: 0.7em;
        }

        .cve-year-content {
            display: none;
            padding: 4px 6px;
            background: #FAFAFA;
            font-size: 0.75em;
        }

        /* Concern Display */
        .concern-details {
            background: #F5F5F5;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #D0D0D0;
            margin-top: 4px;
            font-size: 0.9em;
            line-height: 1.4;
        }

        /* Stats Grid Items */
        .stats-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .stats-item-alt {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .stats-label {
            font-weight: 500;
            color: #2E7D32;
            font-size: 0.9em;
        }

        /* Section Headers */
        .section-header-flex {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .section-header-flex-start {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 10px;
        }

        /* Confirmed Badge */
        .confirmed-badge {
            background: #4CAF50;
            color: white;
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 0.7em;
        }

        /* Form Select */
        .form-select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 200px;
        }

        /* Layout containers */
        .container-flex-between {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        /* Common margin/padding patterns */
        .mb-16 { margin-bottom: 16px; }
        .ml-4 { margin-left: 4px; }
        .ml-8 { margin-left: 8px; }
        .mr-8 { margin-right: 8px; }

        /* CSS-based height utilities - Updated for better content visibility */
        .max-height-300 { max-height: 400px; overflow-y: auto; }
        .max-height-100 { max-height: 100%; }

        /* Text/link styles */
        .link-blue { color: #0066cc; text-decoration: none; }
        .text-center { text-align: center; }

        /* Layout Grid Components */
        .responsive-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .chart-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .data-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .properties-list {
            background: white;
            border: 1px solid #E0E0E0;
            border-radius: 6px;
            padding: 16px;
            min-height: 150px;
            max-height: 350px;
            overflow-y: auto;
        }

        .combinations-list {
            background: white;
            border: 1px solid #E0E0E0;
            border-radius: 6px;
            padding: 16px;
            min-height: 150px;
            max-height: 350px;
            overflow-y: auto;
        }

        .chart-placeholder {
            background: white;
            border: 1px solid #E0E0E0;
            border-radius: 6px;
            padding: 20px;
            text-align: center;
            color: #666;
            font-style: italic;
        }

        .chart-container-main {
            margin-top: 20px;
            height: 280px;
        }

        /* Section Styles */
        .section-header-gradient {
            color: white;
            padding: 12px 16px;
            font-size: 1.0em;
            margin: 15px 0 0 0;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
        }

        .section-container {
            border: 1px solid #4CAF50;
            border-top: none;
            border-radius: 0 0 6px 6px;
            margin-bottom: 15px;
            display: block;
        }

        .cpe-group-div {
            overflow: hidden;
            margin-bottom: 4px;
            border-radius: 4px;
        }

        .cpe-header {
            color: white;
            padding: 6px 12px;
            font-size: 0.85em;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        
        .cpe-header:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .alias-div-clean {
            padding: 15px 20px;
            background: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Source Mapping Dashboard</h1>
            <p>Analyze CVE Source Data Mapping Extraction Results</p>
        </div>

        <div class="file-selector">
            <!-- File Input Controls -->
            <div class="file-input-container">
                <div class="file-input-main">
                    <input type="file" id="fileInput" class="file-input" accept=".json">
                    <button type="button" id="file-select-btn" class="file-input-wrapper">
                        <div class="file-icon">🗺️</div>
                        <div class="file-input-text">Load Source Mapping File</div>
                    </button>
                    <div class="status-bar" id="status-bar" style="display: none;">
                        <div class="status-filename" id="status-filename">--</div>
                        <div class="status-details">
                            <div class="status-item">
                                <span>Generated: <span id="generation-time">--</span></span>
                            </div>
                            <div class="status-item">
                                <span id="file-size">-- KB</span> • <span>Loaded <span id="load-time">--</span></span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Documentation Toggle - Right Aligned -->
                <div class="doc-toggle" onclick="toggleDocumentation()">
                    <div class="doc-header">
                        <div class="doc-header-content">
                            <div class="doc-icon">ℹ️</div>
                            <div>
                                <h3 class="doc-title">What am I looking at?</h3>
                                <p class="doc-subtitle">Click to learn how to use this dashboard</p>
                            </div>
                        </div>
                        <div class="doc-chevron" id="doc-chevron">▼</div>
                    </div>
                </div>
            </div>
            
            <!-- Documentation Content - Expandable -->
            <div class="documentation-content" id="documentation-content">
                <div class="doc-intro">
                    <p><strong>Overview:</strong> This dashboard helps systematically convert unconfirmed alias data into validated CPE mappings for a specific source.</p>
                    <p>For technical issues, feature requests, or questions about the Source Mapping Dashboard, please visit the <a href="https://github.com/Hashmire/Analysis_Tools/issues" target="_blank" style="color: #0066cc; text-decoration: none;">Repository Issues page</a>. <br /> Community feedback and contributions to improve the dashboard's functionality and user experience are always encouraged!</p>
                </div>

                <div class="doc-sections">
                    <div class="doc-section">
                        <h4>🔍 Step 1: Review and Filter Unconfirmed Aliases</h4>
                        <ul>
                            <li>Use the search filter to find aliases for specific vendors, products, or platforms</li>
                            <li>Examine alias properties like vendor, product, and platform as they relate to this source scope</li>
                            <li>Click CVE links to review the current CPE Match String assignments within NVD Applicability Statements for additional plausible proper CPE Base Strings context</li>
                            <li>Focus on high-frequency aliases (more CVEs = higher impact when mapped)</li>
                            <li>Avoid creating aliases that involve inappropriate data such as version information</li>
                        </ul>
                    </div>

                    <div class="doc-section">
                        <h4>📋 Step 2: Select Related Aliases for Mapping</h4>
                        <ul>
                            <li>Check the boxes next to aliases that represent the same product/software within this source scope</li>
                            <li>Include platform variants (e.g., "Windows 10 x64" and "Windows 10 32-bit") if they map to the same CPE Base String</li>
                            <li>Group related aliases that should share the same CPE Base String</li>
                            <li>Minimum 1 alias required to generate a mapping</li>
                        </ul>
                    </div>

                    <div class="doc-section">
                        <h4>🎯 Step 3: Generate Consolidated Mapping</h4>
                        <ul>
                            <li>Click "Generate Consolidated Mapping" to open the mapping generator</li>
                            <li>Choose CPE Base String approach:</li>
                            <ul>
                                <li><strong>Existing CPE:</strong> Select from dropdown of confirmed mappings</li>
                                <li><strong>Manual CPE:</strong> Enter full cpe:2.3:a:vendor:product:*:*:*:*:*:*:*:* format</li>
                            </ul>
                            <li>Review the generated JSON with your selected aliases</li>
                        </ul>
                    </div>

                    <div class="doc-section">
                        <h4>💾 Step 4: Save and Continue</h4>
                        <ul>
                            <li>Copy the JSON output and add it to your confirmed mappings file</li>
                            <li>Update your confirmed mappings file with the new entries</li>
                            <li>Continue mapping remaining unconfirmed aliases in subsequent analysis runs</li>
                            <li>Re-run the curator to process the updated confirmed mappings when desired</li>
                        </ul>
                    </div>

                    <div class="doc-section doc-section-full-width">
                        <h4>📊 Understanding the Data</h4>
                        <ul>
                            <li><strong>Product Groups</strong> - Number of distinct CPE mapping entries (confirmed and unconfirmed) from the source mapping extraction</li>
                            <li><strong>Unique Aliases</strong> - Total count of individual alias entries across all mapping groups</li>
                            <li><strong>Confirmed Mapping Coverage</strong> - Percentage of aliases that already have validated CPE associations</li>
                            <li><strong>Alias Properties</strong> - Vendor, product, and platform attributes extracted from the source analysis</li>
                            <li><strong>Source CVE Context</strong> - The original CVE records where each alias was discovered</li>
                            <li><strong>CPE Base String</strong> - Standardized Common Platform Enumeration identifier for products</li>
                            <li><strong>Unconfirmed Aliases</strong> - Aliases without validated CPE mappings that need manual review and confirmation</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="content">
            <div id="loadingMessage" class="loading">
                Select a source mapping extraction file to begin analysis
            </div>

            <div id="errorMessage" class="error" style="display: none;"></div>

            <div id="mainContent" style="display: none;">
                <div class="section">
                    <div class="aliases-section-header gradient-green" onclick="toggleAnalysis()">
                        <div class="section-header-flex">
                            <div style="text-align: left; flex: 1;">
                                <span style="font-weight: 600;">Source Alias Statistics</span>
                                <div style="font-size: 0.8em; opacity: 0.9; margin-top: 1px;">Analysis and breakdown of confirmed mappings and unconfirmed aliases</div>
                            </div>
                            <span id="analysis-chevron" style="font-size: 1.1em; flex-shrink: 0;">▲</span>
                        </div>
                    </div>
                    <div class="analysis-content expanded" id="analysis-content">
                        <div class="section-content">
                            <div id="statsGrid" class="stats-grid">
                                <div class="stat-card">
                                    <div class="stat-value" id="totalProducts">-</div>
                                    <div class="stat-label">Product Groups</div>
                                </div>
                                <div class="stat-card">
                                    <div class="stat-value" id="totalAliases">-</div>
                                    <div class="stat-label">Unique Aliases</div>
                                </div>
                                <div class="stat-card">
                                    <div class="stat-value" id="confirmedMappingCoverage">-</div>
                                    <div class="stat-label">Confirmed Mapping Coverage</div>
                                </div>
                            </div>
                            <div class="chart-container">
                                <canvas id="topProductsChart"></canvas>
                            </div>
                            <div id="topProductsList" class="top-products"></div>
                        </div>
                    </div>
                </div>

                <div class="filter-container" id="aliasFilter" style="display: none;">
                    <label for="filterInput" class="font-500 color-333">Filter:</label>
                    <input type="text" id="filterInput" class="form-input flex-1 mr-8 ml-8" placeholder="Enter search term..." />
                    <button id="searchButton" class="btn-primary">Search</button>
                    <button id="clearFilter" class="btn-secondary ml-4">Clear</button>
                </div>

                <div id="aliasGroups"></div>

                <!-- Source Data Concerns Section -->
                <div id="sourceDataConcernGroups"></div>
            </div>
        </div>
    </div>

    <script>
        let currentData = null;
        let topProductsChart = null;
        let allSortedAliases = null;
        let allConcerningAliases = null;

        // ========== CACHED DOM ELEMENTS ==========
        let fileInput, searchButton, clearButton, errorMessage, loadingMessage, mainContent, statsGrid;

        // Source Data Concern patterns (synchronized with curator.py placeholder filtering)
        const NON_SPECIFIC_VALUES = [
            // Core placeholder patterns (exact match from curator)
            'n/a', 'n\\/a', 'n\\a', 'na', 'unknown', 'unspecified', 'not specified',
            'not applicable', 'none', 'null', 'undefined', '-', '--', '---',
            'tbd', 'to be determined', 'pending', 'missing', 'empty', 'blank',
            'default', 'generic', 'various', 'multiple', 'mixed', 'other',
            'all', 'any', '*', 'no information', 'no data', 'not available',
            'not disclosed', 'confidential', 'redacted', 'vendor', 'product',
            // Platform-specific placeholders
            'all platforms', 'multiple platforms', 'various platforms', 'unspecified platform',
            'all versions', 'multiple versions', 'various versions', 'all systems',
            // Additional dashboard-specific patterns for comprehensive coverage
            'unavailable', 'nil', 'not determined', 'not known', 'not listed', 'not provided'
        ];

        // Version text patterns that indicate problematic version information
        const VERSION_TEXT_PATTERNS = [
            // Range indicators
            'through', 'thru', 'to', 'between', 'and',
            
            // Upper bound indicators
            'before', 'prior to', 'earlier than', 'up to', 'until', 
            'not after', 'older than', 'below',
            
            // Lower bound indicators
            'after', 'since', 'later than', 'newer than', 
            'starting with', 'from', 'above',
            
            // Approximation indicators
            'about', 'approximately', 'circa', 'around', 'roughly',
            
            // Inclusive/exclusive indicators
            'inclusive', 'exclusive', 'including', 'excluding',
            
            // Non-specific versions
            'all versions', 'any version', 'multiple versions',
            
            // Reference directives
            'see references', 'see advisory', 'refer to', 'check', 'as noted',
            
            // Descriptive statements
            'supported', 'unstable', 'development', 'beta', 'release candidate', 'nightly'
        ];
        
        // Conjunction patterns that indicate multiple values in single field (requires context analysis)
        const CONJUNCTION_PATTERNS = [
            { pattern: ' and ', context: 'conjunction', description: 'conjunction indicating multiple values' },
            { pattern: ' or ', context: 'conjunction', description: 'conjunction indicating multiple values' },
            { pattern: ' to ', context: 'conjunction', description: 'potential range indicator' },
            { pattern: 'inclusive', context: 'conjunction', description: 'range boundary modifier' },
            { pattern: 'exclusive', context: 'conjunction', description: 'range boundary modifier' },
            { pattern: 'including', context: 'conjunction', description: 'range boundary modifier' },
            { pattern: 'excluding', context: 'conjunction', description: 'range boundary modifier' }
        ];

        // ========== GLOBAL CONSTANTS ==========
        const placeholderPatterns = ['n/a', 'null', 'none', 'unknown', 'tbd', 'pending', '*', 'n\\/a'];
        const cve5Properties = [
            'vendor', 'product', 'collectionURL', 'packageName', 'cpes', 
            'modules', 'programFiles', 'programRoutines', 'platforms', 'repo'
        ];

        // ========== UTILITY FUNCTIONS ==========
        function initializeCachedElements() {
            fileInput = document.getElementById('fileInput');
            searchButton = document.getElementById('searchButton');
            clearButton = document.getElementById('clearFilter');
            errorMessage = document.getElementById('errorMessage');
            loadingMessage = document.getElementById('loadingMessage');
            mainContent = document.getElementById('mainContent');
            statsGrid = document.getElementById('statsGrid');
        }

        function isPlaceholderValue(value) {
            if (!value || value === '' || value === null || value === undefined) {
                return true;
            }
            const stringValue = String(value).toLowerCase().trim();
            return placeholderPatterns.some(pattern => stringValue === pattern || stringValue.includes(pattern));
        }

        // Helper function to check if a value is a placeholder or should be omitted
        function isPlaceholderValue(value) {
            if (!value || value === '' || value === null || value === undefined) {
                return true;
            }
            
            if (typeof value === 'string') {
                const valueLower = value.toLowerCase().trim();
                const placeholders = ['unknown', 'n/a', 'na', 'null', 'none', 'tbd', 'pending', '*', 'unspecified', 'not specified', '-'];
                return placeholders.includes(valueLower);
            }
            
            return false;
        }

        // Helper function to get display value or empty string if placeholder
        function getDisplayValue(value, fallback = '') {
            return isPlaceholderValue(value) ? fallback : value;
        }

        function detectSourceDataConcerns(alias) {
            const concerns = [];
            
            // Check vendor field for placeholder data
            if (alias.vendor && typeof alias.vendor === 'string') {
                const vendorLower = alias.vendor.toLowerCase();
                const isPlaceholder = NON_SPECIFIC_VALUES.some(val => vendorLower === val.toLowerCase());
                const isSingleDash = alias.vendor.trim() === '-';
                
                if (isPlaceholder || isSingleDash) {
                    const issueType = isSingleDash ? "single dash placeholder" : "placeholder value";
                    concerns.push({
                        type: "placeholderData",
                        field: "vendor",
                        value: alias.vendor,
                        issue: `Vendor field contains ${issueType} preventing proper CPE matching`
                    });
                }
                
                // Check for version patterns in vendor field (should not be there)
                VERSION_TEXT_PATTERNS.forEach(pattern => {
                    if (vendorLower.includes(pattern.toLowerCase())) {
                        concerns.push({
                            type: "versionInField",
                            field: "vendor", 
                            value: alias.vendor,
                            pattern: pattern,
                            issue: `Vendor field contains version pattern '${pattern}' which should not be in vendor name`
                        });
                    }
                });
            }
            
            // Check product field for placeholder data
            if (alias.product && typeof alias.product === 'string') {
                const productLower = alias.product.toLowerCase();
                const isPlaceholder = NON_SPECIFIC_VALUES.some(val => productLower === val.toLowerCase());
                const isSingleDash = alias.product.trim() === '-';
                
                if (isPlaceholder || isSingleDash) {
                    const issueType = isSingleDash ? "single dash placeholder" : "placeholder value";
                    concerns.push({
                        type: "placeholderData",
                        field: "product",
                        value: alias.product,
                        issue: `Product field contains ${issueType} preventing proper CPE matching`
                    });
                }
                
                // Check for version patterns in product field (should not be there)
                VERSION_TEXT_PATTERNS.forEach(pattern => {
                    if (productLower.includes(pattern.toLowerCase())) {
                        concerns.push({
                            type: "versionInField",
                            field: "product",
                            value: alias.product,
                            pattern: pattern,
                            issue: `Product field contains version pattern '${pattern}' which may indicate multiple product variants`
                        });
                    }
                });
            }
            
            // Check platform field for placeholder data and version patterns
            if (alias.platforms && typeof alias.platforms === 'string') {
                const platformLower = alias.platforms.toLowerCase();
                const isPlaceholder = NON_SPECIFIC_VALUES.some(val => platformLower === val.toLowerCase());
                const isSingleDash = alias.platforms.trim() === '-';
                
                if (isPlaceholder || isSingleDash) {
                    const issueType = isSingleDash ? "single dash placeholder" : "placeholder value";
                    concerns.push({
                        type: "placeholderData",
                        field: "platforms",
                        value: alias.platforms,
                        issue: `Platform field contains ${issueType} preventing proper CPE matching`
                    });
                }
                
                // Check for version patterns in platform field (should not be there)
                VERSION_TEXT_PATTERNS.forEach(pattern => {
                    if (platformLower.includes(pattern.toLowerCase())) {
                        concerns.push({
                            type: "versionInField",
                            field: "platforms",
                            value: alias.platforms,
                            pattern: pattern,
                            issue: `Platform field contains version pattern '${pattern}' which should not be in platform name`
                        });
                    }
                });
            }
            
            // Check for commas indicating multiple product variants
            if (alias.vendor && typeof alias.vendor === 'string' && alias.vendor.includes(',')) {
                concerns.push({
                    type: "multipleVariants",
                    field: "vendor",
                    value: alias.vendor,
                    issue: "Vendor field contains commas indicating multiple vendor variants that should be separated"
                });
            }
            
            if (alias.product && typeof alias.product === 'string' && alias.product.includes(',')) {
                concerns.push({
                    type: "multipleVariants",
                    field: "product", 
                    value: alias.product,
                    issue: "Product field contains commas indicating multiple product variants that should be separated"
                });
            }
            
            if (alias.platforms && typeof alias.platforms === 'string' && alias.platforms.includes(',')) {
                concerns.push({
                    type: "multipleVariants",
                    field: "platforms",
                    value: alias.platforms,
                    issue: "Platform field contains commas indicating multiple platform variants that should be separated"
                });
            }
            
            return concerns;
        }
        let propertyDistributionChart = null;

        // CPE validation functions
        function validateCpeString(cpeString) {
            if (!cpeString) return { valid: false, message: 'Empty CPE string' };
            
            const errors = [];
            
            if (!cpeString.startsWith('cpe:2.3:')) {
                errors.push('Must start with cpe:2.3:');
            }
            
            const parts = cpeString.split(':');
            
            if (parts.length !== 13) {
                errors.push(`Expected 13 components, found ${parts.length}`);
            }
            
            // Only check further validation if we have the right number of parts
            if (parts.length >= 3) {
                // Validate part attribute (must be 'a', 'o', or 'h')
                const part = parts[2];
                if (!['a', 'o', 'h'].includes(part)) {
                    errors.push(`Invalid part attribute '${part}'. Must be 'a' (application), 'o' (operating system), or 'h' (hardware)`);
                }
            }
            
            if (parts.length >= 5) {
                const vendor = parts[3];
                const product = parts[4];
                
                if ((!vendor || vendor === '*') && (!product || product === '*')) {
                    errors.push('Must specify at least vendor or product');
                }
            }
            
            // Check for unescaped spaces and special characters in all components
            for (let i = 3; i < parts.length; i++) {
                const component = parts[i];
                
                // Map component index to attribute name
                const attributeNames = [
                    'Vendor Attribute',      // index 3
                    'Product Attribute',     // index 4
                    'Version Attribute',     // index 5
                    'Update Attribute',      // index 6
                    'Edition Attribute',     // index 7
                    'Language Attribute',    // index 8
                    'SW_Edition Attribute', // index 9
                    'Target_SW Attribute',   // index 10
                    'Target_HW Attribute',   // index 11
                    'Other Attribute'        // index 12
                ];
                
                const attributeName = attributeNames[i - 3] || `Attribute ${i - 2}`;
                
                // Check for unescaped spaces
                if (component.includes(' ')) {
                    errors.push(`${attributeName} contains spaces. Spaces must be converted to underscores in CPE 2.3 format`);
                }
                
                // Check for unescaped special characters
                const requiredEscapes = {
                    '!': '\\!', '"': '\\"', '#': '\\#', '$': '\\$', '&': '\\&', 
                    "'": "\\'", '(': '\\(', ')': '\\)', '+': '\\+', '/': '\\/',
                    ';': '\\;', '<': '\\<', '=': '\\=', '>': '\\>', '?': '\\?',
                    '@': '\\@', '[': '\\[', ']': '\\]', '^': '\\^', '`': '\\`',
                    '{': '\\{', '|': '\\|', '}': '\\}', '~': '\\~', ',': '\\,'
                };
                
                for (const [char, escaped] of Object.entries(requiredEscapes)) {
                    if (component.includes(char) && !component.includes(escaped)) {
                        errors.push(`${attributeName} contains unescaped '${char}'. Must be escaped as '${escaped}'`);
                    }
                }
            }
            
            if (errors.length > 0) {
                return { valid: false, errors: errors };
            }
            
            return { valid: true, message: 'Valid CPE 2.3 Base String' };
        }

        function handleCpeInput(input) {
            let value = input.value;
            const validationDiv = document.getElementById('cpeValidationMessage');
            const previewDiv = document.getElementById('cpePreview');
            
            // Handle empty input
            if (!value) {
                validationDiv.innerHTML = '';
                previewDiv.innerHTML = 'Enter: a:vendor:product';
                input.style.borderColor = '#ccc';
                input.removeAttribute('data-final-cpe');
                updateConsolidatedOutput();
                return;
            }
            
            // Force "cpe:2.3:" prefix only when user is typing new content
            if (!value.startsWith('cpe:2.3:')) {
                // If user typed something that doesn't start with cpe: at all, prepend the full prefix
                if (!value.startsWith('cpe:')) {
                    value = 'cpe:2.3:' + value;
                    input.value = value;
                    // Set cursor position after the forced prefix
                    setTimeout(() => {
                        input.setSelectionRange(value.length, value.length);
                    }, 0);
                } 
                // If user typed cpe: but not the full cpe:2.3:, and it's not a partial deletion
                else if (value.startsWith('cpe:') && !value.startsWith('cpe:2.3:') && value.length > 4) {
                    value = 'cpe:2.3:' + value.substring(4);
                    input.value = value;
                    setTimeout(() => {
                        input.setSelectionRange(value.length, value.length);
                    }, 0);
                }
                // If user is backspacing through "cpe:" or partial "cpe:2.3:", don't force anything
                else if (value === 'cpe:' || value === 'cpe:2' || value === 'cpe:2.' || value === 'cpe:2.3') {
                    validationDiv.innerHTML = '';
                    previewDiv.innerHTML = 'Continue typing: cpe:2.3:a:vendor:product';
                    input.style.borderColor = '#ccc';
                    input.removeAttribute('data-final-cpe');
                    updateConsolidatedOutput();
                    return;
                }
            }
            
            // Show consistent example for exactly "cpe:2.3:"
            if (value === 'cpe:2.3:') {
                validationDiv.innerHTML = '';
                previewDiv.innerHTML = 'Continue with: a:vendor:product';
                input.style.borderColor = '#ccc';
                input.removeAttribute('data-final-cpe');
                updateConsolidatedOutput();
                return;
            }
            
            // Validate the CPE string
            const validation = validateCpeString(value);
            
            if (validation.valid) {
                validationDiv.innerHTML = `<span class="status-success">✅ Valid CPE 2.3 Base String</span>`;
                previewDiv.innerHTML = '';
                input.style.borderColor = '#4CAF50';
                input.setAttribute('data-final-cpe', value);
            } else {
                // Display validation errors in fixed height container with consistent formatting
                if (validation.errors && validation.errors.length > 0) {
                    // Show only first error to maintain consistent height
                    const firstError = validation.errors[0];
                    const moreCount = validation.errors.length > 1 ? ` (+${validation.errors.length - 1} more)` : '';
                    validationDiv.innerHTML = `<span class="status-error">❌ ${firstError}${moreCount}</span>`;
                } else {
                    validationDiv.innerHTML = `<span class="status-error">❌ ${validation.message}</span>`;
                }
                previewDiv.innerHTML = 'Example: a:vendor:product';
                input.style.borderColor = '#dc3545';
                input.removeAttribute('data-final-cpe');
            }
            
            updateConsolidatedOutput();
        }

        function handleCpeKeydown(event) {
            if (event.key === 'Enter') {
                const input = event.target;
                let value = input.value;
                
                // Auto-complete with :*:*:*:*:*:*:*:* if not already complete
                if (value.startsWith('cpe:2.3:') && value.split(':').length < 13) {
                    const parts = value.split(':');
                    while (parts.length < 13) {
                        parts.push('*');
                    }
                    value = parts.join(':');
                    input.value = value;
                    handleCpeInput(input);
                }
                
                event.preventDefault();
            }
        }

        // Initialize filter functionality
        function initializeFilter() {
            const filterInput = document.getElementById('filterInput');
            const filterContainer = document.getElementById('aliasFilter');

            if (allSortedAliases && allSortedAliases.length > 0) {
                filterContainer.style.display = 'flex';
            }

            // Search on Enter
            filterInput.onkeypress = function(e) {
                if (e.key === 'Enter') {
                    performSearch(this.value.toLowerCase());
                }
            };

            // Search on click
            searchButton.onclick = function() {
                performSearch(filterInput.value.toLowerCase());
            };

            // Clear on click
            clearButton.onclick = function() {
                filterInput.value = '';
                performSearch('');
            };
        }

        function performSearch(filterText) {
            // Show loading
            const originalSearchText = searchButton.textContent;
            const originalClearText = clearButton.textContent;
            searchButton.textContent = '⏳ Searching...';
            clearButton.textContent = '⏳ Clearing...';
            searchButton.disabled = true;
            clearButton.disabled = true;

            // Use setTimeout to allow UI update
            setTimeout(() => {
                filterAliases(filterText);
                
                // Restore buttons
                searchButton.textContent = originalSearchText;
                clearButton.textContent = originalClearText;
                searchButton.disabled = false;
                clearButton.disabled = false;
            }, 10);
        }

        function filterAliases(filterText) {
            if (!allSortedAliases) return;

            let cleanResults = allSortedAliases;
            let concerningResults = allConcerningAliases || [];
            
            if (filterText.trim()) {
                const searchTerm = filterText.trim().toLowerCase();
                cleanResults = allSortedAliases.filter(alias => 
                    alias._searchText.includes(searchTerm)
                );
                concerningResults = (allConcerningAliases || []).filter(alias => 
                    alias._searchText.includes(searchTerm)
                );
            }

            // Use faster DOM updates instead of full rebuild
            updateAliasDisplay(cleanResults, concerningResults);
        }

        function updateAliasDisplay(cleanResults, concerningResults) {
            // Fast update: only rebuild if results are significantly different
            const container = document.getElementById('aliasGroups');
            const concernContainer = document.getElementById('sourceDataConcernGroups');
            
            // Clear and rebuild (this is still the bottleneck, but optimized)
            container.innerHTML = '';
            if (concernContainer) concernContainer.innerHTML = '';
            
            if (cleanResults.length > 0) {
                displayAliasesByFrequency(cleanResults);
            }
            
            if (concerningResults.length > 0) {
                displaySourceDataConcerns(concerningResults);
            }
        }

        // CPE formatting functions (from processData.py)
        function normalizeToASCII(text) {
            if (!text) return '';
            
            // Convert to string if not already
            if (typeof text !== 'string') {
                text = String(text);
            }
            
            // Basic Unicode normalization
            text = text.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            
            // Handle specific Unicode characters
            const replacements = {
                'ø': 'o', 'Ø': 'O',
                'æ': 'ae', 'Æ': 'AE',
                'ß': 'ss',
                'ł': 'l', 'Ł': 'L',
                '©': 'c',
                '®': 'r',
                '™': 'tm',
                '€': 'euro',
                '£': 'pound',
                '¥': 'yen'
            };
            
            for (const [unicode, ascii] of Object.entries(replacements)) {
                text = text.replace(new RegExp(unicode, 'g'), ascii);
            }
            
            // Remove remaining non-ASCII characters
            text = text.replace(/[^\x00-\x7F]/g, '');
            
            return text;
        }

        function formatFor23CPE(rawAttribute) {
            if (!rawAttribute) return '';
            
            // Normalize to ASCII first
            let attribute = normalizeToASCII(rawAttribute);
            
            // CPE escaping rules
            const cpeEscape = {
                " ": "_",
                "\\": "\\\\",
                "!": "\\!",
                "\"": "\\\"",
                "#": "\\#",
                "$": "\\$",
                "&": "\\&",
                "'": "\\'",
                "(": "\\(",
                ")": "\\)",
                "+": "\\+",
                "/": "\\/",
                ":": "\\:",
                ";": "\\;",
                "<": "\\<",
                "=": "\\=",
                ">": "\\>",
                "?": "\\?",
                "@": "\\@",
                "[": "\\[",
                "]": "\\]",
                "^": "\\^",
                "`": "\\`",
                "{": "\\{",
                "|": "\\|",
                "}": "\\}",
                "~": "\\~",
                ",": "\\,"
            };
            
            attribute = attribute.toLowerCase();
            
            let result = '';
            for (const char of attribute) {
                result += cpeEscape[char] || char;
            }
            
            return result;
        }

        function generateSuggestedCPE(alias) {
            const vendor = isPlaceholderValue(alias.vendor) ? '*' : formatFor23CPE(alias.vendor);
            const product = isPlaceholderValue(alias.product) ? '*' : formatFor23CPE(alias.product);
            
            // Handle platform mapping for target_hw
            let targetHw = '*';
            if (alias.platforms && !isPlaceholderValue(alias.platforms)) {
                const platform = alias.platforms.toLowerCase();
                if (platform.includes('x64') || platform.includes('64-bit')) {
                    targetHw = 'x64';
                } else if (platform.includes('32-bit') || platform.includes('x86')) {
                    targetHw = 'x86';
                } else if (platform.includes('arm')) {
                    targetHw = 'arm';
                } else {
                    // Keep platform as-is for complex platform strings
                    targetHw = formatFor23CPE(alias.platforms);
                }
            }
            
            return `cpe:2.3:a:${vendor}:${product}:*:*:*:*:*:*:${targetHw}:*`;
        }

        function generateAliasMapping(alias) {
            // Create a clean mapping object excluding calculated fields
            const mapping = {};
            
            // Core required fields
            if (alias.vendor && !isPlaceholderValue(alias.vendor)) mapping.vendor = alias.vendor;
            if (alias.product && !isPlaceholderValue(alias.product)) mapping.product = alias.product;
            
            // Optional fields - only include if they have meaningful values
            const optionalFields = ['platforms', 'packageName', 'repo', 'collectionURL', 
                                  'container_type', 'programRoutines', 'programFiles', 'modules', 'defaultStatus'];
            
            optionalFields.forEach(field => {
                if (alias[field] && !isPlaceholderValue(alias[field])) {
                    mapping[field] = alias[field];
                }
            });
            
            return mapping;
        }

        function downloadConfirmedMappingsJSON(cpeGroups) {
            try {
                // Generate the confirmed mappings JSON structure
                const confirmedMappings = [];
                
                Object.entries(cpeGroups).forEach(([cpeBaseString, aliases]) => {
                    // Create aliases array with only the essential fields
                    const cleanAliases = aliases.map(alias => {
                        const cleanAlias = {};
                        
                        // Add vendor and product (required fields)
                        if (alias.vendor) cleanAlias.vendor = alias.vendor;
                        if (alias.product) cleanAlias.product = alias.product;
                        
                        // Add optional fields if they exist and aren't placeholder values
                        const optionalFields = ['version', 'update', 'edition', 'language'];
                        optionalFields.forEach(field => {
                            if (alias[field] && !isPlaceholderValue(alias[field])) {
                                cleanAlias[field] = alias[field];
                            }
                        });
                        
                        // Handle platform field - normalize to "platform" regardless of source field name
                        const platformValue = alias.platform || alias.platforms;
                        if (platformValue && !isPlaceholderValue(platformValue)) {
                            cleanAlias.platform = platformValue;
                        }
                        
                        return cleanAlias;
                    });
                    
                    // Create the confirmed mapping entry
                    const confirmedMapping = {
                        cpeBaseString: cpeBaseString,
                        aliases: cleanAliases
                    };
                    
                    confirmedMappings.push(confirmedMapping);
                });
                
                // Extract the target_uuid from the loaded data - this is required
                if (!window.currentData || !window.currentData.metadata || !window.currentData.metadata.target_uuid) {
                    throw new Error('Cannot download: No target_uuid found in loaded data metadata');
                }
                const actualCnaId = window.currentData.metadata.target_uuid;
                
                // Create the full JSON structure
                const jsonData = {
                    cnaId: actualCnaId,
                    confirmedMappings: confirmedMappings
                };
                
                // Create and download the file
                const jsonString = JSON.stringify(jsonData, null, 4);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `confirmed_mappings_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show success message
                const downloadBtn = event.target.closest('.download-btn');
                if (downloadBtn) {
                    const originalHTML = downloadBtn.innerHTML;
                    downloadBtn.innerHTML = '<i class="fas fa-check" style="font-size: 0.8em;"></i><span>Downloaded!</span>';
                    downloadBtn.style.background = 'rgba(76, 175, 80, 0.3)';
                    
                    setTimeout(() => {
                        downloadBtn.innerHTML = originalHTML;
                        downloadBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                    }, 2000);
                }
            } catch (error) {
                // Show error message to user
                const downloadBtn = event.target.closest('.download-btn');
                if (downloadBtn) {
                    const originalHTML = downloadBtn.innerHTML;
                    downloadBtn.innerHTML = '<i class="fas fa-exclamation-triangle" style="font-size: 0.8em;"></i><span>Error!</span>';
                    downloadBtn.style.background = 'rgba(244, 67, 54, 0.3)';
                    
                    setTimeout(() => {
                        downloadBtn.innerHTML = originalHTML;
                        downloadBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                    }, 3000);
                }
                
                // Log the error for debugging
                console.error('Download failed:', error.message);
                alert('Download failed: ' + error.message);
            }
        }

        function groupCvesByYear(cveList) {
            const groups = {};
            
            // Handle null/undefined or non-array inputs
            if (!cveList || !Array.isArray(cveList) || cveList.length === 0) {
                return [];
            }
            
            cveList.forEach(cve => {
                // Extract year from CVE-YYYY-NNNNN format
                const yearMatch = cve.match(/CVE-(\d{4})-/);
                const year = yearMatch ? yearMatch[1] : 'Unknown';
                
                if (!groups[year]) {
                    groups[year] = [];
                }
                groups[year].push(cve);
            });
            
            // Sort years in descending order (most recent first)
            const sortedYears = Object.keys(groups).sort((a, b) => {
                if (a === 'Unknown') return 1;
                if (b === 'Unknown') return -1;
                return parseInt(b) - parseInt(a);
            });
            
            return sortedYears.map(year => ({
                year: year,
                cves: groups[year].sort(), // Sort CVEs within each year
                count: groups[year].length
            }));
        }

        function generateCveGroupsHtml(cveGroups) {
            // Handle empty or invalid input
            if (!cveGroups || !Array.isArray(cveGroups) || cveGroups.length === 0) {
                return '<div class="no-cves">No CVE data available</div>';
            }
            
            return cveGroups.map(group => {
                // Subtle color coding using dashboard's existing palette
                const yearColor = group.year === 'Unknown' ? '#BDBDBD' : 
                                 parseInt(group.year) >= 2024 ? '#4CAF50' :  // Main green for recent
                                 parseInt(group.year) >= 2020 ? '#66BB6A' :  // Light green for 2020-2023
                                 '#E0E0E0';  // Light gray for older
                
                const yearLabel = group.year === 'Unknown' ? 'Unknown Year' : group.year;
                const textColor = yearColor === '#E0E0E0' ? '#666' : 'white';
                
                return `
                    <div class="cve-year-group">
                        <div class="cve-year-header" style="background: ${yearColor}; color: ${textColor};" 
                             onclick="toggleCveYear(this)"
                             onmouseover="this.style.opacity='0.8'"
                             onmouseout="this.style.opacity='1'">
                            <span>${yearLabel} • ${group.count} CVE${group.count > 1 ? 's' : ''}</span>
                            <span class="cve-year-toggle">▼</span>
                        </div>
                        <div class="cve-year-content">
                            <div class="cve-list">
                                ${group.cves.map(cve => `<a href="https://nvd.nist.gov/vuln/detail/${cve}#vulnConfigurationsArea" target="_blank" class="cve-link" title="View ${cve} on NVD">${cve}</a>`).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Documentation toggle functionality
        function toggleDocumentation() {
            const fileSelector = document.querySelector('.file-selector');
            const content = document.getElementById('documentation-content');
            const chevron = document.getElementById('doc-chevron');
            
            const isExpanded = content.classList.contains('expanded');
            
            if (isExpanded) {
                content.classList.remove('expanded');
                fileSelector.classList.remove('expanded');
                chevron.textContent = '▼';
                chevron.style.transform = 'rotate(0deg)';
            } else {
                content.classList.add('expanded');
                fileSelector.classList.add('expanded');
                chevron.textContent = '▲';
                chevron.style.transform = 'rotate(180deg)';
            }
        }

        // Analysis toggle functionality
        function toggleAnalysis() {
            const content = document.getElementById('analysis-content');
            const chevron = document.getElementById('analysis-chevron');
            
            const isExpanded = content.classList.contains('expanded');
            
            if (isExpanded) {
                content.classList.remove('expanded');
                chevron.textContent = '▼';
                chevron.style.transform = 'rotate(0deg)';
            } else {
                content.classList.add('expanded');
                chevron.textContent = '▲';
                chevron.style.transform = 'rotate(180deg)';
            }
        }

        // File input handling
        document.addEventListener('DOMContentLoaded', function() {
            initializeCachedElements();
            
            const fileSelectBtn = document.getElementById('file-select-btn');
            const statusBar = document.getElementById('status-bar');
            const statusFilename = document.getElementById('status-filename');
            const fileSize = document.getElementById('file-size');
            const generationTime = document.getElementById('generation-time');
            const loadTime = document.getElementById('load-time');

            // Handle file select button click
            fileSelectBtn.addEventListener('click', function() {
                fileInput.click();
            });

            // Handle file selection
            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    // Show status bar
                    statusBar.style.display = 'block';
                    statusFilename.textContent = file.name;
                    fileSize.textContent = (file.size / 1024).toFixed(1) + ' KB';
                    
                    // Extract generation time from filename if possible
                    const timeMatch = file.name.match(/(\d{8}_\d{6})/);
                    if (timeMatch) {
                        const timeStr = timeMatch[1];
                        const year = timeStr.substring(0, 4);
                        const month = timeStr.substring(4, 6);
                        const day = timeStr.substring(6, 8);
                        const hour = timeStr.substring(9, 11);
                        const minute = timeStr.substring(11, 13);
                        const second = timeStr.substring(13, 15);
                        generationTime.textContent = `${year}-${month}-${day} ${hour}:${minute}:${second}`;
                    } else {
                        generationTime.textContent = 'Unknown';
                    }
                    
                    // Load the file
                    loadFile();
                }
            });
        });

        function loadFile() {
            const file = fileInput.files[0];
            
            if (!file) {
                showError('Please select a file first');
                return;
            }

            const startTime = Date.now();
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    if (!jsonData.aliasGroups) {
                        throw new Error('Invalid file format: missing aliasGroups');
                    }
                    
                    currentData = jsonData;
                    window.currentData = jsonData;  // Make available globally for download function
                    hideError();
                    displayData(jsonData);
                    
                    // Update load time
                    const loadTimeMs = Date.now() - startTime;
                    const loadTimeEl = document.getElementById('load-time');
                    if (loadTimeEl) {
                        loadTimeEl.textContent = loadTimeMs + 'ms ago';
                    }
                } catch (error) {
                    showError('Error loading file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        function hideError() {
            errorMessage.style.display = 'none';
        }

        function displayData(data) {
            loadingMessage.style.display = 'none';
            mainContent.style.display = 'block';

            // Calculate statistics
            const totalProducts = data.aliasGroups.length;
            const totalAliases = data.aliasGroups.reduce((sum, mapping) => sum + mapping.aliases.length, 0);
            const metadata = data.metadata || {};
            
            // Calculate confirmed mapping coverage from confirmedMappings array
            let confirmedAliasCount = 0;
            if (data.confirmedMappings) {
                data.confirmedMappings.forEach(mapping => {
                    mapping.aliases.forEach(alias => {
                        // Count aliases that have source CVE data (indicating they have confirmed mappings)
                        if (alias.source_cve && alias.source_cve.length > 0) {
                            confirmedAliasCount++;
                        }
                    });
                });
            }
            
            const confirmedMappingCoverage = totalAliases > 0 ? 
                ((confirmedAliasCount / totalAliases) * 100).toFixed(1) + '%' : '0%';

            // Update stats
            document.getElementById('totalProducts').textContent = totalProducts;
            document.getElementById('totalAliases').textContent = totalAliases;
            document.getElementById('confirmedMappingCoverage').textContent = confirmedMappingCoverage;

            // Flatten all aliases and sort by CVE count for simple, effective organization
            const allAliases = [];
            const concerningAliases = [];
            const cleanAliases = [];
            
            data.aliasGroups.forEach(mapping => {
                mapping.aliases.forEach(alias => {
                    // Mark as unconfirmed by default (these are from aliasGroups)
                    const isConfirmedMapping = false;
                    
                    // Create optimized search text index for fast filtering
                    const searchFields = [
                        alias.alias || '',
                        alias.product || '',
                        alias.vendor || '',
                        alias.version || '',
                        alias.update || '',
                        alias.edition || '',
                        alias.language || ''
                    ];
                    const searchText = searchFields.join(' ').toLowerCase();
                    
                    const processedAlias = {
                        ...alias,
                        cveCount: alias.source_cve.length,
                        uniqueCveCount: new Set(alias.source_cve).size,
                        aliasGroup: alias.alias_group || mapping.alias_group || 'Unknown',
                        isConfirmedMapping: isConfirmedMapping,
                        _searchText: searchText
                    };
                    
                    // Detect source data concerns
                    const concerns = detectSourceDataConcerns(alias);
                    processedAlias.concerns = concerns;
                    
                    allAliases.push(processedAlias);
                    
                    // Separate concerning from clean aliases
                    if (concerns.length > 0) {
                        concerningAliases.push(processedAlias);
                    } else {
                        cleanAliases.push(processedAlias);
                    }
                });
            });

            // Add confirmed mappings from the confirmedMappings array
            if (data.confirmedMappings) {
                data.confirmedMappings.forEach(confirmedMapping => {
                    // Process confirmedMapping.cve field for CVE context
                    const mappingCve = confirmedMapping.cve || '';
                    
                    // Process confirmedMapping.platform field for platform data
                    const mappingPlatform = confirmedMapping.platform || '';
                    
                    // Process confirmedMapping.aliases array for alias data
                    const mappingAliases = confirmedMapping.aliases || [];
                    
                    confirmedMapping.aliases.forEach(alias => {
                        // All entries from confirmedMappings array are confirmed mappings (whether they have CVE data or not)
                        const isConfirmedMapping = true;
                        const hasCveData = alias.source_cve && alias.source_cve.length > 0;
                        
                        // Create optimized search text index for fast filtering
                        const searchFields = [
                            alias.alias || '',
                            alias.product || '',
                            alias.vendor || '',
                            alias.version || '',
                            alias.update || '',
                            alias.edition || '',
                            alias.language || '',
                            alias.platform || '',
                            alias.platforms || ''
                        ];
                        const searchText = searchFields.join(' ').toLowerCase();
                        
                        const processedAlias = {
                            ...alias,
                            cveCount: alias.source_cve ? alias.source_cve.length : 0,
                            uniqueCveCount: alias.source_cve ? new Set(alias.source_cve).size : 0,
                            aliasGroup: hasCveData ? 'Confirmed_Mapping_WithData' : 'Confirmed_Mapping_NoData',
                            isConfirmedMapping: isConfirmedMapping,
                            hasCveData: hasCveData,
                            cpeBaseString: confirmedMapping.cpebasestring,
                            frequency: alias.frequency || 0,
                            _searchText: searchText
                        };
                        
                        // Detect source data concerns
                        const concerns = detectSourceDataConcerns(alias);
                        processedAlias.concerns = concerns;
                        
                        allAliases.push(processedAlias);
                        
                        // Separate concerning from clean aliases
                        if (concerns.length > 0) {
                            concerningAliases.push(processedAlias);
                        } else {
                            cleanAliases.push(processedAlias);
                        }
                    });
                });
            }

            // Simple sorting by CVE count (highest first), then by product name for grouping
            const sortAliases = (aliases) => aliases.sort((a, b) => {
                // Primary sort: CVE count (highest first)
                if (b.cveCount !== a.cveCount) {
                    return b.cveCount - a.cveCount;
                }
                
                // Secondary sort: Product name (alphabetical)
                const productA = (a.product || '').toLowerCase();
                const productB = (b.product || '').toLowerCase();
                
                return productA.localeCompare(productB);
            });

            const sortedAliases = sortAliases(allAliases);
            const sortedCleanAliases = sortAliases(cleanAliases);
            const sortedConcerningAliases = sortAliases(concerningAliases);

            // Display top aliases chart (use clean aliases for the main chart)
            displayTopAliasesChart(sortedCleanAliases.slice(0, 10));

            // Display alias properties detected
            displayAliasPropertiesDetected(allAliases);
            
            // Display property distribution chart
            displayPropertyDistributionChart(allAliases);

            // Display clean aliases grouped by frequency
            allSortedAliases = sortedCleanAliases; // Store for filtering
            allConcerningAliases = sortedConcerningAliases; // Store concerning aliases for filtering
            displayAliasesByFrequency(sortedCleanAliases);
            
            // Display source data concerns section if there are concerning aliases
            if (sortedConcerningAliases.length > 0) {
                displaySourceDataConcerns(sortedConcerningAliases);
            }
            
            // Initialize filter after displaying aliases
            initializeFilter();
        }

        function displayTopAliasesChart(topAliases) {
            const ctx = document.getElementById('topProductsChart').getContext('2d');
            
            if (topProductsChart) {
                topProductsChart.destroy();
            }

            const labels = topAliases.map(alias => 
                [getDisplayValue(alias.vendor), getDisplayValue(alias.product, 'Product')].filter(v => v).join(' ') || 'Placeholder Content'
            );
            const data = topAliases.map(alias => alias.cveCount);
            
            topProductsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'CVE Count',
                        data: data,
                        backgroundColor: 'rgba(76, 175, 80, 0.8)',
                        borderColor: 'rgba(46, 125, 50, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of CVEs'
                            }
                        },
                        x: {
                            display: false  // Hide X axis labels
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Top 10 Aliases by CVE Count'
                        }
                    }
                }
            });
        }

        function analyzePropertyDistribution(aliases) {
            // CVE 5.X schema properties for affected products (excluding versions and defaultStatus)
            const distribution = {};

            aliases.forEach(alias => {
                // Identify which properties have meaningful values
                const presentProperties = [];
                cve5Properties.forEach(prop => {
                    if (alias[prop] && 
                        alias[prop] !== '' && 
                        alias[prop] !== null && 
                        alias[prop] !== 'N/A' && 
                        alias[prop] !== 'n/a' && 
                        alias[prop] !== undefined) {
                        
                        // For arrays, check if they have content
                        if (Array.isArray(alias[prop])) {
                            if (alias[prop].length > 0) presentProperties.push(prop);
                        } else {
                            presentProperties.push(prop);
                        }
                    }
                });

                // Create a combination key based on the properties present
                const combinationKey = presentProperties.length > 0 ? 
                    presentProperties.sort().join(' + ') : 
                    'no properties';
                
                distribution[combinationKey] = (distribution[combinationKey] || 0) + 1;
            });

            // Sort by frequency (most common combinations first)
            const sortedEntries = Object.entries(distribution)
                .sort(([,a], [,b]) => b - a);

            return {
                labels: sortedEntries.map(([label]) => label),
                values: sortedEntries.map(([, value]) => value)
            };
        }

        function displayPropertyDistributionChart(allAliases) {
            // Use the placeholder created in the properties analysis
            let chartContainer = document.getElementById('propertyDistributionChartPlaceholder');
            if (!chartContainer) {
                // Fallback: Create a container if placeholder doesn't exist
                chartContainer = document.createElement('div');
                chartContainer.id = 'propertyDistributionChartContainer';
                chartContainer.className = 'chart-container-400';
                chartContainer.innerHTML = '<canvas id="propertyDistributionChart"></canvas>';
                
                // Insert after the top products chart
                const topProductsContainer = document.getElementById('topProductsChart').parentElement;
                topProductsContainer.parentElement.insertBefore(chartContainer, topProductsContainer.nextSibling);
            } else {
                // Update the placeholder with the actual chart
                chartContainer.innerHTML = '<canvas id="propertyDistributionChart" style="max-height: 100%;"></canvas>';
            }

            const ctx = document.getElementById('propertyDistributionChart').getContext('2d');
            
            if (propertyDistributionChart && typeof propertyDistributionChart.destroy === 'function') {
                propertyDistributionChart.destroy();
            }

            const { labels, values } = analyzePropertyDistribution(allAliases);
            
            propertyDistributionChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: [
                            '#4CAF50', '#66BB6A', '#81C784', '#A5D6A7', 
                            '#C8E6C9', '#E8F5E8', '#F1F8E9', '#F9FBE7'
                        ],
                        borderColor: '#2E7D32',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Property Combination Distribution'
                        },
                        legend: {
                            position: 'right'
                        }
                    }
                }
            });
        }

        function displayAliasPropertiesDetected(allAliases) {
            const container = document.getElementById('topProductsList');
            container.innerHTML = '';

            // CVE 5.X schema properties for affected products (excluding versions and defaultStatus)
            // Track both individual properties and property combinations
            const propertyStats = {};
            const combinationStats = {};

            // Comprehensive placeholder patterns (from sourceDataConcern system)
            allAliases.forEach((alias, index) => {
                const presentProperties = [];
                
                cve5Properties.forEach(prop => {
                    if (!propertyStats[prop]) {
                        propertyStats[prop] = 0;
                    }
                    
                    // Only count if property has a meaningful value (not placeholder data)
                    if (alias[prop] && !isPlaceholderValue(alias[prop])) {
                        // For arrays, check if they have content and non-placeholder values
                        if (Array.isArray(alias[prop])) {
                            const meaningfulValues = alias[prop].filter(item => !isPlaceholderValue(item));
                            if (meaningfulValues.length > 0) {
                                propertyStats[prop]++;
                                presentProperties.push(prop);
                            }
                        } else {
                            propertyStats[prop]++;
                            presentProperties.push(prop);
                        }
                    }
                });

                // Track combinations
                if (presentProperties.length > 0) {
                    const combinationKey = presentProperties.sort().join(' + ');
                    combinationStats[combinationKey] = (combinationStats[combinationKey] || 0) + 1;
                }
            });

            // Sort properties by frequency
            const sortedProperties = Object.entries(propertyStats)
                .sort(([,a], [,b]) => b - a)
                .filter(([,count]) => count > 0);

            // Sort combinations by frequency
            const sortedCombinations = Object.entries(combinationStats)
                .sort(([,a], [,b]) => b - a);

            // Create responsive layout container
            const responsiveContainer = document.createElement('div');
            responsiveContainer.className = 'responsive-grid';

            // Create chart column (left side)
            const chartColumn = document.createElement('div');
            chartColumn.className = 'chart-column';

            // Create data column (right side)
            const dataColumn = document.createElement('div');
            dataColumn.className = 'data-column';

            // Individual Properties Section
            const individualSection = document.createElement('div');
            individualSection.innerHTML = '<h6 class="stats-label mb-10">Individual Property Frequency</h6>';
            
            const propertiesList = document.createElement('div');
            propertiesList.className = 'white-card-300 green-border-left';
            
            const propertyItems = sortedProperties.map(([property, count]) => {
                const percentage = ((count / allAliases.length) * 100).toFixed(1);
                return `<div class="stats-item">
                    <span class="stats-label">${property}</span>
                    <span class="color-666">${count} (${percentage}%)</span>
                </div>`;
            }).join('');
            
            propertiesList.innerHTML = propertyItems;
            individualSection.appendChild(propertiesList);

            // Property Combinations Section
            const combinationsSection = document.createElement('div');
            combinationsSection.innerHTML = '<h6 style="color: #2E7D32; margin-bottom: 10px;">Property Combinations Found</h6>';
            
            const combinationsList = document.createElement('div');
            combinationsList.className = 'white-card-300 green-border-left-light';
            
            const combinationItems = sortedCombinations.map(([combination, count]) => {
                const percentage = ((count / allAliases.length) * 100).toFixed(1);
                return `<div class="stats-item-alt">
                    <span class="stats-label text-sm">${combination}</span>
                    <span class="color-666">${count} (${percentage}%)</span>
                </div>`;
            }).join('');
            
            combinationsList.innerHTML = combinationItems;
            combinationsSection.appendChild(combinationsList);

            // Create container for doughnut chart that will be added later
            const chartPlaceholder = document.createElement('div');
            chartPlaceholder.id = 'propertyDistributionChartPlaceholder';
            chartPlaceholder.className = 'white-card green-border-left-dark chart-placeholder';
            chartPlaceholder.innerHTML = '<p style="color: #666; text-align: center;">Property Distribution Chart will appear here</p>';

            // Add sections to columns
            chartColumn.appendChild(chartPlaceholder);
            dataColumn.appendChild(individualSection);
            dataColumn.appendChild(combinationsSection);

            // Add columns to responsive container
            responsiveContainer.appendChild(chartColumn);
            responsiveContainer.appendChild(dataColumn);

            // Add responsive container to main container
            container.appendChild(responsiveContainer);

            // Add responsive styles for smaller screens
            const mediaQuery = document.createElement('style');
            mediaQuery.textContent = `
                @media (max-width: 768px) {
                    #topProductsList > div:last-child {
                        grid-template-columns: 1fr !important;
                    }
                    #topProductsList > div:last-child > div {
                        margin-bottom: 20px;
                    }
                }
            `;
            document.head.appendChild(mediaQuery);
        }

        function displayAliasesByFrequency(sortedAliases) {
            const container = document.getElementById('aliasGroups');
            container.innerHTML = '';

            // Store current alias data for selection functionality
            storeCurrentAliasData(sortedAliases);

            if (sortedAliases.length === 0) {
                container.innerHTML = '<div class="no-data">No alias data available</div>';
                return;
            }

            // Separate confirmed mappings from other aliases
            const confirmedMappings = sortedAliases.filter(alias => 
                alias.isConfirmedMapping === true);
            const otherAliases = sortedAliases.filter(alias => 
                alias.isConfirmedMapping !== true);

            // Create sections - confirmed mappings first (grouped by CPE), then consolidated others
            const sections = [];
            
            if (confirmedMappings.length > 0) {
                // Group confirmed mappings by CPE base string
                const cpeGroups = {};
                confirmedMappings.forEach(alias => {
                    const cpeKey = alias.cpeBaseString || alias.cpe_base_string || alias.cpebasestring || 'unknown';
                    if (!cpeGroups[cpeKey]) {
                        cpeGroups[cpeKey] = [];
                    }
                    cpeGroups[cpeKey].push(alias);
                });
                
                // Add a single parent section for all confirmed mappings
                sections.push({
                    title: `Confirmed Mappings (${confirmedMappings.length} aliases)`, 
                    aliases: [], // Will be rendered as CPE groups 
                    priority: 'confirmed-parent',
                    collapsed: true,
                    description: 'Previously validated CPE mappings from authoritative sources',
                    isConfirmedParent: true,
                    cpeGroups: cpeGroups
                });
            }
            
            if (otherAliases.length > 0) {
                sections.push({
                    title: `Unconfirmed Aliases (${otherAliases.length} aliases)`, 
                    aliases: otherAliases, 
                    priority: 'unconfirmed',
                    collapsed: false,
                    description: 'Aliases requiring manual validation and CPE mapping'
                });
            }

            sections.forEach(section => {
                // Simple section header with collapse functionality
                const sectionHeader = document.createElement('div');
                const isCpeGroup = section.isCpeGroup;
                const isConfirmedSection = section.priority.startsWith('confirmed');
                const toggleId = `section-${section.priority}`;
                
                const headerColor = isCpeGroup ? 
                    'linear-gradient(135deg, #2E7D32, #4CAF50)' : 
                    isConfirmedSection ? 
                        'linear-gradient(135deg, #4CAF50, #66BB6A)' : 
                        'linear-gradient(135deg, #4CAF50, #66BB6A)';
                
                sectionHeader.className = 'aliases-section-header gradient-green';
                sectionHeader.style.background = headerColor;
                
                sectionHeader.innerHTML = `
                    <div class="section-header-flex">
                        <div style="text-align: left; flex: 1;">
                            <span style="font-weight: 600;">${section.title}</span>
                            <div style="font-size: 0.8em; opacity: 0.9; margin-top: 1px;">${section.description}</div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                            ${section.isConfirmedParent ? `
                                <button id="${toggleId}-download" class="download-btn" title="Download Confirmed Mappings JSON" 
                                        style="background: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.3); 
                                               border-radius: 4px; padding: 4px 8px; color: white; font-size: 0.85em; 
                                               cursor: pointer; display: flex; align-items: center; gap: 4px;
                                               transition: all 0.2s ease;">
                                    <i class="fas fa-download" style="font-size: 0.8em;"></i>
                                    <span>JSON</span>
                                </button>
                            ` : ''}
                            <span id="${toggleId}-toggle" class="collapsible-toggle" style="font-size: 1.1em;">
                                ${section.collapsed ? '▶' : '▼'}
                            </span>
                        </div>
                    </div>
                `;
                
                // Add click handler for collapse/expand with smooth transitions
                sectionHeader.addEventListener('click', (e) => {
                    // Don't collapse/expand if clicking the download button
                    if (e.target.closest('.download-btn')) {
                        return;
                    }
                    
                    const content = document.getElementById(toggleId + '-content');
                    const toggle = document.getElementById(toggleId + '-toggle');
                    const isCollapsed = content.classList.contains('collapsed');
                    
                    if (isCollapsed) {
                        content.classList.remove('collapsed');
                        toggle.textContent = '▼';
                        toggle.classList.add('rotated');
                    } else {
                        content.classList.add('collapsed');
                        toggle.textContent = '▶';
                        toggle.classList.remove('rotated');
                    }
                });
                
                // Add download button functionality for confirmed mappings
                if (section.isConfirmedParent) {
                    const downloadBtn = sectionHeader.querySelector(`#${toggleId}-download`);
                    if (downloadBtn) {
                        // Add hover effects
                        downloadBtn.addEventListener('mouseenter', () => {
                            downloadBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                            downloadBtn.style.transform = 'translateY(-1px)';
                        });
                        
                        downloadBtn.addEventListener('mouseleave', () => {
                            downloadBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                            downloadBtn.style.transform = 'translateY(0)';
                        });
                        
                        // Add download functionality
                        downloadBtn.addEventListener('click', (e) => {
                            e.stopPropagation(); // Prevent section collapse/expand
                            downloadConfirmedMappingsJSON(section.cpeGroups);
                        });
                    }
                }
                
                container.appendChild(sectionHeader);

                // Section container with smooth collapse support
                const sectionContainer = document.createElement('div');
                sectionContainer.id = toggleId + '-content';
                sectionContainer.className = `aliases-section-container collapsible-content ${section.collapsed ? 'collapsed' : ''}`;

                // Special handling for confirmed parent section - render CPE groups
                if (section.isConfirmedParent && section.cpeGroups) {
                    Object.keys(section.cpeGroups).sort().forEach((cpeString, cpeIndex) => {
                        const aliases = section.cpeGroups[cpeString];
                        
                        // Create CPE group header
                        const cpeGroupDiv = document.createElement('div');
                        cpeGroupDiv.className = 'cpe-group-div white-card-compact';
                        
                        const cpeHeader = document.createElement('div');
                        const cpeToggleId = `cpe-group-${cpeIndex}`;
                        cpeHeader.className = 'cpe-header gradient-green-dark';
                        cpeHeader.innerHTML = `
                            <span>${cpeString} (${aliases.length} aliases)</span>
                            <span id="${cpeToggleId}-toggle" class="collapsible-toggle">▶</span>
                        `;
                        
                        // CPE group content with smooth transitions
                        const cpeContent = document.createElement('div');
                        cpeContent.id = cpeToggleId + '-content';
                        cpeContent.className = 'cpe-collapsible-content collapsed';
                        
                        // Add click handler for CPE group collapse/expand with dynamic height calculation
                        cpeHeader.addEventListener('click', () => {
                            const content = document.getElementById(cpeToggleId + '-content');
                            const toggle = document.getElementById(cpeToggleId + '-toggle');
                            const isCollapsed = content.classList.contains('collapsed');
                            
                            if (isCollapsed) {
                                content.classList.remove('collapsed');
                                toggle.textContent = '▼';
                                toggle.classList.add('rotated');
                                setCpeContentHeight(content, true);
                            } else {
                                content.classList.add('collapsed');
                                toggle.textContent = '▶';
                                toggle.classList.remove('rotated');
                                setCpeContentHeight(content, false);
                            }
                        });
                        
                        // Render aliases within this CPE group using the same system as unconfirmed aliases
                        console.log(`Rendering ${aliases.length} aliases for CPE: ${cpeString}`);
                        aliases.forEach((alias, aliasIndex) => {
                            try {
                                console.log(`Processing alias ${aliasIndex + 1}:`, alias.vendor, alias.product, `CVEs: ${alias.source_cve?.length || 0}`);
                                // Mark this alias as confirmed for proper rendering
                                alias.isConfirmedMapping = true;
                            
                            // Create a temporary section structure to reuse the existing rendering logic
                            const tempSection = {
                                aliases: [alias],
                                isCpeGroup: true,
                                priority: 'confirmed'
                            };
                            
                            // Use the same alias rendering logic as unconfirmed aliases
                            const globalIndex = currentAliasData ? currentAliasData.findIndex(item => 
                                item === alias || (
                                    item.vendor === alias.vendor && 
                                    item.product === alias.product && 
                                    item.frequency === alias.frequency &&
                                    item.platforms === alias.platforms &&
                                    item.version === alias.version &&
                                    item.update === alias.update &&
                                    item.edition === alias.edition &&
                                    item.language === alias.language &&
                                    item.sw_edition === alias.sw_edition &&
                                    item.target_sw === alias.target_sw &&
                                    item.target_hw === alias.target_hw &&
                                    item.other === alias.other &&
                                    JSON.stringify(item.source_cve || []) === JSON.stringify(alias.source_cve || [])
                                )
                            ) : aliasIndex;
                            
                            const aliasDiv = document.createElement('div');
                            aliasDiv.className = 'alias-group';
                            aliasDiv.style.margin = '0';
                            aliasDiv.style.border = 'none';
                            aliasDiv.style.borderBottom = aliasIndex < aliases.length - 1 ? '1px solid #E0E0E0' : 'none';
                            aliasDiv.style.borderRadius = '0';
                            aliasDiv.style.backgroundColor = '#ffffff';

                            const headerDiv = document.createElement('div');
                            headerDiv.className = 'alias-group-header';
                            headerDiv.style.padding = '20px';
                            
                            // This alias is confirmed
                            const isConfirmed = true;
                            
                            // Create comprehensive alias summary using the same logic
                            const aliasProps = [];
                            
                            // Core properties - only show if they exist
                            if (alias.vendor) {
                                aliasProps.push(`<strong>Vendor:</strong> ${alias.vendor}`);
                            }
                            if (alias.product) {
                                aliasProps.push(`<strong>Product:</strong> ${alias.product}`);
                            }
                            if (alias.platform || alias.platforms) {
                                aliasProps.push(`<strong>Platform:</strong> ${alias.platform || alias.platforms}`);
                            }
                            
                            // Additional CVE 5.X properties that might be present
                            const additionalFields = ['collectionURL', 'packageName', 'programRoutines', 
                                                    'programFiles', 'modules', 'defaultStatus', 'repo'];
                            
                            additionalFields.forEach(field => {
                                if (alias[field] && alias[field] !== 'N/A' && alias[field] !== '') {
                                    let value = alias[field];
                                    if (Array.isArray(value)) {
                                        value = value.join(', ');
                                    }
                                    
                                    // Format field name for display
                                    const displayField = field.charAt(0).toUpperCase() + field.slice(1);
                                    aliasProps.push(`<strong>${displayField}:</strong> ${value}`);
                                }
                            });
                            
                            // Add confirmed metadata if available  
                            if (alias.last_updated) {
                                const updateTime = new Date(alias.last_updated).toLocaleDateString();
                                aliasProps.push(`<strong>Last Updated:</strong> ${updateTime}`);
                            }
                            
                            if (alias.confirmed_by) {
                                const confirmedBy = Array.isArray(alias.confirmed_by) ? alias.confirmed_by.join(', ') : alias.confirmed_by;
                                aliasProps.push(`<strong>Confirmed By:</strong> ${confirmedBy}`);
                            }
                            
                            // Create alias title using the same logic
                            const aliasTitle = alias.vendor && alias.product ? 
                                `${alias.vendor} ${alias.product}` :
                                alias.product || alias.vendor || 
                                alias.packageName || alias.programFiles || 
                                `Alias ${aliasIndex + 1}`;
                            
                            // Use the same header HTML structure as unconfirmed aliases
                            headerDiv.innerHTML = `
                                <div class="alias-header">
                                    <div class="flex-between gap-10">
                                        <div class="flex-start">
                                            <div class="flex-1">
                                                <div class="flex-center mb-6">
                                                    <span class="alias-title">${aliasTitle}</span>
                                                    <span class="confirmed-badge">CONFIRMED</span>
                                                </div>
                                                <div class="alias-properties">
                                                    ${aliasProps.join('<br>')}
                                                </div>
                                                ${alias.container_type ? `<div class="alias-container-info"><strong>Container:</strong> ${alias.container_type}</div>` : ''}
                                            </div>
                                        </div>
                                        <div class="flex-center flex-shrink-0 pt-2">
                                            <span class="cve-count">${alias.frequency || alias.source_cve?.length || 0} CVEs</span>
                                            <div class="expand-caret">▼</div>
                                        </div>
                                    </div>
                                </div>
                            `;

                            // Use the same details structure as unconfirmed aliases
                            const detailsDiv = document.createElement('div');
                            detailsDiv.className = 'alias-details';

                            // Add detailed content using the same system
                            const cveGroups = groupCvesByYear(alias.source_cve || []);
                            const cveGroupsHtml = generateCveGroupsHtml(cveGroups);

                            detailsDiv.innerHTML = `
                                <div class="alias-item" style="margin: 0;">
                                    <div style="margin-bottom: 8px;">
                                        <strong>CVE References by Year:</strong>
                                    </div>
                                    ${cveGroupsHtml}
                                </div>
                            `;

                            aliasDiv.appendChild(headerDiv);
                            aliasDiv.appendChild(detailsDiv);

                            // Use the same click handler logic as unconfirmed aliases
                            headerDiv.addEventListener('click', function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                
                                const isExpanded = detailsDiv.classList.contains('expanded');
                                const caret = headerDiv.querySelector('.expand-caret');
                                
                                if (isExpanded) {
                                    detailsDiv.classList.remove('expanded');
                                    caret.textContent = '▶';
                                    caret.classList.remove('rotated');
                                } else {
                                    detailsDiv.classList.add('expanded');
                                    caret.textContent = '▼';
                                    caret.classList.add('rotated');
                                }
                                
                                // Update parent CPE section height after alias expansion/collapse
                                updateCpeContentHeight(detailsDiv);
                            });

                            cpeContent.appendChild(aliasDiv);
                            } catch (error) {
                                console.error(`Error rendering confirmed alias ${aliasIndex}:`, error, alias);
                                // Create a minimal error display for this alias
                                const errorDiv = document.createElement('div');
                                errorDiv.className = 'alias-group';
                                errorDiv.style.padding = '10px';
                                errorDiv.style.backgroundColor = '#ffeaea';
                                errorDiv.innerHTML = `<div style="color: #d32f2f;">Error rendering alias: ${getDisplayValue(alias.vendor, 'Unknown Vendor')} ${getDisplayValue(alias.product, 'Unknown Product')}</div>`;
                                cpeContent.appendChild(errorDiv);
                            }
                        });
                        
                        cpeGroupDiv.appendChild(cpeHeader);
                        cpeGroupDiv.appendChild(cpeContent);
                        sectionContainer.appendChild(cpeGroupDiv);
                    });
                } else {
                    // Normal section rendering for unconfirmed aliases
                    section.aliases.forEach((alias, index) => {
                    // Find the global index of this alias in currentAliasData using comprehensive comparison
                    const globalIndex = currentAliasData ? currentAliasData.findIndex(item => 
                        item === alias || (
                            item.vendor === alias.vendor && 
                            item.product === alias.product && 
                            item.frequency === alias.frequency &&
                            item.platforms === alias.platforms &&
                            item.version === alias.version &&
                            item.update === alias.update &&
                            item.edition === alias.edition &&
                            item.language === alias.language &&
                            item.sw_edition === alias.sw_edition &&
                            item.target_sw === alias.target_sw &&
                            item.target_hw === alias.target_hw &&
                            item.other === alias.other &&
                            JSON.stringify(item.source_cve || []) === JSON.stringify(alias.source_cve || [])
                        )
                    ) : index;
                    
                    const aliasDiv = document.createElement('div');
                    aliasDiv.className = 'alias-group';
                    aliasDiv.style.margin = '0';
                    aliasDiv.style.border = 'none';
                    aliasDiv.style.borderBottom = index < section.aliases.length - 1 ? '1px solid #E0E0E0' : 'none';
                    aliasDiv.style.borderRadius = '0';
                    aliasDiv.style.backgroundColor = '#ffffff';

                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'alias-group-header';
                    headerDiv.style.padding = '20px';
                    
                    // Check if this is a confirmed mapping
                    const isConfirmed = section.isCpeGroup || section.priority.startsWith('confirmed') || 
                                       alias.isConfirmedMapping === true;
                    
                    // Create comprehensive alias summary
                    const aliasProps = [];
                    
                    // Show confirmed mapping indicator or frequency priority
                    if (isConfirmed) {
                        // For confirmed mappings, just show basic alias properties - no extra indicators
                    }
                    // Note: Removed frequency-based priority and group display as requested
                    
                    // Core properties - only show if they exist
                    if (alias.vendor) {
                        aliasProps.push(`<strong>Vendor:</strong> ${alias.vendor}`);
                    }
                    if (alias.product) {
                        aliasProps.push(`<strong>Product:</strong> ${alias.product}`);
                    }
                    if (alias.platform || alias.platforms) {
                        aliasProps.push(`<strong>Platform:</strong> ${alias.platform || alias.platforms}`);
                    }
                    
                    // Additional CVE 5.X properties that might be present
                    const additionalFields = ['collectionURL', 'packageName', 'programRoutines', 
                                            'programFiles', 'modules', 'defaultStatus', 'repo'];
                    
                    additionalFields.forEach(field => {
                        if (alias[field] && alias[field] !== 'N/A' && alias[field] !== '') {
                            let value = alias[field];
                            if (Array.isArray(value)) {
                                value = value.join(', ');
                            }
                            if (typeof value === 'string' && value.length > 50) {
                                value = value.substring(0, 47) + '...';
                            }
                            aliasProps.push(`<strong>${field}:</strong> ${value}`);
                        }
                    });
                    
                    // Enhanced property display features
                    if (alias.lastUpdated || alias.last_updated) {
                        const updateTime = alias.lastUpdated || alias.last_updated;
                        aliasProps.push(`<strong>Last Updated:</strong> ${updateTime}`);
                    }
                    
                    if (alias.confirmedBy || alias.confirmed_by) {
                        const confirmedBy = alias.confirmedBy || alias.confirmed_by;
                        aliasProps.push(`<strong>Confirmed By:</strong> ${confirmedBy}`);
                    }
                    
                    // Create alias title from vendor/product or other identifying fields
                    const aliasTitle = alias.vendor && alias.product ? 
                        `${alias.vendor} ${alias.product}` :
                        alias.product || alias.vendor || 
                        alias.packageName || alias.programFiles || 
                        `Alias ${globalIndex + 1}`;
                    
                    headerDiv.innerHTML = `
                        <div class="alias-header">
                            <div class="flex-between gap-10">
                                <div class="flex-start">
                                    ${!isConfirmed ? `<input type="checkbox" class="alias-selection-checkbox" 
                                           onchange="toggleAliasSelection(this, ${globalIndex})" 
                                           onclick="event.stopPropagation()"
                                           class="mt-2">` : ''}
                                    <div class="flex-1">
                                        <div class="flex-center mb-6">
                                            <span class="alias-title">${aliasTitle}</span>
                                            ${isConfirmed ? '<span class="confirmed-badge">CONFIRMED</span>' : ''}
                                        </div>
                                        <div class="alias-properties">
                                            ${aliasProps.join('<br>')}
                                        </div>
                                        ${alias.container_type ? `<div class="alias-container-info"><strong>Container:</strong> ${alias.container_type}</div>` : ''}
                                    </div>
                                </div>
                                ${!isConfirmed ? `<div class="flex-center flex-shrink-0 pt-2">
                                    <span class="cve-count">${alias.frequency || alias.source_cve?.length || 0} CVEs</span>
                                    <div class="expand-caret">▼</div>
                                </div>` : ''}
                            </div>
                        </div>
                    `;

                    const detailsDiv = document.createElement('div');
                    detailsDiv.className = 'alias-details';

                    // Only add detailed content for non-confirmed mappings
                    if (!isConfirmed) {
                        // Group CVEs by year for better organization
                        const cveGroups = groupCvesByYear(alias.source_cve);
                        const cveGroupsHtml = generateCveGroupsHtml(cveGroups);

                        // Show detailed CVE information with year grouping
                        detailsDiv.innerHTML = `
                            <div class="alias-item" style="margin: 0;">
                                <div style="margin-bottom: 8px;">
                                    <strong>CVE References by Year:</strong>
                                </div>
                                <div class="cve-year-groups">
                                    ${cveGroupsHtml}
                                </div>
                            </div>
                        `;

                        headerDiv.addEventListener('click', function() {
                            const icon = headerDiv.querySelector('.expand-icon') || headerDiv.querySelector('.expand-caret');
                            const isExpanded = detailsDiv.classList.contains('expanded');
                            
                            if (isExpanded) {
                                detailsDiv.classList.remove('expanded');
                                headerDiv.classList.remove('expanded');
                                if (icon) icon.classList.remove('rotated');
                            } else {
                                detailsDiv.classList.add('expanded');
                                headerDiv.classList.add('expanded');
                                if (icon) icon.classList.add('rotated');
                            }
                        });
                    }

                    aliasDiv.appendChild(headerDiv);
                    aliasDiv.appendChild(detailsDiv);
                    sectionContainer.appendChild(aliasDiv);
                });
                } // Close the else block for normal section rendering

                container.appendChild(sectionContainer);
            });
        }

        function displaySourceDataConcerns(concerningAliases) {
            const container = document.getElementById('sourceDataConcernGroups');
            container.innerHTML = '';

            if (concerningAliases.length === 0) {
                return; // Don't show anything if no concerns
            }

            // Store concerning aliases data for selection functionality
            if (!currentAliasData) {
                currentAliasData = [];
            }
            
            // Add concerning aliases to current data with unique identifiers
            concerningAliases.forEach((alias, index) => {
                const concernIndex = `concern_${index}`;
                currentAliasData[concernIndex] = alias;
            });

            // Create the main section header
            const sectionHeader = document.createElement('div');
            const toggleId = 'source-data-concerns';
            
            sectionHeader.className = 'aliases-section-header gradient-green';
            
            sectionHeader.innerHTML = `
                <div class="section-header-flex">
                    <div style="text-align: left; flex: 1;">
                        <span style="font-weight: 600;">Source Data Concerns (${concerningAliases.length} aliases)</span>
                        <div style="font-size: 0.8em; opacity: 0.9; margin-top: 1px;">Aliases requiring upstream data contributor attention</div>
                    </div>
                    <span id="${toggleId}-toggle" class="collapsible-toggle" style="font-size: 1.1em; flex-shrink: 0;">▼</span>
                </div>
            `;
            
            // Add click handler for collapse/expand with smooth transitions
            sectionHeader.addEventListener('click', () => {
                const content = document.getElementById(toggleId + '-content');
                const toggle = document.getElementById(toggleId + '-toggle');
                const isCollapsed = content.classList.contains('collapsed');
                
                if (isCollapsed) {
                    content.classList.remove('collapsed');
                    toggle.textContent = '▼';
                    toggle.classList.add('rotated');
                } else {
                    content.classList.add('collapsed');
                    toggle.textContent = '▶';
                    toggle.classList.remove('rotated');
                }
            });
            
            container.appendChild(sectionHeader);

            // Section container with smooth transitions
            const sectionContainer = document.createElement('div');
            sectionContainer.id = toggleId + '-content';
            sectionContainer.className = 'aliases-section-container collapsible-content';

            // Render aliases exactly like the main unconfirmed aliases section
            concerningAliases.forEach((alias, aliasIndex) => {
                // Create a unique index for this section to avoid conflicts with main section
                const concernGlobalIndex = `concern_${aliasIndex}`;
                
                const aliasDiv = document.createElement('div');
                aliasDiv.className = 'alias-group';
                aliasDiv.style.margin = '0';
                aliasDiv.style.border = 'none';
                aliasDiv.style.borderBottom = aliasIndex < concerningAliases.length - 1 ? '1px solid #E0E0E0' : 'none';
                aliasDiv.style.borderRadius = '0';
                aliasDiv.style.backgroundColor = '#ffffff';

                const headerDiv = document.createElement('div');
                headerDiv.className = 'alias-group-header';
                headerDiv.style.padding = '20px';

                // Use the exact same format as the main unconfirmed aliases
                headerDiv.innerHTML = `
                    <div style="margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #E0E0E0;">
                        <div class="section-header-flex-start">
                            <div style="display: flex; align-items: flex-start; gap: 8px;">
                                <input type="checkbox" class="alias-selection-checkbox" 
                                       onchange="toggleAliasSelection(this, '${concernGlobalIndex}')" 
                                       onclick="event.stopPropagation()"
                                       style="margin-top: 2px;"
                                       data-alias-data='${JSON.stringify(alias).replace(/'/g, "&apos;")}'>
                                <div style="flex: 1; min-width: 0;">
                                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                        <span style="color: #333; font-size: 0.95em; font-weight: 600;">
                                            ${[getDisplayValue(alias.vendor), getDisplayValue(alias.product, 'Product')].filter(v => v).join(' ')}
                                        </span>
                                    </div>
                                    <div style="font-size: 0.85em; line-height: 1.3;">
                                        ${!isPlaceholderValue(alias.vendor) ? `<strong>Vendor:</strong> ${alias.vendor}<br>` : ''}
                                        ${!isPlaceholderValue(alias.product) ? `<strong>Product:</strong> ${alias.product}<br>` : ''}
                                        ${!isPlaceholderValue(alias.platforms) ? `<strong>Platform:</strong> ${alias.platforms}<br>` : ''}
                                    </div>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px; flex-shrink: 0; padding-top: 2px;">
                                <span style="color: #666; font-size: 0.85em; font-weight: 600;">${alias.cveCount} CVEs</span>
                                <div class="expand-icon" style="font-size: 1.2em; color: #666; cursor: pointer;">▼</div>
                            </div>
                        </div>
                    </div>
                `;

                const detailsDiv = document.createElement('div');
                detailsDiv.className = 'alias-details';

                // Generate concern details with full issue descriptions
                const concernDetails = alias.concerns.map(concern => {
                    // Use the detailed issue description captured during detection
                    return concern.issue || `${concern.field}: ${concern.value}`;
                }).join('<br>');

                // Group CVEs by year for better organization
                const cveGroups = groupCvesByYear(alias.source_cve);
                const cveGroupsHtml = generateCveGroupsHtml(cveGroups);

                detailsDiv.innerHTML = `
                    <div class="alias-item" style="margin: 0;">
                        <div style="margin-bottom: 12px;">
                            <strong>Concern(s) Identified:</strong><br>
                            <div class="concern-details">
                                ${concernDetails}
                            </div>
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>CVE References by Year:</strong>
                        </div>
                        <div class="cve-year-groups">
                            ${cveGroupsHtml}
                        </div>
                    </div>
                `;

                headerDiv.addEventListener('click', function() {
                    const icon = headerDiv.querySelector('.expand-icon') || headerDiv.querySelector('.expand-caret');
                    const isExpanded = detailsDiv.classList.contains('expanded');
                    
                    if (isExpanded) {
                        detailsDiv.classList.remove('expanded');
                        headerDiv.classList.remove('expanded');
                        if (icon) icon.classList.remove('rotated');
                    } else {
                        detailsDiv.classList.add('expanded');
                        headerDiv.classList.add('expanded');
                        if (icon) icon.classList.add('rotated');
                    }
                });

                aliasDiv.appendChild(headerDiv);
                aliasDiv.appendChild(detailsDiv);
                sectionContainer.appendChild(aliasDiv);
            });

            container.appendChild(sectionContainer);
        }

        // Toggle CVE year group visibility
        function toggleCveYear(header) {
            const content = header.nextElementSibling;
            const toggle = header.querySelector('.cve-year-toggle');
            
            // Check computed style instead of inline style
            const isHidden = window.getComputedStyle(content).display === 'none';
            
            if (isHidden) {
                content.style.display = 'block';
                toggle.style.transform = 'rotate(180deg)';
                toggle.textContent = '▲';
            } else {
                content.style.display = 'none';
                toggle.style.transform = 'rotate(0deg)';
                toggle.textContent = '▼';
            }
            
            // Update parent CPE section height after CVE expansion/collapse
            updateCpeContentHeight(content);
        }

        function updateCpeContentHeight(changedElement) {
            // Find the parent CPE content container
            let cpeContent = changedElement;
            while (cpeContent && !cpeContent.classList.contains('cpe-collapsible-content')) {
                cpeContent = cpeContent.parentElement;
            }
            
            if (cpeContent && !cpeContent.classList.contains('collapsed')) {
                // Calculate the natural height of all content
                const originalHeight = cpeContent.style.height;
                cpeContent.style.height = 'auto';
                const newHeight = cpeContent.scrollHeight;
                cpeContent.style.height = originalHeight;
                
                // Animate to the new height
                requestAnimationFrame(() => {
                    cpeContent.style.height = newHeight + 'px';
                });
            }
        }

        function setCpeContentHeight(cpeContent, isExpanding) {
            if (isExpanding) {
                // Set height to auto temporarily to measure content
                cpeContent.style.height = 'auto';
                const height = cpeContent.scrollHeight;
                cpeContent.style.height = '0px';
                
                // Force a reflow and then animate to full height
                requestAnimationFrame(() => {
                    cpeContent.style.height = height + 'px';
                });
            } else {
                // Animate to zero height
                const height = cpeContent.scrollHeight;
                cpeContent.style.height = height + 'px';
                
                requestAnimationFrame(() => {
                    cpeContent.style.height = '0px';
                });
            }
        }

        // Allow drag and drop
        document.addEventListener('DOMContentLoaded', function() {
            const container = document.querySelector('.container');

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                container.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                container.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                container.addEventListener(eventName, unhighlight, false);
            });

            function highlight(e) {
                container.style.opacity = '0.8';
            }

            function unhighlight(e) {
                container.style.opacity = '1';
            }

            container.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;

                if (files.length > 0) {
                    fileInput.files = files;
                    loadFile();
                }
            }
        });

        // Alias Selection and Consolidation Functions
        let selectedAliases = new Set();
        let currentAliasData = null;
        let currentConsolidatedData = null; // Store the raw consolidated data

        function makeDraggable() {
            const modal = document.getElementById('modalContent');
            const header = document.getElementById('modalHeader');
            let isDragging = false;
            let currentX = 0;
            let currentY = 0;
            let initialX = 0;
            let initialY = 0;

            header.addEventListener('mousedown', function(e) {
                initialX = e.clientX - currentX;
                initialY = e.clientY - currentY;
                
                if (e.target === header || e.target.tagName === 'H3') {
                    isDragging = true;
                }
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    
                    modal.style.transform = `translate(${currentX}px, ${currentY}px)`;
                }
            });

            document.addEventListener('mouseup', function() {
                isDragging = false;
            });
        }

        function toggleAliasSelection(checkbox, aliasIndex) {
            // Stop event propagation to prevent row expansion
            event.stopPropagation();
            
            if (checkbox.checked) {
                selectedAliases.add(aliasIndex);
            } else {
                selectedAliases.delete(aliasIndex);
            }
            updateSelectionPanel();
            
            // Update modal content if it's open
            if (currentConsolidatedData) {
                updateConsolidatedOutput();
            }
        }

        function updateSelectionPanel() {
            const panel = document.getElementById('selectionPanel');
            const countSpan = document.getElementById('selectionCount');
            const listDiv = document.getElementById('selectionList');
            const consolidateBtn = document.getElementById('consolidateBtn');

            countSpan.textContent = selectedAliases.size;
            
            if (selectedAliases.size === 0) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';
            
            // Update selection list
            listDiv.innerHTML = '';
            selectedAliases.forEach(index => {
                if (currentAliasData && currentAliasData[index]) {
                    const alias = currentAliasData[index];
                    const aliasTitle = alias.vendor && alias.product ? 
                        `${alias.vendor} ${alias.product}` :
                        alias.product || alias.vendor || 
                        alias.packageName || alias.programFiles || 
                        `Alias ${index + 1}`;
                    
                    const item = document.createElement('div');
                    item.className = 'selection-item';
                    item.innerHTML = `
                        <span>${aliasTitle}</span>
                    `;
                    listDiv.appendChild(item);
                }
            });

            consolidateBtn.disabled = selectedAliases.size < 1;
        }

        function consolidateAliases() {
            if (selectedAliases.size < 1) {
                alert('Please select at least 1 alias to consolidate.');
                return;
            }

            // Collect all selected aliases
            const aliasesToConsolidate = Array.from(selectedAliases).map(index => 
                currentAliasData[index]
            ).filter(alias => alias);

            // Store the raw consolidated data
            currentConsolidatedData = [];

            // Create separate entry for each selected alias (no consolidation)
            aliasesToConsolidate.forEach(alias => {
                const aliasEntry = {};

                // Include relevant properties only if they exist and have valid values
                ['vendor', 'product', 'version', 'update', 'edition', 'language', 'sw_edition', 'target_sw', 'target_hw', 'other'].forEach(prop => {
                    if (!isPlaceholderValue(alias[prop])) {
                        // Convert arrays to single string values
                        if (Array.isArray(alias[prop])) {
                            aliasEntry[prop] = alias[prop][0]; // Take first element
                        } else {
                            aliasEntry[prop] = alias[prop];
                        }
                    }
                });

                // Handle special properties - only include if they exist, convert arrays to strings
                if (!isPlaceholderValue(alias.platforms)) {
                    if (Array.isArray(alias.platforms)) {
                        aliasEntry.platform = alias.platforms[0]; // Take first platform
                    } else {
                        aliasEntry.platform = alias.platforms;
                    }
                }
                
                if (!isPlaceholderValue(alias.collectionURL)) {
                    if (Array.isArray(alias.collectionURL)) {
                        aliasEntry.collectionURL = alias.collectionURL[0];
                    } else {
                        aliasEntry.collectionURL = alias.collectionURL;
                    }
                }
                
                if (!isPlaceholderValue(alias.packageName)) {
                    if (Array.isArray(alias.packageName)) {
                        aliasEntry.packageName = alias.packageName[0];
                    } else {
                        aliasEntry.packageName = alias.packageName;
                    }
                }
                
                if (alias.programRoutines && alias.programRoutines !== '' && alias.programRoutines !== 'unknown' && alias.programRoutines !== 'n/a') {
                    if (Array.isArray(alias.programRoutines)) {
                        aliasEntry.programRoutines = alias.programRoutines[0];
                    } else {
                        aliasEntry.programRoutines = alias.programRoutines;
                    }
                }
                
                if (alias.programFiles && alias.programFiles !== '' && alias.programFiles !== 'unknown' && alias.programFiles !== 'n/a') {
                    if (Array.isArray(alias.programFiles)) {
                        aliasEntry.programFiles = alias.programFiles[0];
                    } else {
                        aliasEntry.programFiles = alias.programFiles;
                    }
                }
                
                if (alias.modules && alias.modules !== '' && alias.modules !== 'unknown' && alias.modules !== 'n/a') {
                    if (Array.isArray(alias.modules)) {
                        aliasEntry.modules = alias.modules[0];
                    } else {
                        aliasEntry.modules = alias.modules;
                    }
                }
                
                if (alias.repo && alias.repo !== '' && alias.repo !== 'unknown' && alias.repo !== 'n/a') {
                    if (Array.isArray(alias.repo)) {
                        aliasEntry.repo = alias.repo[0];
                    } else {
                        aliasEntry.repo = alias.repo;
                    }
                }

                // Only add the entry if it has at least some properties
                if (Object.keys(aliasEntry).length > 0) {
                    currentConsolidatedData.push(aliasEntry);
                }
            });

            // Clear the CPE input and show modal
            const cpeInput = document.getElementById('cpeBaseString');
            cpeInput.value = 'cpe:2.3:';
            handleCpeInput(cpeInput); // Initialize the display
            populateExistingCpeDropdown();
            updateConsolidatedOutput();
            document.getElementById('outputModal').style.display = 'flex';
            
            // Initialize draggable functionality
            makeDraggable();
        }

        function populateExistingCpeDropdown() {
            const select = document.getElementById('existingCpeSelect');
            select.innerHTML = '<option value="">Or select from existing CPE strings...</option>';

            // Use the global window.currentData which should have the original loaded data
            const dataToUse = window.currentData || currentData;
            
            // Check for confirmed mappings data
            if (!dataToUse || !dataToUse.confirmedMappings) {
                return;
            }

            const existingCpeStrings = new Set();

            // Collect all existing CPE base strings from confirmed mappings
            dataToUse.confirmedMappings.forEach(mapping => {
                // Handle both cpeBaseString and cpebasestring (case variations)
                const cpeString = mapping.cpeBaseString || mapping.cpebasestring;
                if (cpeString) {
                    existingCpeStrings.add(cpeString);
                }
            });

            // Add options to dropdown
            Array.from(existingCpeStrings).sort().forEach(cpeString => {
                const option = document.createElement('option');
                option.value = cpeString;
                option.textContent = cpeString;
                select.appendChild(option);
            });
        }

        function selectExistingCpe() {
            const select = document.getElementById('existingCpeSelect');
            const input = document.getElementById('cpeBaseString');
            
            if (select.value) {
                input.value = select.value;
                handleCpeInput(input); // Trigger validation and update
            }
        }

        function updateConsolidatedOutput() {
            if (!currentConsolidatedData) return;

            const input = document.getElementById('cpeBaseString');
            const inputValue = input.value.trim();
            
            // Get the final CPE (either generated or validated input)
            const finalCpe = input.getAttribute('data-final-cpe') || inputValue;
            
            let outputData;
            
            if (finalCpe && finalCpe.startsWith('cpe:2.3:')) {
                // Get existing aliases for this CPE base string
                const existingAliases = getExistingAliasesForCpe(finalCpe);
                
                // Combine existing aliases with new ones
                const allAliases = [...existingAliases, ...currentConsolidatedData];
                
                // Include cpebasestring in the structure
                outputData = {
                    "cpebasestring": finalCpe,
                    "aliases": allAliases
                };
            } else {
                // No valid CPE base string
                outputData = {
                    "aliases": currentConsolidatedData
                };
            }

            // Use JSON.stringify with proper replacer to handle escaping
            const jsonOutput = JSON.stringify(outputData, (key, value) => {
                // Ensure proper JSON string escaping for all string values
                if (typeof value === 'string') {
                    // JSON.stringify already handles proper escaping, but let's be explicit about CPE strings
                    return value;
                }
                return value;
            }, 2);
            
            document.getElementById('outputContent').textContent = jsonOutput;
        }

        function getExistingAliasesForCpe(cpeBaseString) {
            if (!currentData || !currentData.aliasGroups) return [];

            const existingAliases = [];

            currentData.aliasGroups.forEach(mapping => {
                // Check if this mapping has the matching CPE base string
                if (mapping.cpe_base_string === cpeBaseString) {
                    if (mapping.aliases) {
                        // Add all aliases from this mapping
                        mapping.aliases.forEach(alias => {
                            // Clean the alias - remove internal fields and ensure string properties
                            const cleanAlias = {};
                            
                            ['vendor', 'product', 'version', 'update', 'edition', 'language', 'sw_edition', 'target_sw', 'target_hw', 'other'].forEach(prop => {
                                if (alias[prop] && alias[prop] !== '' && alias[prop] !== 'unknown' && alias[prop] !== 'n/a') {
                                    if (Array.isArray(alias[prop])) {
                                        cleanAlias[prop] = alias[prop][0];
                                    } else {
                                        cleanAlias[prop] = alias[prop];
                                    }
                                }
                            });

                            // Handle special properties
                            if (alias.platforms && alias.platforms !== '' && alias.platforms !== 'unknown' && alias.platforms !== 'n/a') {
                                if (Array.isArray(alias.platforms)) {
                                    cleanAlias.platform = alias.platforms[0];
                                } else {
                                    cleanAlias.platform = alias.platforms;
                                }
                            }
                            
                            ['collectionURL', 'packageName', 'programRoutines', 'programFiles', 'modules', 'repo'].forEach(prop => {
                                if (alias[prop] && alias[prop] !== '' && alias[prop] !== 'unknown' && alias[prop] !== 'n/a') {
                                    if (Array.isArray(alias[prop])) {
                                        cleanAlias[prop] = alias[prop][0];
                                    } else {
                                        cleanAlias[prop] = alias[prop];
                                    }
                                }
                            });

                            if (Object.keys(cleanAlias).length > 0) {
                                existingAliases.push(cleanAlias);
                            }
                        });
                    }
                }
                
                // Also check individual aliases with cpe_base_string
                if (mapping.aliases) {
                    mapping.aliases.forEach(alias => {
                        if (alias.cpe_base_string === cpeBaseString) {
                            const cleanAlias = {};
                            
                            ['vendor', 'product', 'version', 'update', 'edition', 'language', 'sw_edition', 'target_sw', 'target_hw', 'other'].forEach(prop => {
                                if (alias[prop] && alias[prop] !== '' && alias[prop] !== 'unknown' && alias[prop] !== 'n/a') {
                                    if (Array.isArray(alias[prop])) {
                                        cleanAlias[prop] = alias[prop][0];
                                    } else {
                                        cleanAlias[prop] = alias[prop];
                                    }
                                }
                            });

                            if (alias.platforms && alias.platforms !== '' && alias.platforms !== 'unknown' && alias.platforms !== 'n/a') {
                                if (Array.isArray(alias.platforms)) {
                                    cleanAlias.platform = alias.platforms[0];
                                } else {
                                    cleanAlias.platform = alias.platforms;
                                }
                            }

                            ['collectionURL', 'packageName', 'programRoutines', 'programFiles', 'modules', 'repo'].forEach(prop => {
                                if (alias[prop] && alias[prop] !== '' && alias[prop] !== 'unknown' && alias[prop] !== 'n/a') {
                                    if (Array.isArray(alias[prop])) {
                                        cleanAlias[prop] = alias[prop][0];
                                    } else {
                                        cleanAlias[prop] = alias[prop];
                                    }
                                }
                            });

                            if (Object.keys(cleanAlias).length > 0) {
                                existingAliases.push(cleanAlias);
                            }
                        }
                    });
                }
            });

            return existingAliases;
        }

        function closeOutputModal() {
            document.getElementById('outputModal').style.display = 'none';
            currentConsolidatedData = null;
        }

        function copyToClipboard() {
            const content = document.getElementById('outputContent').textContent;
            const copyBtn = document.getElementById('outputModal').querySelector('.modal-btn-primary');
            const originalText = copyBtn.textContent;
            
            navigator.clipboard.writeText(content).then(() => {
                // Visual feedback instead of alert
                copyBtn.textContent = '✓ Copied!';
                copyBtn.style.background = '#4CAF50';
                
                // Reset after 2 seconds
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = '';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
                // Error feedback
                copyBtn.textContent = '✗ Copy Failed';
                copyBtn.style.background = '#ff4444';
                
                // Reset after 2 seconds
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = '';
                }, 2000);
            });
        }

        // Store alias data when displaying
        function storeCurrentAliasData(aliases) {
            currentAliasData = aliases;
            selectedAliases.clear();
            updateSelectionPanel();
        }

        // Modal interaction enhancements for confirmed mappings
        function showModalConfirmed(confirmedMapping) {
            // Show modal specific to confirmed mapping data
            const modal = document.getElementById('outputModal');
            const content = document.getElementById('outputContent');
            
            content.textContent = JSON.stringify({
                "modal": "confirmed mapping data",
                "cve": confirmedMapping.cve,
                "platform": confirmedMapping.platform,
                "aliases": confirmedMapping.aliases
            }, null, 2);
            
            modal.style.display = 'flex';
        }

        function openModalConfirmed(mappingData) {
            // Open modal with confirmed mapping context
            const modalData = {
                "confirmedMappings": mappingData,
                "enhanced": true
            };
            showModalConfirmed(modalData);
        }

        function populateModalConfirmed(data) {
            // Populate modal with data from confirmedMappings array
            if (data && data.confirmedMappings) {
                data.confirmedMappings.forEach(mapping => {
                    // Modal data confirmedMappings processing
                    console.log('Modal processing:', mapping);
                });
            }
        }
    </script>

    <!-- Selection Panel -->
    <div class="selection-panel white-card" id="selectionPanel">
        <h4>Selected Aliases (<span id="selectionCount">0</span>)</h4>
        <div class="selection-list" id="selectionList"></div>
        <button class="consolidate-btn" id="consolidateBtn" onclick="consolidateAliases()">
            Generate Consolidated Mapping
        </button>
    </div>

    <!-- Output Modal -->
    <div class="output-modal" id="outputModal">
        <div class="output-modal-content white-card" id="modalContent">
            <div class="modal-header" id="modalHeader">
                <h3>Consolidated Mapping Output</h3>
            </div>
            <div style="margin-bottom: 16px;">
                <label for="cpeBaseString" style="display: block; margin-bottom: 4px; font-weight: 500;">CPE Base String:</label>
                
                <!-- CPE Builder Input -->
                <div style="margin-bottom: 6px;">
                    <input type="text" id="cpeBaseString" placeholder="a:vendor:product" 
                           class="code-input"
                           oninput="handleCpeInput(this)"
                           onkeydown="handleCpeKeydown(event)">
                    <div id="cpeValidationMessage" style="font-size: 0.75em; margin-top: 2px; height: 18px; overflow: hidden; line-height: 1.2;"></div>
                    <div id="cpePreview" class="code-preview" style="height: 14px; overflow: hidden;"></div>
                </div>
                
                <!-- Existing CPE Dropdown -->
                <div>
                    <select id="existingCpeSelect" 
                            onchange="selectExistingCpe()" 
                            class="form-select"
                            style="width: 100%;">
                        <option value="">Or select from existing CPE strings...</option>
                    </select>
                </div>
            </div>
            <pre id="outputContent" class="code-output"></pre>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-primary" onclick="copyToClipboard()">Copy to Clipboard</button>
                <button class="modal-btn modal-btn-secondary" onclick="closeOutputModal()">Close</button>
            </div>
        </div>
    </div>
</body>
</html>